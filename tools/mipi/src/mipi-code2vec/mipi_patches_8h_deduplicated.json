[
  {
    "PatchId": "Math_50_kPAR_Patch_2815490_100_cp79.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((f1 * fx < 0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_33_TBar_Patch_280845_47_cp28.diff",
    "BugId": "Lang_33",
    "PatchedMethods": [
      {
        "DevIntention": "to|class",
        "OrgCode": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }",
        "PatCode": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { if (classes == null) continue;if (array[i] == null) continue;classes[i] = array[i].getClass(); } return classes; }"
      }
    ]
  },
  {
    "PatchId": "Chart_11_Avatar_Patch_4534073_355.diff",
    "BugId": "Chart_11",
    "PatchedMethods": [
      {
        "DevIntention": "equal",
        "OrgCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule() != p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone() != iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1 != seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "PatCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule() != p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone() != iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1 != seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_Avatar_Patch_49998_12.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_SimFix_patch_834502_2.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables// start of generated patchfor(int i=getNumObjectiveFunctions();i<getArtificialVariableOffset();i++){ final double entry=tableau.getEntry(0,i);if(Precision.compareTo(entry,0.0,epsilon)>0){columnsToDrop.add(i);}}// end of generated patch/* start of original code for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } end of original code*/ // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_dynamoth_patch_78445_3.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (false) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_TBar_Patch_381028_88_cp31.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < startIndex || (endIndex < 0)) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_SimFix_patch_1626021_2.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; }// start of generated patchint index=this.plot.getIndexOf(this);CategoryDataset dataset=this.plot.getDataset(index);if(plot==null){return null;}if(dataset==null){return result;}// end of generated patch/* start of original code int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } end of original code*/ int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_59_Avatar_Patch_301850_15.diff",
    "BugId": "Math_59",
    "PatchedMethods": [
      {
        "DevIntention": "max",
        "OrgCode": "public static float max(final float a, final float b) { return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); }",
        "PatCode": "public static float max(final float a, final float b) { return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a); }"
      }
    ]
  },
  {
    "PatchId": "Math_75_SimFix_patch_32270_1.diff",
    "BugId": "Math_75",
    "PatchedMethods": [
      {
        "DevIntention": "get|pct",
        "OrgCode": "public double getPct(Object v) { return getCumPct((Comparable<?>) v); }",
        "PatCode": "public double getPct(Object v) {// start of generated patchreturn getPct((Comparable<?>)v);// end of generated patch/* start of original code return getCumPct((Comparable<?>) v); end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Math_89_TBar_Patch_98798_14_cp12.diff",
    "BugId": "Math_89",
    "PatchedMethods": [
      {
        "DevIntention": "add|value",
        "OrgCode": "public void addValue(Object v) { addValue((Comparable<?>) v); }",
        "PatCode": "public void addValue(Object v) { if (v instanceof Comparable<?>) {addValue((Comparable<?>) v);} else {throw new IllegalArgumentException(\"Illegal argument: v\");} }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_Avatar_Patch_136255_1.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno <= sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_5_TBar_Patch_4138058_63_cp58.diff",
    "BugId": "Math_5",
    "PatchedMethods": [
      {
        "DevIntention": "reciprocal",
        "OrgCode": "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { return NaN; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "PatCode": "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { return Complex.INF; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_43_SimFix_patch_35321_1.diff",
    "BugId": "Lang_43",
    "PatchedMethods": [
      {
        "DevIntention": "append|quoted|string",
        "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {// start of generated patchint start=pos.getIndex();char[] c=pattern.toCharArray();if(escapingOn&&c[start]==QUOTE){next(pos);return appendTo==null?null:appendTo.append(QUOTE);}// end of generated patch/* start of original code int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } end of original code*/ int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }"
      }
    ]
  },
  {
    "PatchId": "Math_70_FixMiner_Patch_104934_23.diff",
    "BugId": "Math_70",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); }",
        "PatCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(f, min, max); }"
      }
    ]
  },
  {
    "PatchId": "Math_59_SimFix_patch_64680_1.diff",
    "BugId": "Math_59",
    "PatchedMethods": [
      {
        "DevIntention": "max",
        "OrgCode": "public static float max(final float a, final float b) { return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); }",
        "PatCode": "public static float max(final float a, final float b) {// start of generated patchreturn (a<=b)?b:(Float.isNaN(a+b)?Float.NaN:a);// end of generated patch/* start of original code return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_TBar_Patch_21045539_2722_cp1167.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_SimFix_patch_4083698_4.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt);// start of generated patchb.append('\\n');int charno=error.getCharno();if(excerpt.equals(LINE)&&0<=charno&&charno<=sourceExcerpt.length()){for(int i=0;i<charno;i++){char c=sourceExcerpt.charAt(i);if(Character.isWhitespace(c)){b.append(c);}else {b.append(' ');}}b.append(\"^\\n\");}// end of generated patch/* start of original code b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } end of original code*/ } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Chart_24_TBar_Patch_83655_103_cp3.diff",
    "BugId": "Chart_24",
    "PatchedMethods": [
      {
        "DevIntention": "get|paint",
        "OrgCode": "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "PatCode": "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }"
      }
    ]
  },
  {
    "PatchId": "Math_70_jGenProg_patch_13000_134.diff",
    "BugId": "Math_70",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); }",
        "PatCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)org.apache.commons.math.MaxIterationsExceededException, org.apache.commons.math.FunctionEvaluationException { return solve(f, min, max); }"
      }
    ]
  },
  {
    "PatchId": "Mockito_29_TBar_Patch_893152_100_cp45.diff",
    "BugId": "Mockito_29",
    "PatchedMethods": [
      {
        "DevIntention": "describe|to",
        "OrgCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); description.appendText(wanted.toString()); appendQuoting(description); description.appendText(\")\"); }",
        "PatCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); if (wanted != null) {description.appendText(wanted.toString());} appendQuoting(description); description.appendText(\")\"); }"
      }
    ]
  },
  {
    "PatchId": "Mockito_29_Avatar_Patch_600940_73.diff",
    "BugId": "Mockito_29",
    "PatchedMethods": [
      {
        "DevIntention": "describe|to",
        "OrgCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); description.appendText(wanted.toString()); appendQuoting(description); description.appendText(\")\"); }",
        "PatCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); if (wanted != null) {description.appendText(wanted.toString());} appendQuoting(description); description.appendText(\")\"); }"
      }
    ]
  },
  {
    "PatchId": "Chart_24_Avatar_Patch_40361_27.diff",
    "BugId": "Chart_24",
    "PatchedMethods": [
      {
        "DevIntention": "get|paint",
        "OrgCode": "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "PatCode": "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_3544882_122_cp101.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && !(true)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_89_Avatar_Patch_47337_6.diff",
    "BugId": "Math_89",
    "PatchedMethods": [
      {
        "DevIntention": "add|value",
        "OrgCode": "public void addValue(Object v) { addValue((Comparable<?>) v); }",
        "PatCode": "public void addValue(Object v) { if (v instanceof Comparable<?>) {addValue((Comparable<?>) v);} else {throw new IllegalArgumentException(\"Illegal argument: v\");} }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_FixMiner_Patch_70852_12.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { return availableLocaleSet().contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_3344204_116_cp95.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && (f0 == 0.0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_Avatar_Patch_6969131_1421.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) > 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_2782940_99_cp78.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((fx == 0.0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jKali_patch_6000_15.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "illegal|state|exception",
        "OrgCode": "RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { super(registry, null, null); setPrettyPrint(true); for (String property : properties.keySet()) { RecordProperty prop = properties.get(property); if (prop == null) { throw new IllegalStateException( \"RecordProperty associated with a property should not be null!\"); } defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode()); } // Freeze the record type. isFrozen = true; } @Override public boolean isEquivalentTo(JSType other) { if (!other.isRecordType()) { return false; } // Compare properties. RecordType otherRecord = other.toMaybeRecordType(); if (otherRecord == this) { return true; } Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { return false; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { return false; } } return true; } @Override public ObjectType getImplicitPrototype() { return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); } @Override boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); } @Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type // is returned. for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { // In this branch, the other type is some object type. We find // the greatest subtype with the following algorithm: // 1) For each property \"x\" of this record type, take the union // of all classes with a property \"x\" with a compatible property type. // and which are a subtype of {@code that}. // 2) Take the intersection of all of these unions. for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } } return greatestSubtype; } @Override RecordType toMaybeRecordType() { return this; } @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true; } // Top of the record types is the empty record, or OBJECT_TYPE. if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } // A type is a subtype of a record type if it itself is a record // type and it has at least the same members as the parent record type // with the same types. if (!that.isRecordType()) { return false; } return RecordType.isSubtype(this, that.toMaybeRecordType()); }",
        "PatCode": "RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { super(registry, null, null); setPrettyPrint(true); for (String property : properties.keySet()) { RecordProperty prop = properties.get(property); if (prop == null) { throw new IllegalStateException( \"RecordProperty associated with a property should not be null!\"); } defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode()); } // Freeze the record type. isFrozen = true; } @Override public boolean isEquivalentTo(JSType other) { if (!other.isRecordType()) { return false; } // Compare properties. RecordType otherRecord = other.toMaybeRecordType(); if (otherRecord == this) { return true; } Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { return false; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { return false; } } return true; } @Override public ObjectType getImplicitPrototype() { return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); } @Override boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); } @Override public JSType getLeastSupertype(JSType that) {if (true) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type // is returned. for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { // In this branch, the other type is some object type. We find // the greatest subtype with the following algorithm: // 1) For each property \"x\" of this record type, take the union // of all classes with a property \"x\" with a compatible property type. // and which are a subtype of {@code that}. // 2) Take the intersection of all of these unions. for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } } return greatestSubtype; } @Override RecordType toMaybeRecordType() { return this; } @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true; } // Top of the record types is the empty record, or OBJECT_TYPE. if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } // A type is a subtype of a record type if it itself is a record // type and it has at least the same members as the parent record type // with the same types. if (!that.isRecordType()) { return false; } return RecordType.isSubtype(this, that.toMaybeRecordType()); }"
      }
    ]
  },
  {
    "PatchId": "Mockito_38_TBar_Patch_225053_31_cp12.diff",
    "BugId": "Mockito_38",
    "PatchedMethods": [
      {
        "DevIntention": "safely|matches",
        "OrgCode": "private boolean safelyMatches(Matcher m, Object arg) { try { return m.matches(arg); } catch (Throwable t) { return false; } }",
        "PatCode": "private boolean safelyMatches(Matcher m, Object arg) { try { return m.matches(arg); } catch (Throwable t) { return false; } }"
      },
      {
        "DevIntention": "to|string|equals",
        "OrgCode": "private boolean toStringEquals(Matcher m, Object arg) { return StringDescription.toString(m).equals(arg.toString()); }",
        "PatCode": "private boolean toStringEquals(Matcher m, Object arg) { if (!(StringDescription.toString(m) != null && m != null && arg != null)) return false;return StringDescription.toString(m).equals(arg.toString()); }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_TBar_Patch_298256_9_cp4.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "define|property",
        "OrgCode": "boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); }",
        "PatCode": "boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); }"
      },
      {
        "DevIntention": "get|greatest|subtype|helper",
        "OrgCode": "JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type // is returned. for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { // In this branch, the other type is some object type. We find // the greatest subtype with the following algorithm: // 1) For each property \"x\" of this record type, take the union // of all classes with a property \"x\" with a compatible property type. // and which are a subtype of {@code that}. // 2) Take the intersection of all of these unions. for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } } return greatestSubtype; }",
        "PatCode": "JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type // is returned. for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { // In this branch, the other type is some object type. We find // the greatest subtype with the following algorithm: // 1) For each property \"x\" of this record type, take the union // of all classes with a property \"x\" with a compatible property type. // and which are a subtype of {@code that}. // 2) Take the intersection of all of these unions. for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } } return greatestSubtype; }"
      }
    ]
  },
  {
    "PatchId": "Closure_14_SimFix_patch_2072013_1.diff",
    "BugId": "Closure_14",
    "PatchedMethods": [
      {
        "DevIntention": "compute|follow|node",
        "OrgCode": "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { /* * This is the case where: * * 1. Parent is null implies that we are transferring control to the end of * the script. * * 2. Parent is a function implies that we are transferring control back to * the caller of the function. * * 3. If the node is a return statement, we should also transfer control * back to the caller of the function. * * 4. If the node is root then we have reached the end of what we have been * asked to traverse. * * In all cases we should transfer control to a \"symbolic return\" node. * This will make life easier for DFAs. */ Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) { return null; } // If we are just before a IF/WHILE/DO/FOR: switch (parent.getType()) { // The follow() of any of the path from IF would be what follows IF. case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: // After the body of a CASE, the control goes to the body of the next // case, without having to go to the case condition. if (parent.getNext() != null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: // If we are coming out of the TRY block... if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { // and have FINALLY block. return computeFallThrough(parent.getLastChild()); } else { // and have no FINALLY. return computeFollowNode(fromNode, parent, cfa); } // CATCH block. } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { // and have FINALLY block. return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } // If we are coming out of the FINALLY block... } else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); } } return computeFollowNode(fromNode, parent, cfa); } } // Now that we are done with the special cases follow should be its // immediate sibling, unless its sibling is a function Node nextSibling = node.getNext(); // Skip function declarations because control doesn't get pass into it. while (nextSibling != null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling != null) { return computeFallThrough(nextSibling); } else { // If there are no more siblings, control is transferred up the AST. return computeFollowNode(fromNode, parent, cfa); } }",
        "PatCode": "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { /* * This is the case where: * * 1. Parent is null implies that we are transferring control to the end of * the script. * * 2. Parent is a function implies that we are transferring control back to * the caller of the function. * * 3. If the node is a return statement, we should also transfer control * back to the caller of the function. * * 4. If the node is root then we have reached the end of what we have been * asked to traverse. * * In all cases we should transfer control to a \"symbolic return\" node. * This will make life easier for DFAs. */ Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) { return null; } // If we are just before a IF/WHILE/DO/FOR: switch (parent.getType()) { // The follow() of any of the path from IF would be what follows IF. case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: // After the body of a CASE, the control goes to the body of the next // case, without having to go to the case condition. if (parent.getNext() != null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: // If we are coming out of the TRY block... if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { // and have FINALLY block. return computeFallThrough(parent.getLastChild()); } else { // and have no FINALLY. return computeFollowNode(fromNode, parent, cfa); } // CATCH block. } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { // and have FINALLY block. return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } // If we are coming out of the FINALLY block... } else if (parent.getLastChild() == node){ if (cfa != null) {// start of generated patchfor(Node finallyNode : cfa.finallyMap.get(parent)){cfa.createEdge(fromNode,Branch.ON_EX,finallyNode);}// end of generated patch/* start of original code for (Node finallyNode : cfa.finallyMap.get(parent)) { cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); } end of original code*/ } return computeFollowNode(fromNode, parent, cfa); } } // Now that we are done with the special cases follow should be its // immediate sibling, unless its sibling is a function Node nextSibling = node.getNext(); // Skip function declarations because control doesn't get pass into it. while (nextSibling != null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling != null) { return computeFallThrough(nextSibling); } else { // If there are no more siblings, control is transferred up the AST. return computeFollowNode(fromNode, parent, cfa); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_TBar_Patch_55338_4_cp4.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Time_7_SimFix_patch_878305_1.diff",
    "BugId": "Time_7",
    "PatchedMethods": [
      {
        "DevIntention": "parse|into",
        "OrgCode": "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }",
        "PatCode": "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology();// start of generated patchlong instantLocal=instantMillis+chrono.getZone().getOffset(instantMillis);chrono=selectChronology(chrono);int defaultYear=chrono.year().get(instantMillis);// end of generated patch/* start of original code long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); end of original code*/ DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }"
      }
    ]
  },
  {
    "PatchId": "Chart_8_TBar_Patch_23495_1_cp1.diff",
    "BugId": "Chart_8",
    "PatchedMethods": [
      {
        "DevIntention": "week",
        "OrgCode": "public Week(Date time, TimeZone zone) { // defer argument checking... this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); }",
        "PatCode": "public Week(Date time, TimeZone zone) { // defer argument checking... this(time, zone, Locale.getDefault()); }"
      }
    ]
  },
  {
    "PatchId": "Math_34_FixMiner_Patch_274107_18.diff",
    "BugId": "Math_34",
    "PatchedMethods": [
      {
        "DevIntention": "iterator",
        "OrgCode": "public Iterator<Chromosome> iterator() { return chromosomes.iterator(); }",
        "PatCode": "public Iterator<Chromosome> iterator() { return getChromosomes().iterator(); }"
      }
    ]
  },
  {
    "PatchId": "Math_30_FixMiner_Patch_618966_113.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final long n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_SimFix_patch_1723804_3.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index);// start of generated patchif(dataset==null){return result;}// end of generated patch/* start of original code if (dataset != null) { return result; } end of original code*/ int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_30_TBar_Patch_2523494_146_cp68.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final double n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_Avatar_Patch_23805_2.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleList.contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Math_11_TBar_Patch_5556207_178_cp85.diff",
    "BugId": "Math_11",
    "PatchedMethods": [
      {
        "DevIntention": "density",
        "OrgCode": "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length != dim) { throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "PatCode": "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length != dim) { throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, -dim / 2d) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_kPAR_Patch_34030_1_cp1.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_Avatar_Patch_11273094_1566.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_FixMiner_Patch_243478_103.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, width, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Time_7_Avatar_Patch_8852445_1134.diff",
    "BugId": "Time_7",
    "PatchedMethods": [
      {
        "DevIntention": "parse|into",
        "OrgCode": "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }",
        "PatCode": "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantMillis); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_70_TBar_Patch_255338_28_cp28.diff",
    "BugId": "Math_70",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); }",
        "PatCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(f, min, max); }"
      }
    ]
  },
  {
    "PatchId": "Chart_20_TBar_Patch_8786950_2305_cp765.diff",
    "BugId": "Chart_20",
    "PatchedMethods": [
      {
        "DevIntention": "value|marker",
        "OrgCode": "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { super(paint, stroke, paint, stroke, alpha); this.value = value; }",
        "PatCode": "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { super(paint, stroke, outlinePaint, outlineStroke, alpha); this.value = value; }"
      }
    ]
  },
  {
    "PatchId": "Math_11_TBar_Patch_5683418_180_cp87.diff",
    "BugId": "Math_11",
    "PatchedMethods": [
      {
        "DevIntention": "density",
        "OrgCode": "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length != dim) { throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "PatCode": "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length != dim) { throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, (1.0 / 2) * -dim) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }"
      }
    ]
  },
  {
    "PatchId": "Lang_33_SimFix_patch_75465_1.diff",
    "BugId": "Lang_33",
    "PatchedMethods": [
      {
        "DevIntention": "to|class",
        "OrgCode": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }",
        "PatCode": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length];// start of generated patchfor(int i=0;i<array.length;i++){classes[i]=array[i]==null?null:array[i].getClass();}// end of generated patch/* start of original code for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } end of original code*/ return classes; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_SimFix_patch_16215_1.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' :// start of generated patchif(dec==null&&exp==null&&(numeric.charAt(0)=='-'&&isDigits(numeric.substring(1))||isDigits(numeric))){try{return createLong(numeric);}catch (NumberFormatException nfe) {}return createBigInteger(numeric);}// end of generated patch/* start of original code if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } end of original code*/ throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_4_TBar_Patch_12852974_2084_cp986.diff",
    "BugId": "Chart_4",
    "PatchedMethods": [
      {
        "DevIntention": "get|data|range",
        "OrgCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }",
        "PatCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } if (r == null) continue;Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Chart_11_FixMiner_Patch_2022695_348.diff",
    "BugId": "Chart_11",
    "PatchedMethods": [
      {
        "DevIntention": "equal",
        "OrgCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule() != p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone() != iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1 != seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "PatCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule() != p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone() != iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1 != seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }"
      }
    ]
  },
  {
    "PatchId": "Math_57_SimFix_patch_233452_1.diff",
    "BugId": "Math_57",
    "PatchedMethods": [
      {
        "DevIntention": "choose|initial|centers",
        "OrgCode": "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); // Choose one center uniformly at random from among the data points. final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. int sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } // Add one new data point as a center. Each point x is chosen with // probability proportional to D(x)2 final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "PatCode": "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); // Choose one center uniformly at random from among the data points. final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen.// start of generated patchdouble sum=0;for(int i=0;i<pointSet.size();i++){ final T p=pointSet.get(i); final Cluster<T> nearest=getNearestCluster(resultSet,p); final double d=p.distanceFrom(nearest.getCenter());sum+=d*d;dx2[i]=sum;}// end of generated patch/* start of original code int sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } end of original code*/ // Add one new data point as a center. Each point x is chosen with // probability proportional to D(x)2 final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_jKali_patch_77000_23.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_86_TBar_Patch_126225_2_cp2.diff",
    "BugId": "Closure_86",
    "PatchedMethods": [
      {
        "DevIntention": "evaluates|to|local|value",
        "OrgCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: // A result that is aliased by a non-local name, is the effectively the // same as returning a non-local name, but this doesn't matter if the // value is immutable. return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: // There is no information about the locality of object properties. return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: // TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) return true; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: // Literals objects with non-literal children are allowed. return true; case Token.IN: // TODO(johnlenz): should IN operator be included in #isSimpleOperator? return true; default: // Other op force a local value: // x = '' + g (x is now an local string) // x -= g (x is now an local number) if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } }",
        "PatCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: // A result that is aliased by a non-local name, is the effectively the // same as returning a non-local name, but this doesn't matter if the // value is immutable. return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: // There is no information about the locality of object properties. return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: // TODO(nicksantos): This needs to be changed so that it // returns true iff we're sure the value was never aliased from inside // the constructor (similar to callHasLocalResult) return false; case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: // Literals objects with non-literal children are allowed. return true; case Token.IN: // TODO(johnlenz): should IN operator be included in #isSimpleOperator? return true; default: // Other op force a local value: // x = '' + g (x is now an local string) // x -= g (x is now an local number) if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } }"
      }
    ]
  },
  {
    "PatchId": "Math_11_TBar_Patch_5620098_179_cp86.diff",
    "BugId": "Math_11",
    "PatchedMethods": [
      {
        "DevIntention": "density",
        "OrgCode": "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length != dim) { throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "PatCode": "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length != dim) { throw new DimensionMismatchException(vals.length, dim); } return FastMath.pow(2 * FastMath.PI, -dim / 2f) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }"
      }
    ]
  },
  {
    "PatchId": "Time_7_kPAR_Patch_1598706_221_cp100.diff",
    "BugId": "Time_7",
    "PatchedMethods": [
      {
        "DevIntention": "parse|into",
        "OrgCode": "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }",
        "PatCode": "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantMillis); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_FixMiner_Patch_59732_11.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { return availableLocaleList().contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Chart_4_FixMiner_Patch_6054119_1613.diff",
    "BugId": "Chart_4",
    "PatchedMethods": [
      {
        "DevIntention": "get|data|range",
        "OrgCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }",
        "PatCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } if (r == null) { return null;}Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_75_TBar_Patch_95496_20_cp10.diff",
    "BugId": "Math_75",
    "PatchedMethods": [
      {
        "DevIntention": "get|pct",
        "OrgCode": "public double getPct(Object v) { return getCumPct((Comparable<?>) v); }",
        "PatCode": "public double getPct(Object v) { return getPct((Comparable<?>) v); }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_jGenProg_patch_1668000_2546.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135425_8.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.stopTime <= 1) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Chart_20_SimFix_patch_48210_1.diff",
    "BugId": "Chart_20",
    "PatchedMethods": [
      {
        "DevIntention": "value|marker",
        "OrgCode": "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { super(paint, stroke, paint, stroke, alpha); this.value = value; }",
        "PatCode": "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) {// start of generated patchsuper(paint,stroke,outlinePaint,outlineStroke,alpha);this.value=value;// end of generated patch/* start of original code super(paint, stroke, paint, stroke, alpha); this.value = value; end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_SimFix_patch_3253994_1.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line// start of generated patchif(excerpt.equals(LINE)&&0<=charno&&charno<=sourceExcerpt.length()){for(int i=0;i<charno;i++){char c=sourceExcerpt.charAt(i);if(Character.isWhitespace(c)){b.append(c);}else {b.append(' ');}}b.append(\"^\\n\");}// end of generated patch/* start of original code if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } end of original code*/ } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_TBar_Patch_198912_38_cp18.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { return availableLocaleSet().contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135422_6.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.stopTime <= 0) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_TBar_Patch_494019_8_cp8.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno<=sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_jMutRepair_patch_18000_39.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index);if (!(dataset != null)) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_jMutRepair_patch_5000_15.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "lightweight|message|formatter",
        "OrgCode": "private LightweightMessageFormatter() { super(null); this.excerpt = LINE; } public LightweightMessageFormatter(SourceExcerptProvider source) { this(source, LINE); } public LightweightMessageFormatter(SourceExcerptProvider source, SourceExcerpt excerpt) { super(source); Preconditions.checkNotNull(source); this.excerpt = excerpt; } static LightweightMessageFormatter withoutSource() { return new LightweightMessageFormatter(); } public String formatError(JSError error) { return format(error, false); } public String formatWarning(JSError warning) { return format(warning, true); } private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private LightweightMessageFormatter() { super(null); this.excerpt = LINE; } public LightweightMessageFormatter(SourceExcerptProvider source) { this(source, LINE); } public LightweightMessageFormatter(SourceExcerptProvider source, SourceExcerpt excerpt) { super(source); Preconditions.checkNotNull(source); this.excerpt = excerpt; } static LightweightMessageFormatter withoutSource() { return new LightweightMessageFormatter(); } public String formatError(JSError error) { return format(error, false); } public String formatWarning(JSError warning) { return format(warning, true); } private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE)(0 <= charno)) && (charno <= sourceExcerpt.length())) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_SimFix_patch_1598853_1.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; }// start of generated patchint index=this.plot.getIndexOf(this);CategoryDataset dataset=this.plot.getDataset(index);if(dataset==null){return result;}// end of generated patch/* start of original code int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } end of original code*/ int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_jMutRepair_patch_10000_34.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index);if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135415_2.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.STATE_RUNNING == this.runningState) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_jKali_patch_54000_21.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */if (false) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_53_SimFix_patch_41203_1.diff",
    "BugId": "Math_53",
    "PatchedMethods": [
      {
        "DevIntention": "add",
        "OrgCode": "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
        "PatCode": "public Complex add(Complex rhs) throws NullArgumentException {// start of generated patchMathUtils.checkNotNull(rhs);if(isNaN||rhs.isNaN){return NaN;}return createComplex(real+rhs.getReal(),imaginary+rhs.getImaginary());// end of generated patch/* start of original code MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Math_65_TBar_Patch_1866357_309_cp191.diff",
    "BugId": "Math_65",
    "PatchedMethods": [
      {
        "DevIntention": "get|chi|square",
        "OrgCode": "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; chiSquare += residual * residual / residualsWeights[i]; } return chiSquare; }",
        "PatCode": "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; chiSquare += residual * residual * residualsWeights[i]; } return chiSquare; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_3743257_128_cp107.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && (f1 * fx < 0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_57_SimFix_patch_217939_1.diff",
    "BugId": "Closure_57",
    "PatchedMethods": [
      {
        "DevIntention": "extract|class|name|if|goog",
        "OrgCode": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null) { className = target.getString(); } } } } return className; }",
        "PatCode": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext();// start of generated patchif(target!=null&&target.getType()==Token.STRING){className=target.getString();}// end of generated patch/* start of original code if (target != null) { className = target.getString(); } end of original code*/ } } } return className; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_SimFix_patch_189503_1.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i);// start of generated patchif(Precision.compareTo(entry,0.0,epsilon)>0){columnsToDrop.add(i);}// end of generated patch/* start of original code if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } end of original code*/ } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_3212488_112_cp91.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && (f1 == 0.0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_Avatar_Patch_16808737_2460.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "parse|token",
        "OrgCode": "protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { // Scan a run of the same character, which indicates a time // pattern. buf.append(c); while (i + 1 < length) { char peek = pattern.charAt(i + 1); if (peek == c) { buf.append(c); i++; } else { break; } } } else { // This will identify token as text. buf.append('\\''); boolean inLiteral = false; for (; i < length; i++) { c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { // '' is treated as escaped ' i++; buf.append(c); } else { inLiteral = !inLiteral; } } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { i--; break; } else { buf.append(c); } } } indexRef[0] = i; return buf.toString(); }",
        "PatCode": "protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { // Scan a run of the same character, which indicates a time // pattern. buf.append(c); while (i + 1 < length) { char peek = pattern.charAt(i + 1); if (peek == c) { buf.append(c); i++; } else { break; } } } else { // This will identify token as text. buf.append('\\''); boolean inLiteral = false; for (; i < length; i++) { c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { // '' is treated as escaped ' i++; buf.append(c); } else { inLiteral = !inLiteral; } } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { i--; break; } else { buf.append(c); } } } indexRef[0] = i; return buf.toString(); }"
      },
      {
        "DevIntention": "estimate|length",
        "OrgCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max; }",
        "PatCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { if (mValues == null) return LONG; int len = mValues[i].length(); if (len > max) { max = len; } } return max; }"
      },
      {
        "DevIntention": "escape|regex",
        "OrgCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "PatCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(i)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }"
      },
      {
        "DevIntention": "add|regex",
        "OrgCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }",
        "PatCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }"
      }
    ]
  },
  {
    "PatchId": "Math_30_TBar_Patch_2595482_148_cp70.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final long n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_FixMiner_Patch_26879305_367.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb > 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_57_TBar_Patch_16069683_237_cp137.diff",
    "BugId": "Math_57",
    "PatchedMethods": [
      {
        "DevIntention": "choose|initial|centers",
        "OrgCode": "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); // Choose one center uniformly at random from among the data points. final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. int sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } // Add one new data point as a center. Each point x is chosen with // probability proportional to D(x)2 final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "PatCode": "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); // Choose one center uniformly at random from among the data points. final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } // Add one new data point as a center. Each point x is chosen with // probability proportional to D(x)2 final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135412_1.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.runningState == 1) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Chart_24_FixMiner_Patch_83379_29.diff",
    "BugId": "Chart_24",
    "PatchedMethods": [
      {
        "DevIntention": "get|paint",
        "OrgCode": "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "PatCode": "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255.0); return new Color(g, g, g); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_2715069_97_cp76.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((f0 == 0.0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Time_7_TBar_Patch_13432881_2274_cp497.diff",
    "BugId": "Time_7",
    "PatchedMethods": [
      {
        "DevIntention": "parse|into",
        "OrgCode": "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantLocal); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }",
        "PatCode": "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); int defaultYear = chrono.year().get(instantMillis); DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal, chrono, iLocale, iPivotYear, defaultYear); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; }"
      }
    ]
  },
  {
    "PatchId": "Closure_73_SimFix_patch_73123_1.diff",
    "BugId": "Closure_73",
    "PatchedMethods": [
      {
        "DevIntention": "str|escape",
        "OrgCode": "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': // Break </script into <\\/script final String END_SCRIPT = \"/script\"; // Break <!-- into <\\!-- final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: // If we're given an outputCharsetEncoder, then check if the // character can be represented in this character set. if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { // Unicode-escape the character. appendHexJavaScriptRepresentation(sb, c); } } else { // No charsetEncoder provided - pass straight latin characters // through, and escape the rest. Doing the explicit character // check is measurably faster than using the CharsetEncoder. if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers, // or perhaps mangled by proxies along the way, // so we play it safe and unicode escape them. appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "PatCode": "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': // Break </script into <\\/script final String END_SCRIPT = \"/script\"; // Break <!-- into <\\!-- final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: // If we're given an outputCharsetEncoder, then check if the // character can be represented in this character set. if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { // Unicode-escape the character. appendHexJavaScriptRepresentation(sb, c); } } else { // No charsetEncoder provided - pass straight latin characters // through, and escape the rest. Doing the explicit character // check is measurably faster than using the CharsetEncoder.// start of generated patchif(c>0x1f&&c<0x7f){sb.append(c);}else {appendHexJavaScriptRepresentation(sb,c);}// end of generated patch/* start of original code if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers, // or perhaps mangled by proxies along the way, // so we play it safe and unicode escape them. appendHexJavaScriptRepresentation(sb, c); } end of original code*/ } } } sb.append(quote); return sb.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Closure_57_SimFix_patch_1527551_4.diff",
    "BugId": "Closure_57",
    "PatchedMethods": [
      {
        "DevIntention": "extract|class|name|if|goog",
        "OrgCode": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null) { className = target.getString(); } } } } return className; }",
        "PatCode": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName();// start of generated patchif(functionName.equals(qualifiedName)){Node target=callee.getNext();if(target!=null&&target.getType()==Token.STRING){className=target.getString();}}// end of generated patch/* start of original code if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null) { className = target.getString(); } } end of original code*/ } } return className; }"
      }
    ]
  },
  {
    "PatchId": "Chart_11_TBar_Patch_2522058_225_cp174.diff",
    "BugId": "Chart_11",
    "PatchedMethods": [
      {
        "DevIntention": "equal",
        "OrgCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule() != p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p1.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone() != iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1 != seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "PatCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule() != p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone() != iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1 != seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_kPAR_Patch_5202641_833_cp285.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_SimFix_patch_1414670_1.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } // start of generated patchif(this.maxMiddleIndex>=0){long s=getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime();long e=getDataItem(this.maxMiddleIndex).getPeriod().getEnd().getTime();long maxMiddle=s+(e-s)/2;if(middle>maxMiddle){this.maxMiddleIndex=index;}}else {this.maxMiddleIndex=index;}// end of generated patch/* start of original code if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } end of original code*/ if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_79_SimFix_patch_1032079_1.diff",
    "BugId": "Math_79",
    "PatchedMethods": [
      {
        "DevIntention": "distance",
        "OrgCode": "public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "PatCode": "public static double distance(int[] p1, int[] p2) {// start of generated patchdouble sum=0;for(int i=0;i<p1.length;i++){ final double dp=p1[i]-p2[i];sum+=dp*dp;}return Math.sqrt(sum);// end of generated patch/* start of original code int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_TBar_Patch_189085_37_cp17.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { return availableLocaleList().contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Lang_43_SimFix_patch_1529136_2.diff",
    "BugId": "Lang_43",
    "PatchedMethods": [
      {
        "DevIntention": "append|quoted|string",
        "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray();// start of generated patchif(escapingOn&&c[start]==QUOTE){next(pos);return appendTo==null?null:appendTo.append(QUOTE);}// end of generated patch/* start of original code if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } end of original code*/ int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_TBar_Patch_15315682_2027_cp731.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "escape|regex",
        "OrgCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "PatCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }"
      }
    ]
  },
  {
    "PatchId": "Lang_33_SimFix_patch_141856_2.diff",
    "BugId": "Lang_33",
    "PatchedMethods": [
      {
        "DevIntention": "to|class",
        "OrgCode": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }",
        "PatCode": "public static Class<?>[] toClass(Object[] array) {// start of generated patchif(array==null){return null;}else if(array.length==0){return ArrayUtils.EMPTY_CLASS_ARRAY;}Class<?>[] classes=new Class[array.length];for(int i=0;i<array.length;i++){classes[i]=array[i]==null?null:array[i].getClass();}return classes;// end of generated patch/* start of original code if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Mockito_38_TBar_Patch_211019_30_cp11.diff",
    "BugId": "Mockito_38",
    "PatchedMethods": [
      {
        "DevIntention": "safely|matches",
        "OrgCode": "private boolean safelyMatches(Matcher m, Object arg) { try { return m.matches(arg); } catch (Throwable t) { return false; } }",
        "PatCode": "private boolean safelyMatches(Matcher m, Object arg) { try { return m.matches(arg); } catch (Throwable t) { return false; } }"
      },
      {
        "DevIntention": "to|string|equals",
        "OrgCode": "private boolean toStringEquals(Matcher m, Object arg) { return StringDescription.toString(m).equals(arg.toString()); }",
        "PatCode": "private boolean toStringEquals(Matcher m, Object arg) { if (arg == null) arg = new Object(); return StringDescription.toString(m).equals(arg.toString()); }"
      }
    ]
  },
  {
    "PatchId": "Math_5_TBar_Patch_4069754_62_cp57.diff",
    "BugId": "Math_5",
    "PatchedMethods": [
      {
        "DevIntention": "reciprocal",
        "OrgCode": "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { return NaN; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "PatCode": "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { return INF; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_Avatar_Patch_571679_15.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "define|property",
        "OrgCode": "boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); }",
        "PatCode": "boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); }"
      },
      {
        "DevIntention": "get|greatest|subtype|helper",
        "OrgCode": "JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type // is returned. for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { // In this branch, the other type is some object type. We find // the greatest subtype with the following algorithm: // 1) For each property \"x\" of this record type, take the union // of all classes with a property \"x\" with a compatible property type. // and which are a subtype of {@code that}. // 2) Take the intersection of all of these unions. for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } } return greatestSubtype; }",
        "PatCode": "JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type // is returned. for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { // In this branch, the other type is some object type. We find // the greatest subtype with the following algorithm: // 1) For each property \"x\" of this record type, take the union // of all classes with a property \"x\" with a compatible property type. // and which are a subtype of {@code that}. // 2) Take the intersection of all of these unions. for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } } return greatestSubtype; }"
      }
    ]
  },
  {
    "PatchId": "Closure_2_TBar_Patch_4086041_109_cp52.diff",
    "BugId": "Closure_2",
    "PatchedMethods": [
      {
        "DevIntention": "check|interface|conflict|properties",
        "OrgCode": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { if (!interfaceType.getPropertyType(name).isEquivalentTo( oType.getPropertyType(name))) { compiler.report( t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString())); } } currentProperties.put(name, interfaceType); } for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); } }",
        "PatCode": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). if (implicitProto != null) {currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { if (!interfaceType.getPropertyType(name).isEquivalentTo( oType.getPropertyType(name))) { compiler.report( t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString())); } } currentProperties.put(name, interfaceType); }} for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135419_4.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.STATE_SUSPENDED != this.runningState) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9017293_950_cp710.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb>0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_Avatar_Patch_16831934_2478.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "parse|token",
        "OrgCode": "protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { // Scan a run of the same character, which indicates a time // pattern. buf.append(c); while (i + 1 < length) { char peek = pattern.charAt(i + 1); if (peek == c) { buf.append(c); i++; } else { break; } } } else { // This will identify token as text. buf.append('\\''); boolean inLiteral = false; for (; i < length; i++) { c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { // '' is treated as escaped ' i++; buf.append(c); } else { inLiteral = !inLiteral; } } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { i--; break; } else { buf.append(c); } } } indexRef[0] = i; return buf.toString(); }",
        "PatCode": "protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { // Scan a run of the same character, which indicates a time // pattern. buf.append(c); while (i + 1 < length) { char peek = pattern.charAt(i + 1); if (peek == c) { buf.append(c); i++; } else { break; } } } else { // This will identify token as text. buf.append('\\''); boolean inLiteral = false; for (; i < length; i++) { c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { // '' is treated as escaped ' i++; buf.append(c); } else { inLiteral = !inLiteral; } } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { i--; break; } else { buf.append(c); } } } indexRef[0] = i; return buf.toString(); }"
      },
      {
        "DevIntention": "estimate|length",
        "OrgCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max; }",
        "PatCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { if (mValues == null) return LONG; int len = mValues[i].length(); if (len > max) { max = len; } } return max; }"
      },
      {
        "DevIntention": "escape|regex",
        "OrgCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "PatCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }"
      },
      {
        "DevIntention": "add|regex",
        "OrgCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }",
        "PatCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10481015_1065_cp706.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * (n - 1); for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Chart_4_TBar_Patch_12826885_2080_cp984.diff",
    "BugId": "Chart_4",
    "PatchedMethods": [
      {
        "DevIntention": "get|data|range",
        "OrgCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }",
        "PatCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } if (r == null) { return null;}Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Mockito_38_Avatar_Patch_89137_10.diff",
    "BugId": "Mockito_38",
    "PatchedMethods": [
      {
        "DevIntention": "safely|matches",
        "OrgCode": "private boolean safelyMatches(Matcher m, Object arg) { try { return m.matches(arg); } catch (Throwable t) { return false; } }",
        "PatCode": "private boolean safelyMatches(Matcher m, Object arg) { try { return m.matches(arg); } catch (Throwable t) { return false; } }"
      },
      {
        "DevIntention": "to|string|equals",
        "OrgCode": "private boolean toStringEquals(Matcher m, Object arg) { return StringDescription.toString(m).equals(arg.toString()); }",
        "PatCode": "private boolean toStringEquals(Matcher m, Object arg) { if (arg == null) { return false;}return StringDescription.toString(m).equals(arg.toString()); }"
      }
    ]
  },
  {
    "PatchId": "Math_58_TBar_Patch_1156375_100_cp56.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "fit",
        "OrgCode": "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); return fit(new Gaussian.Parametric(), guess); }",
        "PatCode": "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); return fit(guess); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_jMutRepair_patch_92000_102.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if ((fa * fb) > 0.0) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_30_FixMiner_Patch_546814_111.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final double n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Math_34_TBar_Patch_72268_1_cp1.diff",
    "BugId": "Math_34",
    "PatchedMethods": [
      {
        "DevIntention": "iterator",
        "OrgCode": "public Iterator<Chromosome> iterator() { return chromosomes.iterator(); }",
        "PatCode": "public Iterator<Chromosome> iterator() { return getChromosomes().iterator(); }"
      }
    ]
  },
  {
    "PatchId": "Math_5_SimFix_patch_99356_1.diff",
    "BugId": "Math_5",
    "PatchedMethods": [
      {
        "DevIntention": "reciprocal",
        "OrgCode": "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { return NaN; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "PatCode": "public Complex reciprocal() { if (isNaN) { return NaN; }// start of generated patchif(real==0.0&&imaginary==0.0){return INF;}// end of generated patch/* start of original code if (real == 0.0 && imaginary == 0.0) { return NaN; } end of original code*/ if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_2680735_96_cp75.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((f1 == 0.0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9073149_957_cp717.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if ((fa * fb >= 0.0) && ((fa * fb > 0.0)) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_89_kPAR_Patch_110348_12_cp11.diff",
    "BugId": "Math_89",
    "PatchedMethods": [
      {
        "DevIntention": "add|value",
        "OrgCode": "public void addValue(Object v) { addValue((Comparable<?>) v); }",
        "PatCode": "public void addValue(Object v) { if (v instanceof Comparable<?>) {addValue((Comparable<?>) v);} else {throw new IllegalArgumentException(\"Illegal argument: v\");} }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jGenProg_patch_8789000_17918.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "get|least|supertype",
        "OrgCode": "public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "PatCode": "public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); }} return super.getLeastSupertype(that); }"
      }
    ]
  },
  {
    "PatchId": "Math_75_FixMiner_Patch_2367936_1362.diff",
    "BugId": "Math_75",
    "PatchedMethods": [
      {
        "DevIntention": "get|pct",
        "OrgCode": "public double getPct(Object v) { return getCumPct((Comparable<?>) v); }",
        "PatCode": "public double getPct(Object v) { return getPct((Comparable<?>) v); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_3610486_124_cp103.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && (fx == 0.0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Mockito_38_TBar_Patch_181808_28_cp9.diff",
    "BugId": "Mockito_38",
    "PatchedMethods": [
      {
        "DevIntention": "safely|matches",
        "OrgCode": "private boolean safelyMatches(Matcher m, Object arg) { try { return m.matches(arg); } catch (Throwable t) { return false; } }",
        "PatCode": "private boolean safelyMatches(Matcher m, Object arg) { try { return m.matches(arg); } catch (Throwable t) { return false; } }"
      },
      {
        "DevIntention": "to|string|equals",
        "OrgCode": "private boolean toStringEquals(Matcher m, Object arg) { return StringDescription.toString(m).equals(arg.toString()); }",
        "PatCode": "private boolean toStringEquals(Matcher m, Object arg) { if (arg == null) { return false;}return StringDescription.toString(m).equals(arg.toString()); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_SimFix_patch_1210647_3.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; }// start of generated patchList<Integer> columnsToDrop=new ArrayList<Integer>();columnsToDrop.add(0);for(int i=getNumObjectiveFunctions();i<getArtificialVariableOffset();i++){ final double entry=tableau.getEntry(0,i);if(Precision.compareTo(entry,0.0,epsilon)>0){columnsToDrop.add(i);}}// end of generated patch/* start of original code List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } end of original code*/ // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Closure_73_Avatar_Patch_2395147_180.diff",
    "BugId": "Closure_73",
    "PatchedMethods": [
      {
        "DevIntention": "str|escape",
        "OrgCode": "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': // Break </script into <\\/script final String END_SCRIPT = \"/script\"; // Break <!-- into <\\!-- final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: // If we're given an outputCharsetEncoder, then check if the // character can be represented in this character set. if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { // Unicode-escape the character. appendHexJavaScriptRepresentation(sb, c); } } else { // No charsetEncoder provided - pass straight latin characters // through, and escape the rest. Doing the explicit character // check is measurably faster than using the CharsetEncoder. if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers, // or perhaps mangled by proxies along the way, // so we play it safe and unicode escape them. appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "PatCode": "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': // Break --> into --\\> or ]]> into ]]\\> if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': // Break </script into <\\/script final String END_SCRIPT = \"/script\"; // Break <!-- into <\\!-- final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: // If we're given an outputCharsetEncoder, then check if the // character can be represented in this character set. if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { // Unicode-escape the character. appendHexJavaScriptRepresentation(sb, c); } } else { // No charsetEncoder provided - pass straight latin characters // through, and escape the rest. Doing the explicit character // check is measurably faster than using the CharsetEncoder. if (c > 0x1f && c < 0x7f) { sb.append(c); } else { // Other characters can be misinterpreted by some js parsers, // or perhaps mangled by proxies along the way, // so we play it safe and unicode escape them. appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Chart_4_TBar_Patch_12801465_2078_cp982.diff",
    "BugId": "Chart_4",
    "PatchedMethods": [
      {
        "DevIntention": "get|data|range",
        "OrgCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }",
        "PatCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } if (r != null) {Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } }} } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_82_jMutRepair_patch_9000_37.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col);if (org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon) > 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_dynamoth_patch_68215_1.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); if (false) { tryMinimizeExits(finallyBlock, exitType, labelName); } } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_13532544_2531_cp1209.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon)>0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_70_SimFix_patch_21251_1.diff",
    "BugId": "Math_70",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); }",
        "PatCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {// start of generated patchreturn solve(f,min,max);// end of generated patch/* start of original code return solve(min, max); end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Lang_6_TBar_Patch_13384450_1243_cp683.diff",
    "BugId": "Lang_6",
    "PatchedMethods": [
      {
        "DevIntention": "translate",
        "OrgCode": "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; }// // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { pos += Character.charCount(Character.codePointAt(input, pos)); } } }",
        "PatCode": "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; }// // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { pos += Character.charCount(Character.codePointAt(input, pt)); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_4_FixMiner_Patch_6041512_1612.diff",
    "BugId": "Chart_4",
    "PatchedMethods": [
      {
        "DevIntention": "get|data|range",
        "OrgCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }",
        "PatCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } if (r != null) {Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } }} } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_jKali_patch_117737_22.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }if (true)return; this.runningState = org.apache.commons.lang.time.StopWatch.STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252130_4.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if ((this.getOriginalNumDecisionVariables() - this.getArtificialVariableOffset()) == 1) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_jGenProg_patch_911000_9130.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "get|max|middle|index",
        "OrgCode": "public int getMaxMiddleIndex() { return this.maxMiddleIndex; }",
        "PatCode": "public int getMaxMiddleIndex() { return this.maxStartIndex; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_FixMiner_Patch_541591_154.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null || exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10199466_1007_cp676.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i==j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_Avatar_Patch_2622255_58.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_28_dynamoth_patch_466005_1.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } if (false) { return minRow; } } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9365311_994_cp754.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa >= a && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_dynamoth_patch_48155_1.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (true) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Time_11_TBar_Patch_356943_60_cp22.diff",
    "BugId": "Time_11",
    "PatchedMethods": [
      {
        "DevIntention": "verbose",
        "OrgCode": "public static boolean verbose() { return cVerbose.get(); }",
        "PatCode": "public static boolean verbose() { return cVerbose != null || cVerbose.get(); }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_9090000_829_cp554.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; process1RowBlock(k); work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Mockito_29_TBar_Patch_622918_79_cp30.diff",
    "BugId": "Mockito_29",
    "PatchedMethods": [
      {
        "DevIntention": "same",
        "OrgCode": "public static <T> T same(T value) { return (T) reportMatcher(new Same(value)).<T>returnFor(value); }",
        "PatCode": "public static <T> T same(T value) { if (value == null) { return null;}return (T) reportMatcher(new Same(value)).<T>returnFor(value); }"
      }
    ]
  },
  {
    "PatchId": "Chart_26_Nopol_patch_56274_1.diff",
    "BugId": "Chart_26",
    "PatchedMethods": [
      {
        "DevIntention": "draw",
        "OrgCode": "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { // if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; } // record the plot area... if (state == null) { // if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes state = new PlotRenderingInfo(null); } state.setPlotArea(area); // adjust the drawing area for the plot insets (if any)... RectangleInsets insets = getInsets(); insets.trim(area); // calculate the data area... AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); // if there is a renderer, it draws the background, otherwise use the // default background... if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); // don't let anyone draw outside the data area Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates() .get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } // draw the markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } // now render data items... boolean foundData = false; // set up the alpha-transparency... Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { for (int i = 0; i < this.datasets.size(); i++) { foundData = render(g2, dataArea, i, state) || foundData; } } else { // DatasetRenderingOrder.REVERSE for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } } // draw the foreground markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } // draw the annotations (if any)... drawAnnotations(g2, dataArea); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } // draw range crosshair if required... if (isRangeCrosshairVisible()) { // FIXME: this doesn't handle multiple range axes drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } // draw an outline around the plot area... if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } }",
        "PatCode": "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { // if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (org.jfree.chart.plot.CategoryPlot.this.backgroundRangeMarkers!=null) { return; } // record the plot area... if (state == null) { // if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes state = new PlotRenderingInfo(null); } state.setPlotArea(area); // adjust the drawing area for the plot insets (if any)... RectangleInsets insets = getInsets(); insets.trim(area); // calculate the data area... AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); // if there is a renderer, it draws the background, otherwise use the // default background... if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); // don't let anyone draw outside the data area Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates() .get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } // draw the markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } // now render data items... boolean foundData = false; // set up the alpha-transparency... Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { for (int i = 0; i < this.datasets.size(); i++) { foundData = render(g2, dataArea, i, state) || foundData; } } else { // DatasetRenderingOrder.REVERSE for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } } // draw the foreground markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } // draw the annotations (if any)... drawAnnotations(g2, dataArea); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } // draw range crosshair if required... if (isRangeCrosshairVisible()) { // FIXME: this doesn't handle multiple range axes drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } // draw an outline around the plot area... if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135428_10.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.runningState <= this.STATE_RUNNING) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2725681_324_cp244.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(expPos > -1 && expPos < str.length() - 1)) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_13381_1.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "PatCode": "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { throw new IllegalArgumentException(\"Requires start <= end.\"); } } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_TBar_Patch_21231800_2735_cp1178.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (getLegendItemURLGenerator() != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252126_3.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if ((this.getOriginalNumDecisionVariables() - this.getSlackVariableOffset()) == 1) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9207472_974_cp734.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa == b && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_28_FixMiner_Patch_21969962_663.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Chart_5_jKali_patch_2000_9.diff",
    "BugId": "Chart_5",
    "PatchedMethods": [
      {
        "DevIntention": "add|or|update",
        "OrgCode": "public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); } existing.setY(y); } else { // if the series is sorted, the negative index is a result from // Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... if (this.autoSort) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { this.data.add(new XYDataItem(x, y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } } fireSeriesChanged(); return overwritten; }",
        "PatCode": "public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); } existing.setY(y); } else { // if the series is sorted, the negative index is a result from // Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list...if (false) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { this.data.add(new XYDataItem(x, y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } } fireSeriesChanged(); return overwritten; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_83000_52.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];if (true)return false; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_FixMiner_Patch_26947782_376.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * b >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10049039_977_cp660.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { process2RowsBlock(step); j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_Nopol_patch_25529_2.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (((dec == null) && (exp == null))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_TBar_Patch_932636_16_cp16.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno || charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9112675_962_cp722.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa == fb && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_16378_4.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period if (org.jfree.data.time.TimeSeries.this.data.size() == org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length()) { endIndex = endIndex - 1; // so this is last item BEFORE end } } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_Avatar_Patch_899469_12.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno || charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_FixMiner_Patch_26978292_380.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * upperBound >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Closure_48_dynamoth_patch_187176_1.diff",
    "BugId": "Closure_48",
    "PatchedMethods": [
      {
        "DevIntention": "maybe|declare|qualified|name",
        "OrgCode": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); Preconditions.checkArgument(qName != null && ownerName != null); // Precedence of type information on GETPROPs: // 1) @type annnotation / @enum annotation // 2) ASSIGN to FUNCTION literal // 3) @param/@return annotation (with no function literal) // 4) ASSIGN to something marked @const // 5) ASSIGN to anything else // // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff // the function has jsdoc or has not been declared before. // // FUNCTION literals are special because TypedScopeCreator is very smart // about getting as much type information as possible for them. // Determining type for #1 + #2 + #3 + #4 JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); if (valueType == null && rhsValue != null) { // Determining type for #5 valueType = rhsValue.getJSType(); } // Function prototypes are special. // It's a common JS idiom to do: // F.prototype = { ... }; // So if F does not have an explicitly declared super type, // allow F.prototype to be redefined arbitrarily. if (\"prototype\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to an object literal, // then they are responsible for making sure that the object literal's // implicit prototype is set up appropriately. We just obey // the @extends tag. ObjectType qVarType = ObjectType.cast(qVar.getType()); if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) { typeRegistry.resetImplicitPrototype( rhsValue.getJSType(), qVarType.getImplicitPrototype()); } else if (!qVar.isTypeInferred()) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to some arbitrary expression, // there's not much we can do. We just ignore the expression, // and hope they've annotated their code in a way to tell us // what props are going to be on that prototype. return; } if (qVar.getScope() == scope) { scope.undeclare(qVar); } } } if (valueType == null) { if (parent.isExprResult()) { stubDeclarations.add(new StubDeclaration( n, t.getInput() != null && t.getInput().isExtern(), ownerName)); } return; } // NOTE(nicksantos): Determining whether a property is declared or not // is really really obnoxious. // // The problem is that there are two (equally valid) coding styles: // // (function() { // /* The authoritative definition of goog.bar. */ // goog.bar = function() {}; // })(); // // function f() { // goog.bar(); // /* Reset goog.bar to a no-op. */ // goog.bar = function() {}; // } // // In a dynamic language with first-class functions, it's very difficult // to know which one the user intended without looking at lots of // contextual information (the second example demonstrates a small case // of this, but there are some really pathological cases as well). // // The current algorithm checks if either the declaration has // jsdoc type information, or @const with a known type, // or a function literal with a name we haven't seen before. boolean inferred = true; if (info != null) { // Determining declaration for #1 + #3 + #4 inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred) { // Determining declaration for #2 inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false))); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { // Only declare this as an official property if it has not been // declared yet. boolean isExtern = t.getInput() != null && t.getInput().isExtern(); if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) { // If the property is undeclared or inferred, declare it now. ownerType.defineDeclaredProperty(propName, valueType, n); } } // If the property is already declared, the error will be // caught when we try to declare it in the current scope. defineSlot(n, parent, valueType, inferred); } else if (rhsValue != null && rhsValue.isTrue()) { // We declare these for delegate proxy method properties. FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName)); if (ownerType != null) { JSType ownerTypeOfThis = ownerType.getTypeOfThis(); String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true); } } } }",
        "PatCode": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); Preconditions.checkArgument(qName != null && ownerName != null); // Precedence of type information on GETPROPs: // 1) @type annnotation / @enum annotation // 2) ASSIGN to FUNCTION literal // 3) @param/@return annotation (with no function literal) // 4) ASSIGN to something marked @const // 5) ASSIGN to anything else // // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff // the function has jsdoc or has not been declared before. // // FUNCTION literals are special because TypedScopeCreator is very smart // about getting as much type information as possible for them. // Determining type for #1 + #2 + #3 + #4 JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); if (valueType == null && rhsValue != null) { // Determining type for #5 if (false) { valueType = rhsValue.getJSType(); } } // Function prototypes are special. // It's a common JS idiom to do: // F.prototype = { ... }; // So if F does not have an explicitly declared super type, // allow F.prototype to be redefined arbitrarily. if (\"prototype\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to an object literal, // then they are responsible for making sure that the object literal's // implicit prototype is set up appropriately. We just obey // the @extends tag. ObjectType qVarType = ObjectType.cast(qVar.getType()); if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) { typeRegistry.resetImplicitPrototype( rhsValue.getJSType(), qVarType.getImplicitPrototype()); } else if (!qVar.isTypeInferred()) { // If the programmer has declared that F inherits from Super, // and they assign F.prototype to some arbitrary expression, // there's not much we can do. We just ignore the expression, // and hope they've annotated their code in a way to tell us // what props are going to be on that prototype. return; } if (qVar.getScope() == scope) { scope.undeclare(qVar); } } } if (valueType == null) { if (parent.isExprResult()) { stubDeclarations.add(new StubDeclaration( n, t.getInput() != null && t.getInput().isExtern(), ownerName)); } return; } // NOTE(nicksantos): Determining whether a property is declared or not // is really really obnoxious. // // The problem is that there are two (equally valid) coding styles: // // (function() { // /* The authoritative definition of goog.bar. */ // goog.bar = function() {}; // })(); // // function f() { // goog.bar(); // /* Reset goog.bar to a no-op. */ // goog.bar = function() {}; // } // // In a dynamic language with first-class functions, it's very difficult // to know which one the user intended without looking at lots of // contextual information (the second example demonstrates a small case // of this, but there are some really pathological cases as well). // // The current algorithm checks if either the declaration has // jsdoc type information, or @const with a known type, // or a function literal with a name we haven't seen before. boolean inferred = true; if (info != null) { // Determining declaration for #1 + #3 + #4 inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred) { // Determining declaration for #2 inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false))); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { // Only declare this as an official property if it has not been // declared yet. boolean isExtern = t.getInput() != null && t.getInput().isExtern(); if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) { // If the property is undeclared or inferred, declare it now. ownerType.defineDeclaredProperty(propName, valueType, n); } } // If the property is already declared, the error will be // caught when we try to declare it in the current scope. defineSlot(n, parent, valueType, inferred); } else if (rhsValue != null && rhsValue.isTrue()) { // We declare these for delegate proxy method properties. FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName)); if (ownerType != null) { JSType ownerTypeOfThis = ownerType.getTypeOfThis(); String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_12425558_2387_cp1074.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio<=minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_Avatar_Patch_15444802_1948.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "parse|token",
        "OrgCode": "protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { // Scan a run of the same character, which indicates a time // pattern. buf.append(c); while (i + 1 < length) { char peek = pattern.charAt(i + 1); if (peek == c) { buf.append(c); i++; } else { break; } } } else { // This will identify token as text. buf.append('\\''); boolean inLiteral = false; for (; i < length; i++) { c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { // '' is treated as escaped ' i++; buf.append(c); } else { inLiteral = !inLiteral; } } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { i--; break; } else { buf.append(c); } } } indexRef[0] = i; return buf.toString(); }",
        "PatCode": "protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { // Scan a run of the same character, which indicates a time // pattern. buf.append(c); while (i + 1 < length) { char peek = pattern.charAt(i + 1); if (peek == c) { buf.append(c); i++; } else { break; } } } else { // This will identify token as text. buf.append('\\''); boolean inLiteral = false; for (; i < length; i++) { c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { // '' is treated as escaped ' i++; buf.append(c); } else { inLiteral = !inLiteral; } } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { i--; break; } else { buf.append(c); } } } indexRef[0] = i; return buf.toString(); }"
      },
      {
        "DevIntention": "estimate|length",
        "OrgCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max; }",
        "PatCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { if (mValues == null) return LONG; int len = mValues[i].length(); if (len > max) { max = len; } } return max; }"
      },
      {
        "DevIntention": "escape|regex",
        "OrgCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "PatCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!unquote) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }"
      },
      {
        "DevIntention": "add|regex",
        "OrgCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }",
        "PatCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_20183856_987.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint == null) { return null;}if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_68000_49.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) {if (true)return false; final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_120646_10.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[0] <= 0) { if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19656960_971.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|constraint|type|counts",
        "OrgCode": "private int getConstraintTypeCounts(final Relationship relationship) { int count = 0; for (final LinearConstraint constraint : constraints) { if (constraint.getRelationship() == relationship) { ++count; } } return count; }",
        "PatCode": "private int getConstraintTypeCounts(final Relationship relationship) { int count = 0; for (final LinearConstraint constraint : constraints) { if (constraint.getRelationship() != relationship) { ++count; } } return count; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_338815_2652.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) {ensureCapacity(size + width); buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY]; String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17745736_909.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "get|goal|type",
        "OrgCode": "protected GoalType getGoalType() { return goal; }",
        "PatCode": "protected GoalType getGoalType() { if (goal == null) { throw new IllegalArgumentException(\"Null 'goal' argument.\");}return goal; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_Avatar_Patch_761284_10.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9159968_968_cp728.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa > fb && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jKali_patch_106000_208.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "assert|valid|resolve",
        "OrgCode": "public static JSType assertValidResolve( JSType type, StaticScope<JSType> scope) { ErrorReporter t = TestErrorReporter.forNoExpectedReports(); JSType resolvedType = type.resolve(t, scope); assertTypeEquals(\"JSType#resolve should not affect object equality\", type, resolvedType); Assert.assertEquals(\"JSType#resolve should not affect hash codes\", type.hashCode(), resolvedType.hashCode()); return resolvedType; } public static void assertTypeNotEquals(JSType a, JSType b) { assertTypeNotEquals(\"\", a, b); } public static void assertTypeNotEquals(String message, JSType a, JSType b) { Assert.assertFalse( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Type: \" + b + \"\\n\", a.isEquivalentTo(b)); Assert.assertFalse( message + \" Equals is not symmetric.\\n\" + \"Type: \" + b + \"\\n\", b.isEquivalentTo(a)); } public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); } public static void assertTypeEquals(String message, JSType a, JSType b) { Assert.assertTrue( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Expected: \" + a + \"\\n\" + \"Actual : \" + b, a.isEquivalentTo(b)); Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }",
        "PatCode": "public static JSType assertValidResolve( JSType type, StaticScope<JSType> scope) { ErrorReporter t = TestErrorReporter.forNoExpectedReports(); JSType resolvedType = type.resolve(t, scope); assertTypeEquals(\"JSType#resolve should not affect object equality\", type, resolvedType); Assert.assertEquals(\"JSType#resolve should not affect hash codes\", type.hashCode(), resolvedType.hashCode()); return resolvedType; } public static void assertTypeNotEquals(JSType a, JSType b) { assertTypeNotEquals(\"\", a, b); } public static void assertTypeNotEquals(String message, JSType a, JSType b) { Assert.assertFalse( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Type: \" + b + \"\\n\", a.isEquivalentTo(b)); Assert.assertFalse( message + \" Equals is not symmetric.\\n\" + \"Type: \" + b + \"\\n\", b.isEquivalentTo(a)); } public static void assertTypeEquals(JSType a, JSType b) {if (true)return; } public static void assertTypeEquals(String message, JSType a, JSType b) { Assert.assertTrue( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Expected: \" + a + \"\\n\" + \"Actual : \" + b, a.isEquivalentTo(b)); Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_4346946_146_cp125.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && !(f1 <= 0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_kPAR_Patch_2729664_371_cp188.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1576486_306_cp153.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null || isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2464290_300_cp220.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(decPos > -1)) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_TBar_Patch_1659693_34_cp29.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_24000_146.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();if (strLen >= width) { buffer = new char[str.length() + org.apache.commons.lang.text.StrBuilder.CAPACITY]; str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9491709_1010_cp770.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa == lowerBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_97067_7.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { if ((param[0] <= 0) && (param != null)) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_TBar_Patch_21147222_2729_cp1173.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (getBaseItemLabelGenerator() != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252141_8.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getArtificialVariableOffset())) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_21301754_1066.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "create|tableau",
        "OrgCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }",
        "PatCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.LEQ) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Math_95_jGenProg_patch_925000_2552.diff",
    "BugId": "Math_95",
    "PatchedMethods": [
      {
        "DevIntention": "get|initial|domain",
        "OrgCode": "protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); return ret; }",
        "PatCode": "protected double getInitialDomain(double p) { double ret;double d = getDenominatorDegreesOfFreedom(); ret = 0.0; // use mean return ret; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9041083_953_cp713.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if ((fa * fb >= 0.0) && ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_12703209_2421_cp1108.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio <= minRatio || (ratio < minRatio)) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18922173_944.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.numArtificialVariables, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18704399_939.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.restrictToNonNegative, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_20_Nopol_patch_274583_1.diff",
    "BugId": "Math_20",
    "PatchedMethods": [
      {
        "DevIntention": "repair",
        "OrgCode": "private double[] repair(final double[] x) { double[] repaired = new double[x.length]; for (int i = 0; i < x.length; i++) { if (x[i] < 0) { repaired[i] = 0; } else if (x[i] > 1.0) { repaired[i] = 1.0; } else { repaired[i] = x[i]; } } return repaired; }",
        "PatCode": "private double[] repair(final double[] x) { double[] repaired = new double[x.length]; for (int i = 0; i < x.length; i++) { if (x[i] < 0) { repaired[i] = 0; } else if (x[i] > 1.0) { if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.generateStatistics) { repaired[i] = 1.0; } } else { repaired[i] = x[i]; } } return repaired; }"
      }
    ]
  },
  {
    "PatchId": "Time_7_Nopol_patch_23883_1.diff",
    "BugId": "Time_7",
    "PatchedMethods": [
      {
        "DevIntention": "compute|millis",
        "OrgCode": "public long computeMillis(boolean resetFields, String text) { SavedField[] savedFields = iSavedFields; int count = iSavedFieldsCount; if (iSavedFieldsShared) { iSavedFields = savedFields = (SavedField[])iSavedFields.clone(); iSavedFieldsShared = false; } sort(savedFields, count); if (count > 0) { // alter base year for parsing if first field is month or day DurationField months = DurationFieldType.months().getField(iChrono); DurationField days = DurationFieldType.days().getField(iChrono); DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); return computeMillis(resetFields, text); } } long millis = iMillis; try { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e; } if (iOffset != null) { millis -= iOffset; } else if (iZone != null) { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')'; if (text != null) { message = \"Cannot parse \\\"\" + text + \"\\\": \" + message; } throw new IllegalInstantException(message); } } return millis; }",
        "PatCode": "public long computeMillis(boolean resetFields, String text) { SavedField[] savedFields = iSavedFields; int count = iSavedFieldsCount; if (iSavedFieldsShared) { iSavedFields = savedFields = (SavedField[])iSavedFields.clone(); iSavedFieldsShared = false; } sort(savedFields, count); if (count > 0) { // alter base year for parsing if first field is month or day DurationField months = DurationFieldType.months().getField(iChrono); DurationField days = DurationFieldType.days().getField(iChrono); DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); if (resetFields) { return computeMillis(resetFields, text); } } } long millis = iMillis; try { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e; } if (iOffset != null) { millis -= iOffset; } else if (iZone != null) { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')'; if (text != null) { message = \"Cannot parse \\\"\" + text + \"\\\": \" + message; } throw new IllegalInstantException(message); } } return millis; }"
      }
    ]
  },
  {
    "PatchId": "Lang_44_kPAR_Patch_550878_53_cp42.diff",
    "BugId": "Lang_44",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String val) throws NumberFormatException { if (val == null) { return null; } if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); } if (val.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) { return createInteger(val); } char lastChar = val.charAt(val.length() - 1); String mant; String dec; String exp; int decPos = val.indexOf('.'); int expPos = val.indexOf('e') + val.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(val + \" is not a valid number.\"); } dec = val.substring(decPos + 1, expPos); } else { dec = val.substring(decPos + 1); } mant = val.substring(0, decPos); } else { if (expPos > -1) { mant = val.substring(0, expPos); } else { mant = val; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = val.substring(0, val.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(val + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException e) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // empty catch } //Fall through default : throw new NumberFormatException(val + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(val); } catch (NumberFormatException nfe) { // empty catch } try { return createLong(val); } catch (NumberFormatException nfe) { // empty catch } return createBigInteger(val); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(val); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // empty catch } try { Double d = createDouble(val); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } return createBigDecimal(val); } } }",
        "PatCode": "public static Number createNumber(String val) throws NumberFormatException { if (val == null) { return null; } if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); } if (val.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) { return createInteger(val); } char lastChar = val.charAt(val.length() - 1); String mant; String dec; String exp; int decPos = val.indexOf('.'); int expPos = val.indexOf('e') + val.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(val + \" is not a valid number.\"); } dec = val.substring(decPos + 1, expPos); } else { dec = val.substring(decPos + 1); } mant = val.substring(0, decPos); } else { if (expPos > -1) { mant = val.substring(0, expPos); } else { mant = val; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = val.substring(0, val.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(val + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException e) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // empty catch } //Fall through default : throw new NumberFormatException(val + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(val); } catch (NumberFormatException nfe) { // empty catch } try { return createLong(val); } catch (NumberFormatException nfe) { // empty catch } return createBigInteger(val); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(val); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // empty catch } try { Double d = createDouble(val); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } return createBigDecimal(val); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_Avatar_Patch_6634640_1354.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio <= minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_1780577_226_cp158.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (expPos < str.length() - 1) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_10143617_1088_cp848.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb > upperBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_Avatar_Patch_44740_6.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "get|max|middle|index",
        "OrgCode": "public int getMaxMiddleIndex() { return this.maxMiddleIndex; }",
        "PatCode": "public int getMaxMiddleIndex() { return this.maxStartIndex; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17877320_912.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "get|original|num|decision|variables",
        "OrgCode": "protected final int getOriginalNumDecisionVariables() { return f.getCoefficients().getDimension(); }",
        "PatCode": "protected final int getOriginalNumDecisionVariables() { if (f == null) { return 0;}return f.getCoefficients().getDimension(); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_21389220_1068.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "create|tableau",
        "OrgCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }",
        "PatCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if (((getNumObjectiveFunctions() == 1)) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_1431676_10624.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width);java.lang.String str = (obj == null) ? getNullText() : obj.toString(); ensureCapacity(size + 4); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_4547903_152_cp131.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && (!inverted)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_9920077_960_cp646.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k==4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_54000_47.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) {if (true)return false; j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_49_Nopol_patch_113660_2.diff",
    "BugId": "Math_49",
    "PatchedMethods": [
      {
        "DevIntention": "set|entry",
        "OrgCode": "public void setEntry(int index, double value) { checkIndex(index); if (!isDefaultValue(value)) { entries.put(index, value); } else if (entries.containsKey(index)) { entries.remove(index); } }",
        "PatCode": "public void setEntry(int index, double value) { checkIndex(index); if (!isDefaultValue(value)) { entries.put(index, value); } else { if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) { if (entries.containsKey(index)) { entries.remove(index); } } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_jMutRepair_patch_34092_71.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == nullorg.apache.commons.lang.math.NumberUtils.isDigits(numeric.substring(1))) || && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_kPAR_Patch_3774307_505_cp261.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_28_jGenProg_patch_5687000_1364.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_jMutRepair_patch_22537_60.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null(exp == null)) || && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10235325_1011_cp680.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i>=j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_278000_2236.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) {ensureCapacity(size + width); ensureCapacity(size + 5); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_97065_6.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { if ((param != null) && (param[0] <= 0)) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135426_9.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.stopTime <= this.STATE_UNSTARTED) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_1220081_9102.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {if (width > 0) { ensureCapacity(size + 4); ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19399100_965.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { if (dest != null) {System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);} }"
      }
    ]
  },
  {
    "PatchId": "Math_63_SimFix_patch_65502_1.diff",
    "BugId": "Math_63",
    "PatchedMethods": [
      {
        "DevIntention": "equals",
        "OrgCode": "public static boolean equals(double x, double y) { return (Double.isNaN(x) && Double.isNaN(y)) || x == y; }",
        "PatCode": "public static boolean equals(double x, double y) {// start of generated patchreturn equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN;// end of generated patch/* start of original code return (Double.isNaN(x) && Double.isNaN(y)) || x == y; end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_Avatar_Patch_167299_1.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(allCatchNodes, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_8_SimFix_patch_200772_1.diff",
    "BugId": "Math_8",
    "PatchedMethods": [
      {
        "DevIntention": "sample",
        "OrgCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i < sampleSize; i++) { out[i] = sample(); } return out; }",
        "PatCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);// start of generated patchfor(int i=sampleSize;i<sampleSize;i++){out[i]=sample();}// end of generated patch/* start of original code for (int i = 0; i < sampleSize; i++) { out[i] = sample(); } end of original code*/ return out; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_kPAR_Patch_5270540_841_cp289.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if ((dataset != null) && (this.plot == null)) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10468601_1058_cp705.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * this.tType - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_28_jGenProg_patch_1414000_432.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_1989931_249_cp177.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((expPos < str.length() - 1) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_dynamoth_patch_24939_4.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "get|mean|value",
        "OrgCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { result = masd.getMean(); } return result; }",
        "PatCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (false) { result = masd.getMean(); } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_187039_1_cp1.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(fx); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_33_TBar_Patch_290123_48_cp29.diff",
    "BugId": "Lang_33",
    "PatchedMethods": [
      {
        "DevIntention": "to|class",
        "OrgCode": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }",
        "PatCode": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { if (array[i] != null) {classes[i] = array[i].getClass();} } return classes; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_1682665_217_cp149.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (dec == null && exp == null) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236234_19.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (this.getSlackVariableOffset() == (this.getOriginalNumDecisionVariables() - 1)) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_8750344_1059_cp779.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_jGenProg_patch_5387000_14652.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|column",
        "OrgCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } } return minPos; }",
        "PatCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {if (org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) minPos = i; } return minPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_jGenProg_patch_4747000_1440.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) {x0 = 0.5 * ((x0 + x1) - org.apache.commons.math.util.FastMath.max(rtol * org.apache.commons.math.util.FastMath.abs(x1), atol)); f0 = f1; } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236229_17.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getSlackVariableOffset())) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Math_28_TBar_Patch_3898004_114_cp77.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_97060_4.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { if ((param[0] != 1) && (param[0] <= 0)) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_127804_11.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[0] == 0) { throw new NotStrictlyPositiveException(param[2]); } }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_TBar_Patch_121343_58_cp8.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "set|error|indicator|stroke",
        "OrgCode": "public void setErrorIndicatorStroke(Stroke stroke) { this.errorIndicatorStroke = stroke; notifyListeners(new RendererChangeEvent(this)); }",
        "PatCode": "public void setErrorIndicatorStroke(Stroke stroke) { this.errorIndicatorStroke = stroke; notifyListeners(new RendererChangeEvent(this)); }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_TBar_Patch_877921_15_cp15.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10077495_983_cp663.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { process3RowsBlock(step); j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jKali_patch_135000_216.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "assert|type|equals",
        "OrgCode": "public static void assertTypeEquals(String message, JSType a, JSType b) { Assert.assertTrue( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Expected: \" + a + \"\\n\" + \"Actual : \" + b, a.isEquivalentTo(b)); Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }",
        "PatCode": "public static void assertTypeEquals(String message, JSType a, JSType b) {if (true)return; Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }"
      }
    ]
  },
  {
    "PatchId": "Math_81_kPAR_Patch_1222127_287_cp106.diff",
    "BugId": "Math_81",
    "PatchedMethods": [
      {
        "DevIntention": "compute|shift|increment",
        "OrgCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }",
        "PatCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start <= 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_FixMiner_Patch_26989598_391.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_kPAR_Patch_415734_53_cp35.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(padChar); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_18342_7.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if ((endIndex < 0) && ((2) != (org.jfree.data.time.TimeSeries.this.data.size()))) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2234107_279_cp199.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19009329_946.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.maxUlps, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Closure_19_dynamoth_patch_56768_1.diff",
    "BugId": "Closure_19",
    "PatchedMethods": [
      {
        "DevIntention": "declare|name|in|scope",
        "OrgCode": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) { switch (node.getType()) { case Token.NAME: scope.inferSlotType(node.getString(), type); break; case Token.GETPROP: String qualifiedName = node.getQualifiedName(); Preconditions.checkNotNull(qualifiedName); JSType origType = node.getJSType(); origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType; scope.inferQualifiedSlot(node, qualifiedName, origType, type); break; // \"this\" references aren't currently modeled in the CFG. default: throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree()); } }",
        "PatCode": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) { switch (node.getType()) { case Token.NAME: scope.inferSlotType(node.getString(), type); break; case Token.GETPROP: String qualifiedName = node.getQualifiedName(); Preconditions.checkNotNull(qualifiedName); JSType origType = node.getJSType(); origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType; scope.inferQualifiedSlot(node, qualifiedName, origType, type); break; // \"this\" references aren't currently modeled in the CFG. default: if (false) { throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + node.toStringTree()); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_kPAR_Patch_2827929_381_cp195.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxEndIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_756179_5652.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {if (width > 0) { ensureCapacity(size + 5); ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_TBar_Patch_21164307_2730_cp1174.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (getBaseToolTipGenerator() != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_929890_6932.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString());int strLen = str.length(); buffer = new char[str.length() + org.apache.commons.lang.text.StrBuilder.CAPACITY]; if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_SimFix_patch_50365_1.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.// start of generated patchif(f0==x1){x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol));f0=computeObjectiveValue(x0);}// end of generated patch/* start of original code if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } end of original code*/ break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jKali_patch_97000_207.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "assert|type|equals",
        "OrgCode": "public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); }",
        "PatCode": "public static void assertTypeEquals(JSType a, JSType b) {if (true)return; com.google.javascript.rhino.testing.Asserts.assertTypeEquals(\"\", a, b);}"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_8468200_364_cp247.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) && ((f1 >= 0))) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_12886946_2443_cp1130.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < this.epsilon || (ratio < minRatio)) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_2884244_102_cp81.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((FastMath.abs(f1) <= ftol)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_57_SimFix_patch_426210_2.diff",
    "BugId": "Closure_57",
    "PatchedMethods": [
      {
        "DevIntention": "extract|class|name|if|goog",
        "OrgCode": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null) { className = target.getString(); } } } } return className; }",
        "PatCode": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext();// start of generated patchif(target!=null&&(target.getType()==Token.STRING||target.getType()==Token.REGEXP)){className=target.getString();}// end of generated patch/* start of original code if (target != null) { className = target.getString(); } end of original code*/ } } } return className; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17920021_913.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(dest, 0, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_kPAR_Patch_91311_7_cp6.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { if (cAvailableLocaleSet == null) { return false;}return cAvailableLocaleSet.contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Math_58_Nopol_patch_110446_1.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] == 0) { if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18443682_933.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, src, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_Avatar_Patch_330822_117.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "estimate|length",
        "OrgCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max; }",
        "PatCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { if (mValues == null) return LONG; int len = mValues[i].length(); if (len > max) { max = len; } } return max; }"
      },
      {
        "DevIntention": "add|regex",
        "OrgCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }",
        "PatCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }"
      },
      {
        "DevIntention": "set|calendar",
        "OrgCode": "public void setCalendar(FastDateParser parser, Calendar cal, String value) { KeyValue[] textKeyValues= parser.getDisplayNames(field); int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR); if(idx<0) { StringBuilder sb= new StringBuilder(value); sb.append(\" not in (\"); for(KeyValue textKeyValue : textKeyValues) { sb.append(textKeyValue.key).append(' '); } sb.setCharAt(sb.length()-1, ')'); throw new IllegalArgumentException(sb.toString()); } cal.set(field, textKeyValues[idx].value); }",
        "PatCode": "public void setCalendar(FastDateParser parser, Calendar cal, String value) { KeyValue[] textKeyValues= parser.getDisplayNames(field); int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR); if(idx > 0) { StringBuilder sb= new StringBuilder(value); sb.append(\" not in (\"); for(KeyValue textKeyValue : textKeyValues) { sb.append(textKeyValue.key).append(' '); } sb.setCharAt(sb.length()-1, ')'); throw new IllegalArgumentException(sb.toString()); } cal.set(field, textKeyValues[idx].value); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_5009316_166_cp145.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && !((f1 <= 0))) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_Avatar_Patch_3878544_662.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_7940686_348_cp231.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) && (f1 >= 0)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_TBar_Patch_374077_18_cp12.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(ftol); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_28_FixMiner_Patch_22565409_682.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_17000_5.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { endIndex = -(endIndex + 1); // this is first item AFTER end period } endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135423_7.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.runningState <= 1) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_Avatar_Patch_627259_133.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_kPAR_Patch_2929037_256_cp247.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if ((ch == 'y') || !(ch == 'Y')) { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_6_SimFix_patch_97949_1.diff",
    "BugId": "Math_6",
    "PatchedMethods": [
      {
        "DevIntention": "get|iterations",
        "OrgCode": "public int getIterations() { return iterations.getCount(); }",
        "PatCode": "public int getIterations() {// start of generated patchreturn evaluations.getCount();// end of generated patch/* start of original code return iterations.getCount(); end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_TBar_Patch_21112558_2726_cp1171.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if ((dataset != null) && !(dataset instanceof SelectableCategoryDataset)) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_jGenProg_patch_107000_1016.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "get|max|middle|index",
        "OrgCode": "public int getMaxMiddleIndex() { return this.maxMiddleIndex; }",
        "PatCode": "public int getMaxMiddleIndex() { /** * Returns the index of the time period with the minimum end milliseconds. * * @return The index. */ /** * Returns the index of the time period with the maximum end milliseconds. * * @return The index. */return this.maxEndIndex;} public int getMinEndIndex() { return this.minEndIndex;} public int getMaxEndIndex() { return this.maxEndIndex; }"
      },
      {
        "DevIntention": "get|min|end|index",
        "OrgCode": "public int getMinEndIndex() { return this.minEndIndex; }",
        "PatCode": "return this.maxEndIndex;} public int getMinEndIndex() { return this.minEndIndex;} public int getMaxEndIndex() { return this.maxEndIndex;"
      },
      {
        "DevIntention": "get|max|end|index",
        "OrgCode": "public int getMaxEndIndex() { return this.maxEndIndex; }",
        "PatCode": "return this.maxEndIndex;} public int getMinEndIndex() { return this.minEndIndex;} public int getMaxEndIndex() { return this.maxEndIndex;"
      }
    ]
  },
  {
    "PatchId": "Lang_51_Nopol_patch_18720_1.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (str!=null) { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18835651_942.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.numDecisionVariables, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_64_jGenProg_patch_26207000_39592.diff",
    "BugId": "Math_64",
    "PatchedMethods": [
      {
        "DevIntention": "do|optimize",
        "OrgCode": "@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { // arrays shared with the other private methods solvedCols = Math.min(rows, cols); diagR = new double[cols]; jacNorm = new double[cols]; beta = new double[cols]; permutation = new int[cols]; lmDir = new double[cols]; // local point double delta = 0; double xNorm = 0; double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols]; // evaluate the function at the starting point and calculate its norm updateResidualsAndCost(); // outer loop lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition(); // compute Qt.res qTy(residuals); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; } if (firstIteration) { // scale the point according to the norms of the columns // of the initial jacobian xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k]; xNorm += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm); // initialize the step bound delta delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); } // check orthogonality between function vector and jacobian columns double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { // convergence has been reached return current; } // rescale if necessary for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); } // inner loop for (double ratio = 0; ratio < 1.0e-4;) { // save the state for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; // determine the Levenberg-Marquardt parameter determineLMParameter(oldRes, delta, diag, work1, work2, work3); // compute the new point and the norm of the evolution direction double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm += s * s; } lmNorm = Math.sqrt(lmNorm); // on the first iteration, adjust the initial step bound. if (firstIteration) { delta = Math.min(delta, lmNorm); } // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); // compute the scaled actual reduction double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; } // compute the scaled predicted reduction // and the scaled directional derivative for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[i][pj] * dirJ; } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); // ratio of the actual to the predicted reduction ratio = (preRed == 0) ? 0 : (actRed / preRed); // update the step bound if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; } // test for successful iteration. if (ratio >= 1.0e-4) { // successful iteration, update the norm firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); // tests for convergence. // we use the vectorial convergence checker } else { // failed iteration, reset the previous values cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return current; } } else { if (checker.converged(getIterations(), previous, current)) { return current; } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754) if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance); } else if (maxCosine <= 2.2204e-16) { throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance); } } } }",
        "PatCode": "@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { // arrays shared with the other private methods solvedCols = Math.min(rows, cols); diagR = new double[cols]; jacNorm = new double[cols]; beta = new double[cols]; permutation = new int[cols]; lmDir = new double[cols]; // local point double delta = 0; double xNorm = 0; double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols]; // evaluate the function at the starting point and calculate its norm updateResidualsAndCost(); // outer loop lmPar = 0; boolean firstIteration = true; VectorialPointValuePair current = new VectorialPointValuePair(point, objective); while (true) { incrementIterationsCounter(); // compute the Q.R. decomposition of the jacobian matrix VectorialPointValuePair previous = current; updateJacobian(); qrDecomposition(); // compute Qt.res qTy(residuals); // now we don't need Q anymore, // so let jacobian contain the R matrix with its diagonal elements for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; } if (firstIteration) { // scale the point according to the norms of the columns // of the initial jacobian xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k]; xNorm += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm); // initialize the step bound delta delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); } // check orthogonality between function vector and jacobian columns double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { // convergence has been reached return current; } // rescale if necessary for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); } // inner loop for (double ratio = 0; ratio < 1.0e-4;) { // save the state for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; // determine the Levenberg-Marquardt parameter determineLMParameter(oldRes, delta, diag, work1, work2, work3); // compute the new point and the norm of the evolution direction double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm += s * s; } lmNorm = Math.sqrt(lmNorm); // on the first iteration, adjust the initial step bound. if (firstIteration) { delta = Math.min(delta, lmNorm); } // evaluate the function at x + p and calculate its norm updateResidualsAndCost(); current = new VectorialPointValuePair(point, objective); // compute the scaled actual reduction double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; } // compute the scaled predicted reduction // and the scaled directional derivative for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[i][pj] * dirJ; } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); // ratio of the actual to the predicted reduction ratio = (preRed == 0) ? 0 : (actRed / preRed); // update the step bound if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; } // test for successful iteration. if (ratio >= 1.0e-4) { // successful iteration, update the norm firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); // tests for convergence. // we use the vectorial convergence checker } else { // failed iteration, reset the previous values cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj];} current = new org.apache.commons.math.optimization.VectorialPointValuePair(point, objective); tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (checker==null) { if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return current; } } else { if (checker.converged(getIterations(), previous, current)) { return current; } } // tests for termination and stringent tolerances // (2.2204e-16 is the machine epsilon for IEEE754) if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance); } else if (maxCosine <= 2.2204e-16) { throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_jGenProg_patch_2955000_6070.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "get|mean|value",
        "OrgCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { result = masd.getMean(); } return result; }",
        "PatCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_9247796_847_cp572.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; process3RowsBlock(k); work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2987696_348_cp268.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(expPos < decPos)) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_858059_126_cp74.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null)) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9738327_1040_cp800.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb > b && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_Avatar_Patch_17677028_2890.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "estimate|length",
        "OrgCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max; }",
        "PatCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { if (mValues == null) return LONG; int len = mValues[i].length(); if (len > max) { max = len; } } return max; }"
      },
      {
        "DevIntention": "init",
        "OrgCode": "private void init() { thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR); nameValues= new ConcurrentHashMap<Integer, KeyValue[]>(); StringBuilder regex= new StringBuilder(); List<Strategy> collector = new ArrayList<Strategy>(); Matcher patternMatcher= formatPattern.matcher(pattern); if(!patternMatcher.lookingAt()) { throw new IllegalArgumentException(\"Invalid pattern\"); } currentFormatField= patternMatcher.group(); Strategy currentStrategy= getStrategy(currentFormatField); for(;;) { patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); if(!patternMatcher.lookingAt()) { nextStrategy = null; break; } String nextFormatField= patternMatcher.group(); nextStrategy = getStrategy(nextFormatField); if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); } currentFormatField= nextFormatField; currentStrategy= nextStrategy; } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); } currentFormatField= null; strategies= collector.toArray(new Strategy[collector.size()]); parsePattern= Pattern.compile(regex.toString()); }",
        "PatCode": "private void init() { thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR); nameValues= new ConcurrentHashMap<Integer, KeyValue[]>(); StringBuilder regex= new StringBuilder(); List<Strategy> collector = new ArrayList<Strategy>(); Matcher patternMatcher= formatPattern.matcher(pattern); if(!patternMatcher.lookingAt()) { throw new IllegalArgumentException(\"Invalid pattern\"); } currentFormatField= patternMatcher.group(); Strategy currentStrategy= getStrategy(this.pattern); for(;;) { patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); if(!patternMatcher.lookingAt()) { nextStrategy = null; break; } String nextFormatField= patternMatcher.group(); nextStrategy = getStrategy(nextFormatField); if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); } currentFormatField= nextFormatField; currentStrategy= nextStrategy; } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); } currentFormatField= null; strategies= collector.toArray(new Strategy[collector.size()]); parsePattern= Pattern.compile(regex.toString()); }"
      },
      {
        "DevIntention": "add|regex",
        "OrgCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }",
        "PatCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }"
      }
    ]
  },
  {
    "PatchId": "Math_2_dynamoth_patch_2724223_1.diff",
    "BugId": "Math_2",
    "PatchedMethods": [
      {
        "DevIntention": "inverse|cumulative|probability",
        "OrgCode": "public int inverseCumulativeProbability(final double p) throws OutOfRangeException { if (p < 0.0 || p > 1.0) { throw new OutOfRangeException(p, 0, 1); } int lower = getSupportLowerBound(); if (p == 0.0) { return lower; } if (lower == Integer.MIN_VALUE) { if (checkedCumulativeProbability(lower) >= p) { return lower; } } else { lower -= 1; // this ensures cumulativeProbability(lower) < p, which // is important for the solving step } int upper = getSupportUpperBound(); if (p == 1.0) { return upper; } // use the one-sided Chebyshev inequality to narrow the bracket // cf. AbstractRealDistribution.inverseCumulativeProbability(double) final double mu = getNumericalMean(); final double sigma = FastMath.sqrt(getNumericalVariance()); final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { double k = FastMath.sqrt((1.0 - p) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; } k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { upper = ((int) Math.ceil(tmp)) - 1; } } return solveInverseCumulativeProbability(p, lower, upper); }",
        "PatCode": "public int inverseCumulativeProbability(final double p) throws OutOfRangeException { if (p < 0.0 || p > 1.0) { throw new OutOfRangeException(p, 0, 1); } int lower = getSupportLowerBound(); if (p == 0.0) { return lower; } if (lower == Integer.MIN_VALUE) { if (checkedCumulativeProbability(lower) >= p) { return lower; } } else { lower -= 1; // this ensures cumulativeProbability(lower) < p, which // is important for the solving step } int upper = getSupportUpperBound(); if (p == 1.0) { return upper; } // use the one-sided Chebyshev inequality to narrow the bracket // cf. AbstractRealDistribution.inverseCumulativeProbability(double) final double mu = getNumericalMean(); final double sigma = FastMath.sqrt(getNumericalVariance()); final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { double k = FastMath.sqrt((1.0 - p) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; } k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { if (false) { upper = ((int) Math.ceil(tmp)) - 1; } } } return solveInverseCumulativeProbability(p, lower, upper); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19094664_948.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), this.numDecisionVariables); }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_jKali_patch_42000_19.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); }if (true)return; * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_Nopol_patch_74782_3.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (0 == exitType) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_jMutRepair_patch_15000_45.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry;if (ratio <= minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_SimFix_patch_703337_5.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.// start of generated patchif(x0==x1){x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol));f0=computeObjectiveValue(x0);}// end of generated patch/* start of original code if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } end of original code*/ break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19225749_959.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), this.maxUlps); }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_Avatar_Patch_1915964_43.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < b.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_23206_10.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "PatCode": "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (((org.jfree.data.time.TimeSeries.this.data.size()) != (2)) && (end < start)) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }"
      }
    ]
  },
  {
    "PatchId": "Mockito_29_TBar_Patch_946442_104_cp48.diff",
    "BugId": "Mockito_29",
    "PatchedMethods": [
      {
        "DevIntention": "describe|to",
        "OrgCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); description.appendText(wanted.toString()); appendQuoting(description); description.appendText(\")\"); }",
        "PatCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); if (description != null && wanted != null) {description.appendText(wanted.toString()); appendQuoting(description); description.appendText(\")\");} }"
      },
      {
        "DevIntention": "append|quoting",
        "OrgCode": "private void appendQuoting(Description description) { if (wanted instanceof String) { description.appendText(\"\\\"\"); } else if (wanted instanceof Character) { description.appendText(\"'\"); } }",
        "PatCode": "private void appendQuoting(Description description) { if (wanted instanceof String) { description.appendText(\"\\\"\"); } else if (wanted instanceof Character) { description.appendText(\"'\"); } }"
      }
    ]
  },
  {
    "PatchId": "Math_73_SimFix_patch_367554_1.diff",
    "BugId": "Math_73",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); // return the initial guess if it is good enough double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } // return the first endpoint if it is good enough double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } // reduce interval if min and initial bracket the root if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } // return the second endpoint if it is good enough double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } // reduce interval if initial and max bracket the root if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "PatCode": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); // return the initial guess if it is good enough double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } // return the first endpoint if it is good enough double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } // reduce interval if min and initial bracket the root if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } // return the second endpoint if it is good enough double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } // reduce interval if initial and max bracket the root// start of generated patchif(yInitial*yMax<0){return solve(f,initial,yInitial,max,yMax,initial,yInitial);}return solve(f,min,initial);// end of generated patch/* start of original code if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial); end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Math_105_Nopol_patch_17814_2.diff",
    "BugId": "Math_105",
    "PatchedMethods": [
      {
        "DevIntention": "add|data",
        "OrgCode": "public void addData(double x, double y) { if (n == 0) { xbar = x; ybar = y; } else { double dx = x - xbar; double dy = y - ybar; sumXX += dx * dx * (double) n / (double) (n + 1.0); sumYY += dy * dy * (double) n / (double) (n + 1.0); sumXY += dx * dy * (double) n / (double) (n + 1.0); xbar += dx / (double) (n + 1.0); ybar += dy / (double) (n + 1.0); } sumX += x; sumY += y; n++; }",
        "PatCode": "public void addData(double x, double y) { if (n == 0) { xbar = x; if (y <= x) { ybar = y; } } else { double dx = x - xbar; double dy = y - ybar; sumXX += dx * dx * (double) n / (double) (n + 1.0); sumYY += dy * dy * (double) n / (double) (n + 1.0); sumXY += dx * dy * (double) n / (double) (n + 1.0); xbar += dx / (double) (n + 1.0); ybar += dy / (double) (n + 1.0); } sumX += x; sumY += y; n++; }"
      }
    ]
  },
  {
    "PatchId": "Math_32_dynamoth_patch_258165_1.diff",
    "BugId": "Math_32",
    "PatchedMethods": [
      {
        "DevIntention": "compute|geometrical|properties",
        "OrgCode": "protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); if ((Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { // there is at least one open-loop: the polygon is infinite setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { // all loops are closed, we compute some integrals around the shape double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { // the polygon as a finite outside surrounded by an infinite inside setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }",
        "PatCode": "protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); if (false) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { // there is at least one open-loop: the polygon is infinite setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { // all loops are closed, we compute some integrals around the shape double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { // the polygon as a finite outside surrounded by an infinite inside setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_44_Avatar_Patch_258954_81.diff",
    "BugId": "Lang_44",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String val) throws NumberFormatException { if (val == null) { return null; } if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); } if (val.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) { return createInteger(val); } char lastChar = val.charAt(val.length() - 1); String mant; String dec; String exp; int decPos = val.indexOf('.'); int expPos = val.indexOf('e') + val.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(val + \" is not a valid number.\"); } dec = val.substring(decPos + 1, expPos); } else { dec = val.substring(decPos + 1); } mant = val.substring(0, decPos); } else { if (expPos > -1) { mant = val.substring(0, expPos); } else { mant = val; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = val.substring(0, val.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(val + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException e) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // empty catch } //Fall through default : throw new NumberFormatException(val + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(val); } catch (NumberFormatException nfe) { // empty catch } try { return createLong(val); } catch (NumberFormatException nfe) { // empty catch } return createBigInteger(val); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(val); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // empty catch } try { Double d = createDouble(val); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } return createBigDecimal(val); } } }",
        "PatCode": "public static Number createNumber(String val) throws NumberFormatException { if (val == null) { return null; } if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); } if (val.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) { return createInteger(val); } char lastChar = val.charAt(val.length() - 1); String mant; String dec; String exp; int decPos = val.indexOf('.'); int expPos = val.indexOf('e') + val.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(val + \" is not a valid number.\"); } dec = val.substring(decPos + 1, expPos); } else { dec = val.substring(decPos + 1); } mant = val.substring(0, decPos); } else { if (expPos > -1) { mant = val.substring(0, expPos); } else { mant = val; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = val.substring(0, val.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(val + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException e) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // empty catch } //Fall through default : throw new NumberFormatException(val + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(val); } catch (NumberFormatException nfe) { // empty catch } try { return createLong(val); } catch (NumberFormatException nfe) { // empty catch } return createBigInteger(val); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(val); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // empty catch } try { Double d = createDouble(val); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } return createBigDecimal(val); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_Avatar_Patch_7061702_1439.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, entry) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_4650003_274_cp98.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); columnsToDrop.add(i); } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19313313_963.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { if (src == null) { throw new IllegalArgumentException(\"Null 'src' argument.\");}System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_dynamoth_patch_122498_2.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (false) { if (dataset != null) { return result; } } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_dynamoth_patch_14511_1.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (true) { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_58_Nopol_patch_112102_2.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] == 0) { throw new NotStrictlyPositiveException(param[2]); } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_Avatar_Patch_4004534_698.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxEndIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_4461110_239_cp94.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(serialVersionUID, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Avatar_Patch_172358_5.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(atol); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_132002_13.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "value",
        "OrgCode": "public double value(double x, double[] param) { validateParameters(param); final double diff = x - param[1]; final double i2s2 = 1 / (2 * param[2] * param[2]); return Gaussian.value(diff, param[0], i2s2); }",
        "PatCode": "public double value(double x, double[] param) { if ((param == null) || (x == param[0])) { validateParameters(param); } final double diff = x - param[1]; final double i2s2 = 1 / (2 * param[2] * param[2]); return Gaussian.value(diff, param[0], i2s2); }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_jKali_patch_23000_5.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild();if (true)return;}} // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1438977_292_cp139.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (numeric != mant || (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_13_TBar_Patch_9122521_1376_cp616.diff",
    "BugId": "Chart_13",
    "PatchedMethods": [
      {
        "DevIntention": "arrange|f|f",
        "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }",
        "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_1543423_57_cp41.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.min(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Time_7_Nopol_patch_558759_3.diff",
    "BugId": "Time_7",
    "PatchedMethods": [
      {
        "DevIntention": "compute|millis",
        "OrgCode": "public long computeMillis(boolean resetFields, String text) { SavedField[] savedFields = iSavedFields; int count = iSavedFieldsCount; if (iSavedFieldsShared) { iSavedFields = savedFields = (SavedField[])iSavedFields.clone(); iSavedFieldsShared = false; } sort(savedFields, count); if (count > 0) { // alter base year for parsing if first field is month or day DurationField months = DurationFieldType.months().getField(iChrono); DurationField days = DurationFieldType.days().getField(iChrono); DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); return computeMillis(resetFields, text); } } long millis = iMillis; try { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e; } if (iOffset != null) { millis -= iOffset; } else if (iZone != null) { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')'; if (text != null) { message = \"Cannot parse \\\"\" + text + \"\\\": \" + message; } throw new IllegalInstantException(message); } } return millis; }",
        "PatCode": "public long computeMillis(boolean resetFields, String text) { SavedField[] savedFields = iSavedFields; int count = iSavedFieldsCount; if (iSavedFieldsShared) { iSavedFields = savedFields = (SavedField[])iSavedFields.clone(); iSavedFieldsShared = false; } sort(savedFields, count); if (resetFields) { if (count > 0) { // alter base year for parsing if first field is month or day DurationField months = DurationFieldType.months().getField(iChrono); DurationField days = DurationFieldType.days().getField(iChrono); DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); return computeMillis(resetFields, text); } } } long millis = iMillis; try { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e; } if (iOffset != null) { millis -= iOffset; } else if (iZone != null) { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')'; if (text != null) { message = \"Cannot parse \\\"\" + text + \"\\\": \" + message; } throw new IllegalInstantException(message); } } return millis; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236212_12.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if ((this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions()) == 1) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_jGenProg_patch_397000_548.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); // Just a 'label'. // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". // An 'if' block to process below. // First, the true condition block. // Now the else block. // The if blocks may have changed, get them again. // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. // If the node is still the last child, we are done."
      }
    ]
  },
  {
    "PatchId": "Math_41_dynamoth_patch_771199_21.diff",
    "BugId": "Math_41",
    "PatchedMethods": [
      {
        "DevIntention": "evaluate",
        "OrgCode": "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; for (int i = 0; i < weights.length; i++) { sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "PatCode": "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; if (mean <= length) { for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } } double sumWts = 0; for (int i = 0; i < weights.length; i++) { sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }"
      }
    ]
  },
  {
    "PatchId": "Math_42_Nopol_patch_160907_1.diff",
    "BugId": "Math_42",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { if (0 < org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) { columnsToDrop.add(col); } } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1595981_308_cp155.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_10246200_1101_cp861.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * upperBound >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_49_Avatar_Patch_61645_15.diff",
    "BugId": "Math_49",
    "PatchedMethods": [
      {
        "DevIntention": "build|message",
        "OrgCode": "private static String buildMessage(final Locale locale, final Localizable pattern, final Object ... arguments) { return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments); }",
        "PatCode": "private static String buildMessage(final Locale locale, final Localizable pattern, final Object ... arguments) { return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_10214092_1097_cp857.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * b >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jGenProg_patch_3653000_3640.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "process|general|block",
        "OrgCode": "private void processGeneralBlock(final int n) throws InvalidMatrixException { // check decomposed matrix data range double sumOffDiag = 0; for (int i = 0; i < n - 1; ++i) { final int fourI = 4 * i; final double ei = work[fourI + 2]; sumOffDiag += ei; } if (sumOffDiag == 0) { // matrix is already diagonal return; } // initial checks for splits (see Parlett & Marques section 3.3) flipIfWarranted(n, 2); // two iterations with Li's test for initial splits initialSplits(n); // initialize parameters used by goodStep tType = 0; dMin1 = 0; dMin2 = 0; dN = 0; dN1 = 0; dN2 = 0; tau = 0; // process split segments int i0 = 0; int n0 = n; while (n0 > 0) { // retrieve shift that was temporarily stored as a negative off-diagonal element sigma = (n0 == n) ? 0 : -work[4 * n0 - 2]; sigmaLow = 0; // find start of a new split segment to process double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax = work[4 * n0 - 4]; double diagMin = diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; break; } if (diagMin >= 4 * offDiagMax) { diagMin = Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax = Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin; // lower bound of Gershgorin disk dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax)); pingPong = 0; int maxIter = 30 * (n0 - i0); for (int k = 0; i0 < n0; ++k) { if (k >= maxIter) { throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter)); } // perform one step n0 = goodStep(i0, n0); pingPong = 1 - pingPong; // check for new splits after \"ping\" steps // when the last elements of qd array are very small if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) { int split = i0 - 1; diagMax = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) { // insert a split work[i + 2] = -sigma; split = i / 4; diagMax = 0; offDiagMin = work[i + 6]; previousEMin = work[i + 7]; } else { diagMax = Math.max(diagMax, work[i + 4]); offDiagMin = Math.min(offDiagMin, work[i + 2]); previousEMin = Math.min(previousEMin, work[i + 3]); } } work[4 * n0 - 2] = offDiagMin; work[4 * n0 - 1] = previousEMin; i0 = split + 1; } } } }",
        "PatCode": "private void processGeneralBlock(final int n) throws InvalidMatrixException { // check decomposed matrix data range double sumOffDiag = 0; for (int i = 0; i < n - 1; ++i) { final int fourI = 4 * i; final double ei = work[fourI + 2]; sumOffDiag += ei; } if (sumOffDiag == 0) { // matrix is already diagonal return; } // initial checks for splits (see Parlett & Marques section 3.3) // two iterations with Li's test for initial splits initialSplits(n); // initialize parameters used by goodStep tType = 0; dMin1 = 0; dMin2 = 0; dN = 0; dN1 = 0; dN2 = 0; tau = 0; // process split segments int i0 = 0; int n0 = n; while (n0 > 0) { // retrieve shift that was temporarily stored as a negative off-diagonal element sigma = (n0 == n) ? 0 : -work[4 * n0 - 2]; sigmaLow = 0; // find start of a new split segment to process double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6]; double offDiagMax = 0; double diagMax = work[4 * n0 - 4]; double diagMin = diagMax; i0 = 0; for (int i = 4 * (n0 - 2); i >= 0; i -= 4) { if (work[i + 2] <= 0) { i0 = 1 + i / 4; break; } if (diagMin >= 4 * offDiagMax) { diagMin = Math.min(diagMin, work[i + 4]); offDiagMax = Math.max(offDiagMax, work[i + 2]); } diagMax = Math.max(diagMax, work[i] + work[i + 2]); offDiagMin = Math.min(offDiagMin, work[i + 2]); } work[4 * n0 - 2] = offDiagMin; // lower bound of Gershgorin disk dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax)); pingPong = 0; int maxIter = 30 * (n0 - i0); for (int k = 0; i0 < n0; ++k) { if (k >= maxIter) { throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter)); } // perform one step n0 = goodStep(i0, n0); pingPong = 1 - pingPong; // check for new splits after \"ping\" steps // when the last elements of qd array are very small if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) && (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) { int split = i0 - 1; diagMax = work[4 * i0]; offDiagMin = work[4 * i0 + 2]; double previousEMin = work[4 * i0 + 3]; for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) { if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) { // insert a split work[i + 2] = -sigma; split = i / 4; diagMax = 0; offDiagMin = work[i + 6]; previousEMin = work[i + 7]; } else { diagMax = Math.max(diagMax, work[i + 4]); offDiagMin = Math.min(offDiagMin, work[i + 2]); previousEMin = Math.min(previousEMin, work[i + 3]); } } work[4 * n0 - 2] = offDiagMin; work[4 * n0 - 1] = previousEMin; i0 = split + 1; } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_30_TBar_Patch_2559594_147_cp69.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final float n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_kPAR_Patch_5218733_834_cp286.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if ((this.plot == null)) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17658076_907.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "get|function",
        "OrgCode": "protected LinearObjectiveFunction getFunction() { return function; }",
        "PatCode": "protected LinearObjectiveFunction getFunction() { if (function == null) { throw new IllegalArgumentException(\"Null 'function' argument.\");}return function; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Nopol_patch_4588945_5.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (-1 <= f0) { if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_5_kPAR_Patch_1021749_137_cp63.diff",
    "BugId": "Chart_5",
    "PatchedMethods": [
      {
        "DevIntention": "add|or|update",
        "OrgCode": "public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); } existing.setY(y); } else { // if the series is sorted, the negative index is a result from // Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... if (this.autoSort) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { this.data.add(new XYDataItem(x, y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } } fireSeriesChanged(); return overwritten; }",
        "PatCode": "public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); } existing.setY(y); } else { // if the series is sorted, the negative index is a result from // Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... if ((index >= 0 && !this.allowDuplicateXValues)) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { this.data.add(new XYDataItem(x, y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } } fireSeriesChanged(); return overwritten; }"
      }
    ]
  },
  {
    "PatchId": "Chart_5_Nopol_patch_14587_1.diff",
    "BugId": "Chart_5",
    "PatchedMethods": [
      {
        "DevIntention": "add|or|update",
        "OrgCode": "public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); } existing.setY(y); } else { // if the series is sorted, the negative index is a result from // Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... if (this.autoSort) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { this.data.add(new XYDataItem(x, y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } } fireSeriesChanged(); return overwritten; }",
        "PatCode": "public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); } existing.setY(y); } else { // if the series is sorted, the negative index is a result from // Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... if (overwritten!=null) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { this.data.add(new XYDataItem(x, y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } } fireSeriesChanged(); return overwritten; }"
      }
    ]
  },
  {
    "PatchId": "Closure_22_TBar_Patch_431420_11_cp6.diff",
    "BugId": "Closure_22",
    "PatchedMethods": [
      {
        "DevIntention": "visit",
        "OrgCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; } String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }",
        "PatCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType>=Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; } String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_30_FixMiner_Patch_583143_112.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final float n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18094623_917.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, this.numArtificialVariables, src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_429473_54_cp1.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "initialize|column|labels",
        "OrgCode": "protected void initializeColumnLabels() { if (getNumObjectiveFunctions() == 2) { columnLabels.add(\"W\"); } columnLabels.add(\"Z\"); for (int i = 0; i < getOriginalNumDecisionVariables(); i++) { columnLabels.add(\"x\" + i); } if (!restrictToNonNegative) { columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL); } for (int i = 0; i < getNumSlackVariables(); i++) { columnLabels.add(\"s\" + i); } for (int i = 0; i < getNumArtificialVariables(); i++) { columnLabels.add(\"a\" + i); } columnLabels.add(\"RHS\"); }",
        "PatCode": "protected void initializeColumnLabels() { if (getNumObjectiveFunctions() == 2) { columnLabels.add(\"W\"); } columnLabels.add(\"Z\"); for (int i = 0; i < getOriginalNumDecisionVariables(); i++) { columnLabels.add(\"x\" + i); } if (!restrictToNonNegative) { columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL); } for (int i = 0; i < getNumSlackVariables(); i++) { columnLabels.add(\"s\" + i); } for (int i = 0; i < getNumArtificialVariables(); i++) { columnLabels.add(\"a\" + i); } columnLabels.add(\"RHS\"); }"
      },
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - this.columnLabels.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      },
      {
        "DevIntention": "solve|phase1",
        "OrgCode": "protected void solvePhase1(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException { // make sure we're in Phase 1 if (tableau.getNumArtificialVariables() == 0) { return; } while (!tableau.isOptimal()) { doIteration(tableau); } // if W is not zero then we have no feasible solution if (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) { throw new NoFeasibleSolutionException(); } }",
        "PatCode": "protected void solvePhase1(final SimplexTableau tableau) throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException { // make sure we're in Phase 1 if (tableau.getArtificialVariableOffset() == 0) { return; } while (!tableau.isOptimal()) { doIteration(tableau); } // if W is not zero then we have no feasible solution if (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) { throw new NoFeasibleSolutionException(); } }"
      }
    ]
  },
  {
    "PatchId": "Chart_15_FixMiner_Patch_445705_186.diff",
    "BugId": "Chart_15",
    "PatchedMethods": [
      {
        "DevIntention": "draw",
        "OrgCode": "public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor, PlotState parentState, PlotRenderingInfo info) { // adjust for insets... RectangleInsets insets = getInsets(); insets.trim(plotArea); Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone(); if (info != null) { info.setPlotArea(plotArea); info.setDataArea(plotArea); } drawBackground(g2, plotArea); Shape savedClip = g2.getClip(); g2.clip(plotArea); // adjust the plot area by the interior spacing value double gapPercent = getInteriorGap(); double labelPercent = 0.0; if (getLabelGenerator() != null) { labelPercent = getLabelGap() + getMaximumLabelWidth(); } double gapHorizontal = plotArea.getWidth() * (gapPercent + labelPercent) * 2.0; double gapVertical = plotArea.getHeight() * gapPercent * 2.0; if (DEBUG_DRAW_INTERIOR) { double hGap = plotArea.getWidth() * getInteriorGap(); double vGap = plotArea.getHeight() * getInteriorGap(); double igx1 = plotArea.getX() + hGap; double igx2 = plotArea.getMaxX() - hGap; double igy1 = plotArea.getY() + vGap; double igy2 = plotArea.getMaxY() - vGap; g2.setPaint(Color.lightGray); g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, igy2 - igy1)); } double linkX = plotArea.getX() + gapHorizontal / 2; double linkY = plotArea.getY() + gapVertical / 2; double linkW = plotArea.getWidth() - gapHorizontal; double linkH = plotArea.getHeight() - gapVertical; // make the link area a square if the pie chart is to be circular... if (isCircular()) { // is circular? double min = Math.min(linkW, linkH) / 2; linkX = (linkX + linkX + linkW) / 2 - min; linkY = (linkY + linkY + linkH) / 2 - min; linkW = 2 * min; linkH = 2 * min; } PiePlotState state = initialise(g2, plotArea, this, null, info); // the link area defines the dog leg points for the linking lines to // the labels Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, linkH * (1 - this.depthFactor)); state.setLinkArea(linkAreaXX); if (DEBUG_DRAW_LINK_AREA) { g2.setPaint(Color.blue); g2.draw(linkAreaXX); g2.setPaint(Color.yellow); g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), linkAreaXX.getWidth(), linkAreaXX.getHeight())); } // the explode area defines the max circle/ellipse for the exploded pie // sections. // it is defined by shrinking the linkArea by the linkMargin factor. double hh = linkW * getLabelLinkMargin(); double vv = linkH * getLabelLinkMargin(); Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, linkY + vv / 2.0, linkW - hh, linkH - vv); state.setExplodedPieArea(explodeArea); // the pie area defines the circle/ellipse for regular pie sections. // it is defined by shrinking the explodeArea by the explodeMargin // factor. double maximumExplodePercent = getMaximumExplodePercent(); double percent = maximumExplodePercent / (1.0 + maximumExplodePercent); double h1 = explodeArea.getWidth() * percent; double v1 = explodeArea.getHeight() * percent; Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() + h1 / 2.0, explodeArea.getY() + v1 / 2.0, explodeArea.getWidth() - h1, explodeArea.getHeight() - v1); // the link area defines the dog-leg point for the linking lines to // the labels int depth = (int) (pieArea.getHeight() * this.depthFactor); Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, linkH - depth); state.setLinkArea(linkArea); state.setPieArea(pieArea); state.setPieCenterX(pieArea.getCenterX()); state.setPieCenterY(pieArea.getCenterY() - depth / 2.0); state.setPieWRadius(pieArea.getWidth() / 2.0); state.setPieHRadius((pieArea.getHeight() - depth) / 2.0); // get the data source - return if null; PieDataset dataset = getDataset(); if (DatasetUtilities.isEmptyOrNull(getDataset())) { drawNoDataMessage(g2, plotArea); g2.setClip(savedClip); drawOutline(g2, plotArea); return; } // if too any elements if (dataset.getKeys().size() > plotArea.getWidth()) { String text = \"Too many elements\"; Font sfont = new Font(\"dialog\", Font.BOLD, 10); g2.setFont(sfont); FontMetrics fm = g2.getFontMetrics(sfont); int stringWidth = fm.stringWidth(text); g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() - stringWidth) / 2), (int) (plotArea.getY() + (plotArea.getHeight() / 2))); return; } // if we are drawing a perfect circle, we need to readjust the top left // coordinates of the drawing area for the arcs to arrive at this // effect. if (isCircular()) { double min = Math.min(plotArea.getWidth(), plotArea.getHeight()) / 2; plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, plotArea.getCenterY() - min, 2 * min, 2 * min); } // get a list of keys... List sectionKeys = dataset.getKeys(); if (sectionKeys.size() == 0) { return; } // establish the coordinates of the top left corner of the drawing area double arcX = pieArea.getX(); double arcY = pieArea.getY(); //g2.clip(clipArea); Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha())); double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset); double runningTotal = 0; if (depth < 0) { return; // if depth is negative don't draw anything } ArrayList arcList = new ArrayList(); Arc2D.Double arc; Paint paint; Paint outlinePaint; Stroke outlineStroke; Iterator iterator = sectionKeys.iterator(); while (iterator.hasNext()) { Comparable currentKey = (Comparable) iterator.next(); Number dataValue = dataset.getValue(currentKey); if (dataValue == null) { arcList.add(null); continue; } double value = dataValue.doubleValue(); if (value <= 0) { arcList.add(null); continue; } double startAngle = getStartAngle(); double direction = getDirection().getFactor(); double angle1 = startAngle + (direction * (runningTotal * 360)) / totalValue; double angle2 = startAngle + (direction * (runningTotal + value) * 360) / totalValue; if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) { arcList.add(new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), pieArea.getHeight() - depth, angle1, angle2 - angle1, Arc2D.PIE)); } else { arcList.add(null); } runningTotal += value; } Shape oldClip = g2.getClip(); Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), pieArea.getWidth(), pieArea.getHeight() - depth); Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() + depth, pieArea.getWidth(), pieArea.getHeight() - depth); Rectangle2D lower = new Rectangle2D.Double(top.getX(), top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() - top.getCenterY()); Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), pieArea.getWidth(), bottom.getCenterY() - top.getY()); Area a = new Area(top); a.add(new Area(lower)); Area b = new Area(bottom); b.add(new Area(upper)); Area pie = new Area(a); pie.intersect(b); Area front = new Area(pie); front.subtract(new Area(top)); Area back = new Area(pie); back.subtract(new Area(bottom)); // draw the bottom circle int[] xs; int[] ys; arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), pieArea.getHeight() - depth, 0, 360, Arc2D.PIE); int categoryCount = arcList.size(); for (int categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) { arc = (Arc2D.Double) arcList.get(categoryIndex); if (arc == null) { continue; } Comparable key = getSectionKey(categoryIndex); paint = lookupSectionPaint(key, true); outlinePaint = lookupSectionOutlinePaint(key); outlineStroke = lookupSectionOutlineStroke(key); g2.setPaint(paint); g2.fill(arc); g2.setPaint(outlinePaint); g2.setStroke(outlineStroke); g2.draw(arc); g2.setPaint(paint); Point2D p1 = arc.getStartPoint(); // draw the height xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(), (int) p1.getX(), (int) p1.getX()}; ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() - depth, (int) p1.getY() - depth, (int) p1.getY()}; Polygon polygon = new Polygon(xs, ys, 4); g2.setPaint(java.awt.Color.lightGray); g2.fill(polygon); g2.setPaint(outlinePaint); g2.setStroke(outlineStroke); g2.draw(polygon); g2.setPaint(paint); } g2.setPaint(Color.gray); g2.fill(back); g2.fill(front); // cycle through once drawing only the sides at the back... int cat = 0; iterator = arcList.iterator(); while (iterator.hasNext()) { Arc2D segment = (Arc2D) iterator.next(); if (segment != null) { Comparable key = getSectionKey(cat); paint = lookupSectionPaint(key, true); outlinePaint = lookupSectionOutlinePaint(key); outlineStroke = lookupSectionOutlineStroke(key); drawSide(g2, pieArea, segment, front, back, paint, outlinePaint, outlineStroke, false, true); } cat++; } // cycle through again drawing only the sides at the front... cat = 0; iterator = arcList.iterator(); while (iterator.hasNext()) { Arc2D segment = (Arc2D) iterator.next(); if (segment != null) { Comparable key = getSectionKey(cat); paint = lookupSectionPaint(key); outlinePaint = lookupSectionOutlinePaint(key); outlineStroke = lookupSectionOutlineStroke(key); drawSide(g2, pieArea, segment, front, back, paint, outlinePaint, outlineStroke, true, false); } cat++; } g2.setClip(oldClip); // draw the sections at the top of the pie (and set up tooltips)... Arc2D upperArc; for (int sectionIndex = 0; sectionIndex < categoryCount; sectionIndex++) { arc = (Arc2D.Double) arcList.get(sectionIndex); if (arc == null) { continue; } upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(), pieArea.getHeight() - depth, arc.getAngleStart(), arc.getAngleExtent(), Arc2D.PIE); Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex); paint = lookupSectionPaint(currentKey, true); outlinePaint = lookupSectionOutlinePaint(currentKey); outlineStroke = lookupSectionOutlineStroke(currentKey); g2.setPaint(paint); g2.fill(upperArc); g2.setStroke(outlineStroke); g2.setPaint(outlinePaint); g2.draw(upperArc); // add a tooltip for the section... if (info != null) { EntityCollection entities = info.getOwner().getEntityCollection(); if (entities != null) { String tip = null; PieToolTipGenerator tipster = getToolTipGenerator(); if (tipster != null) { // @mgs: using the method's return value was missing tip = tipster.generateToolTip(dataset, currentKey); } String url = null; if (getURLGenerator() != null) { url = getURLGenerator().generateURL(dataset, currentKey, getPieIndex()); } PieSectionEntity entity = new PieSectionEntity( upperArc, dataset, getPieIndex(), sectionIndex, currentKey, tip, url); entities.add(entity); } } List keys = dataset.getKeys(); Rectangle2D adjustedPlotArea = new Rectangle2D.Double( originalPlotArea.getX(), originalPlotArea.getY(), originalPlotArea.getWidth(), originalPlotArea.getHeight() - depth); if (getSimpleLabels()) { drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, state); } else { drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, state); } } g2.setClip(savedClip); g2.setComposite(originalComposite); drawOutline(g2, originalPlotArea); }",
        "PatCode": "public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor, PlotState parentState, PlotRenderingInfo info) { // adjust for insets... RectangleInsets insets = getInsets(); insets.trim(plotArea); Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone(); if (info != null) { info.setPlotArea(plotArea); info.setDataArea(plotArea); } drawBackground(g2, plotArea); Shape savedClip = g2.getClip(); g2.clip(plotArea); // adjust the plot area by the interior spacing value double gapPercent = getInteriorGap(); double labelPercent = 0.0; if (getLabelGenerator() != null) { labelPercent = getLabelGap() + getMaximumLabelWidth(); } double gapHorizontal = plotArea.getWidth() * (gapPercent + labelPercent) * 2.0; double gapVertical = plotArea.getHeight() * gapPercent * 2.0; if (DEBUG_DRAW_INTERIOR) { double hGap = plotArea.getWidth() * getInteriorGap(); double vGap = plotArea.getHeight() * getInteriorGap(); double igx1 = plotArea.getX() + hGap; double igx2 = plotArea.getMaxX() - hGap; double igy1 = plotArea.getY() + vGap; double igy2 = plotArea.getMaxY() - vGap; g2.setPaint(Color.lightGray); g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, igy2 - igy1)); } double linkX = plotArea.getX() + gapHorizontal / 2; double linkY = plotArea.getY() + gapVertical / 2; double linkW = plotArea.getWidth() - gapHorizontal; double linkH = plotArea.getHeight() - gapVertical; // make the link area a square if the pie chart is to be circular... if (isCircular()) { // is circular? double min = Math.min(linkW, linkH) / 2; linkX = (linkX + linkX + linkW) / 2 - min; linkY = (linkY + linkY + linkH) / 2 - min; linkW = 2 * min; linkH = 2 * min; } if (info == null) { return;}PiePlotState state = initialise(g2, plotArea, this, null, info); // the link area defines the dog leg points for the linking lines to // the labels Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, linkH * (1 - this.depthFactor)); state.setLinkArea(linkAreaXX); if (DEBUG_DRAW_LINK_AREA) { g2.setPaint(Color.blue); g2.draw(linkAreaXX); g2.setPaint(Color.yellow); g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), linkAreaXX.getWidth(), linkAreaXX.getHeight())); } // the explode area defines the max circle/ellipse for the exploded pie // sections. // it is defined by shrinking the linkArea by the linkMargin factor. double hh = linkW * getLabelLinkMargin(); double vv = linkH * getLabelLinkMargin(); Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, linkY + vv / 2.0, linkW - hh, linkH - vv); state.setExplodedPieArea(explodeArea); // the pie area defines the circle/ellipse for regular pie sections. // it is defined by shrinking the explodeArea by the explodeMargin // factor. double maximumExplodePercent = getMaximumExplodePercent(); double percent = maximumExplodePercent / (1.0 + maximumExplodePercent); double h1 = explodeArea.getWidth() * percent; double v1 = explodeArea.getHeight() * percent; Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() + h1 / 2.0, explodeArea.getY() + v1 / 2.0, explodeArea.getWidth() - h1, explodeArea.getHeight() - v1); // the link area defines the dog-leg point for the linking lines to // the labels int depth = (int) (pieArea.getHeight() * this.depthFactor); Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, linkH - depth); state.setLinkArea(linkArea); state.setPieArea(pieArea); state.setPieCenterX(pieArea.getCenterX()); state.setPieCenterY(pieArea.getCenterY() - depth / 2.0); state.setPieWRadius(pieArea.getWidth() / 2.0); state.setPieHRadius((pieArea.getHeight() - depth) / 2.0); // get the data source - return if null; PieDataset dataset = getDataset(); if (DatasetUtilities.isEmptyOrNull(getDataset())) { drawNoDataMessage(g2, plotArea); g2.setClip(savedClip); drawOutline(g2, plotArea); return; } // if too any elements if (dataset.getKeys().size() > plotArea.getWidth()) { String text = \"Too many elements\"; Font sfont = new Font(\"dialog\", Font.BOLD, 10); g2.setFont(sfont); FontMetrics fm = g2.getFontMetrics(sfont); int stringWidth = fm.stringWidth(text); g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() - stringWidth) / 2), (int) (plotArea.getY() + (plotArea.getHeight() / 2))); return; } // if we are drawing a perfect circle, we need to readjust the top left // coordinates of the drawing area for the arcs to arrive at this // effect. if (isCircular()) { double min = Math.min(plotArea.getWidth(), plotArea.getHeight()) / 2; plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, plotArea.getCenterY() - min, 2 * min, 2 * min); } // get a list of keys... List sectionKeys = dataset.getKeys(); if (sectionKeys.size() == 0) { return; } // establish the coordinates of the top left corner of the drawing area double arcX = pieArea.getX(); double arcY = pieArea.getY(); //g2.clip(clipArea); Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha())); double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset); double runningTotal = 0; if (depth < 0) { return; // if depth is negative don't draw anything } ArrayList arcList = new ArrayList(); Arc2D.Double arc; Paint paint; Paint outlinePaint; Stroke outlineStroke; Iterator iterator = sectionKeys.iterator(); while (iterator.hasNext()) { Comparable currentKey = (Comparable) iterator.next(); Number dataValue = dataset.getValue(currentKey); if (dataValue == null) { arcList.add(null); continue; } double value = dataValue.doubleValue(); if (value <= 0) { arcList.add(null); continue; } double startAngle = getStartAngle(); double direction = getDirection().getFactor(); double angle1 = startAngle + (direction * (runningTotal * 360)) / totalValue; double angle2 = startAngle + (direction * (runningTotal + value) * 360) / totalValue; if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) { arcList.add(new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), pieArea.getHeight() - depth, angle1, angle2 - angle1, Arc2D.PIE)); } else { arcList.add(null); } runningTotal += value; } Shape oldClip = g2.getClip(); Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), pieArea.getWidth(), pieArea.getHeight() - depth); Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() + depth, pieArea.getWidth(), pieArea.getHeight() - depth); Rectangle2D lower = new Rectangle2D.Double(top.getX(), top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() - top.getCenterY()); Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), pieArea.getWidth(), bottom.getCenterY() - top.getY()); Area a = new Area(top); a.add(new Area(lower)); Area b = new Area(bottom); b.add(new Area(upper)); Area pie = new Area(a); pie.intersect(b); Area front = new Area(pie); front.subtract(new Area(top)); Area back = new Area(pie); back.subtract(new Area(bottom)); // draw the bottom circle int[] xs; int[] ys; arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), pieArea.getHeight() - depth, 0, 360, Arc2D.PIE); int categoryCount = arcList.size(); for (int categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) { arc = (Arc2D.Double) arcList.get(categoryIndex); if (arc == null) { continue; } Comparable key = getSectionKey(categoryIndex); paint = lookupSectionPaint(key, true); outlinePaint = lookupSectionOutlinePaint(key); outlineStroke = lookupSectionOutlineStroke(key); g2.setPaint(paint); g2.fill(arc); g2.setPaint(outlinePaint); g2.setStroke(outlineStroke); g2.draw(arc); g2.setPaint(paint); Point2D p1 = arc.getStartPoint(); // draw the height xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(), (int) p1.getX(), (int) p1.getX()}; ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() - depth, (int) p1.getY() - depth, (int) p1.getY()}; Polygon polygon = new Polygon(xs, ys, 4); g2.setPaint(java.awt.Color.lightGray); g2.fill(polygon); g2.setPaint(outlinePaint); g2.setStroke(outlineStroke); g2.draw(polygon); g2.setPaint(paint); } g2.setPaint(Color.gray); g2.fill(back); g2.fill(front); // cycle through once drawing only the sides at the back... int cat = 0; iterator = arcList.iterator(); while (iterator.hasNext()) { Arc2D segment = (Arc2D) iterator.next(); if (segment != null) { Comparable key = getSectionKey(cat); paint = lookupSectionPaint(key, true); outlinePaint = lookupSectionOutlinePaint(key); outlineStroke = lookupSectionOutlineStroke(key); drawSide(g2, pieArea, segment, front, back, paint, outlinePaint, outlineStroke, false, true); } cat++; } // cycle through again drawing only the sides at the front... cat = 0; iterator = arcList.iterator(); while (iterator.hasNext()) { Arc2D segment = (Arc2D) iterator.next(); if (segment != null) { Comparable key = getSectionKey(cat); paint = lookupSectionPaint(key); outlinePaint = lookupSectionOutlinePaint(key); outlineStroke = lookupSectionOutlineStroke(key); drawSide(g2, pieArea, segment, front, back, paint, outlinePaint, outlineStroke, true, false); } cat++; } g2.setClip(oldClip); // draw the sections at the top of the pie (and set up tooltips)... Arc2D upperArc; for (int sectionIndex = 0; sectionIndex < categoryCount; sectionIndex++) { arc = (Arc2D.Double) arcList.get(sectionIndex); if (arc == null) { continue; } upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(), pieArea.getHeight() - depth, arc.getAngleStart(), arc.getAngleExtent(), Arc2D.PIE); Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex); paint = lookupSectionPaint(currentKey, true); outlinePaint = lookupSectionOutlinePaint(currentKey); outlineStroke = lookupSectionOutlineStroke(currentKey); g2.setPaint(paint); g2.fill(upperArc); g2.setStroke(outlineStroke); g2.setPaint(outlinePaint); g2.draw(upperArc); // add a tooltip for the section... if (info != null) { EntityCollection entities = info.getOwner().getEntityCollection(); if (entities != null) { String tip = null; PieToolTipGenerator tipster = getToolTipGenerator(); if (tipster != null) { // @mgs: using the method's return value was missing tip = tipster.generateToolTip(dataset, currentKey); } String url = null; if (getURLGenerator() != null) { url = getURLGenerator().generateURL(dataset, currentKey, getPieIndex()); } PieSectionEntity entity = new PieSectionEntity( upperArc, dataset, getPieIndex(), sectionIndex, currentKey, tip, url); entities.add(entity); } } List keys = dataset.getKeys(); Rectangle2D adjustedPlotArea = new Rectangle2D.Double( originalPlotArea.getX(), originalPlotArea.getY(), originalPlotArea.getWidth(), originalPlotArea.getHeight() - depth); if (getSimpleLabels()) { drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, state); } else { drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, state); } } g2.setClip(savedClip); g2.setComposite(originalComposite); drawOutline(g2, originalPlotArea); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18531935_935.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, DEFAULT_ULPS, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_737040_5566.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width);java.lang.String str = (obj == null) ? getNullText() : obj.toString(); ensureCapacity(size + 5); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_3880373_132_cp111.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol))) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_968841_140_cp84.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null || exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_1421752_10608.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();if (strLen >= width) { buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY]; str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_8844820_1085_cp787.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_79_TBar_Patch_1068439_284_cp125.diff",
    "BugId": "Math_79",
    "PatchedMethods": [
      {
        "DevIntention": "distance",
        "OrgCode": "public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "PatCode": "public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { final double dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_896756_28_cp22.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), rtol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_22560_9.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "PatCode": "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if ((2) != (org.jfree.data.time.TimeSeries.this.data.size())) { if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_TBar_Patch_21180800_2731_cp1175.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (getBaseURLGenerator() != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_Nopol_patch_28112_1.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "draw|item",
        "OrgCode": "public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset data, int row, int column, int pass) { // defensive check if (!(data instanceof StatisticalCategoryDataset)) { throw new IllegalArgumentException( \"Requires StatisticalCategoryDataset.\"); } StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; PlotOrientation orientation = plot.getOrientation(); if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } else if (orientation == PlotOrientation.VERTICAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } }",
        "PatCode": "public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset data, int row, int column, int pass) { // defensive check if (!(data instanceof StatisticalCategoryDataset)) { throw new IllegalArgumentException( \"Requires StatisticalCategoryDataset.\"); } StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; PlotOrientation orientation = plot.getOrientation(); if (row == -1) { if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } else if (orientation == PlotOrientation.VERTICAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_SimFix_patch_1472629_6.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.// start of generated patchif(x==Double.POSITIVE_INFINITY){x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol));f0=computeObjectiveValue(x0);}// end of generated patch/* start of original code if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } end of original code*/ break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_Avatar_Patch_11384545_1573.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (this.baseItemLabelGenerator != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_kPAR_Patch_426619_54_cp36.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(CAPACITY); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_12903424_2445_cp1132.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio <= this.epsilon || (ratio < minRatio)) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_Avatar_Patch_11428230_1575.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (this.baseToolTipGenerator != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_jMutRepair_patch_16000_17.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "lightweight|message|formatter",
        "OrgCode": "private LightweightMessageFormatter() { super(null); this.excerpt = LINE; } public LightweightMessageFormatter(SourceExcerptProvider source) { this(source, LINE); } public LightweightMessageFormatter(SourceExcerptProvider source, SourceExcerpt excerpt) { super(source); Preconditions.checkNotNull(source); this.excerpt = excerpt; } static LightweightMessageFormatter withoutSource() { return new LightweightMessageFormatter(); } public String formatError(JSError error) { return format(error, false); } public String formatWarning(JSError warning) { return format(warning, true); } private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private LightweightMessageFormatter() { super(null); this.excerpt = LINE; } public LightweightMessageFormatter(SourceExcerptProvider source) { this(source, LINE); } public LightweightMessageFormatter(SourceExcerptProvider source, SourceExcerpt excerpt) { super(source); Preconditions.checkNotNull(source); this.excerpt = excerpt; } static LightweightMessageFormatter withoutSource() { return new LightweightMessageFormatter(); } public String formatError(JSError error) { return format(error, false); } public String formatWarning(JSError warning) { return format(warning, true); } private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE)(0 <= charno)) || (charno < sourceExcerpt.length())) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_TBar_Patch_21215131_2734_cp1177.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (getLegendItemToolTipGenerator() != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_81372_6_cp6.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "get|max|middle|index",
        "OrgCode": "public int getMaxMiddleIndex() { return this.maxMiddleIndex; }",
        "PatCode": "public int getMaxMiddleIndex() { return this.maxEndIndex; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252122_2.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if ((this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions()) == 1) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Closure_21_Avatar_Patch_682558_32.diff",
    "BugId": "Closure_21",
    "PatchedMethods": [
      {
        "DevIntention": "visit",
        "OrgCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }",
        "PatCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_43_TBar_Patch_4153384_151_cp79.diff",
    "BugId": "Lang_43",
    "PatchedMethods": [
      {
        "DevIntention": "apply|pattern",
        "OrgCode": "public final void applyPattern(String pattern) { if (registry == null) { super.applyPattern(pattern); toPattern = super.toPattern(); return; } ArrayList foundFormats = new ArrayList(); ArrayList foundDescriptions = new ArrayList(); StringBuffer stripCustom = new StringBuffer(pattern.length()); ParsePosition pos = new ParsePosition(0); char[] c = pattern.toCharArray(); int fmtCount = 0; while (pos.getIndex() < pattern.length()) { switch (c[pos.getIndex()]) { case QUOTE: appendQuotedString(pattern, pos, stripCustom, true); break; case START_FE: fmtCount++; seekNonWs(pattern, pos); int start = pos.getIndex(); int index = readArgumentIndex(pattern, next(pos)); stripCustom.append(START_FE).append(index); seekNonWs(pattern, pos); Format format = null; String formatDescription = null; if (c[pos.getIndex()] == START_FMT) { formatDescription = parseFormatDescription(pattern, next(pos)); format = getFormat(formatDescription); if (format == null) { stripCustom.append(START_FMT).append(formatDescription); } } foundFormats.add(format); foundDescriptions.add(format == null ? null : formatDescription); Validate.isTrue(foundFormats.size() == fmtCount); Validate.isTrue(foundDescriptions.size() == fmtCount); if (c[pos.getIndex()] != END_FE) { throw new IllegalArgumentException( \"Unreadable format element at position \" + start); } // fall through default: stripCustom.append(c[pos.getIndex()]); next(pos); } } super.applyPattern(stripCustom.toString()); toPattern = insertFormats(super.toPattern(), foundDescriptions); if (containsElements(foundFormats)) { Format[] origFormats = getFormats(); // only loop over what we know we have, as MessageFormat on Java 1.3 // seems to provide an extra format element: int i = 0; for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) { Format f = (Format) it.next(); if (f != null) { origFormats[i] = f; } } super.setFormats(origFormats); } }",
        "PatCode": "public final void applyPattern(String pattern) { if (registry == null) { super.applyPattern(pattern); toPattern = super.toPattern(); return; } ArrayList foundFormats = new ArrayList(); ArrayList foundDescriptions = new ArrayList(); StringBuffer stripCustom = new StringBuffer(pattern.length()); ParsePosition pos = new ParsePosition(0); char[] c = pattern.toCharArray(); int fmtCount = 0; while (pos.getIndex() < pattern.length()) { switch (c[pos.getIndex()]) { case QUOTE: appendQuotedString(pattern, pos, stripCustom, false); break; case START_FE: fmtCount++; seekNonWs(pattern, pos); int start = pos.getIndex(); int index = readArgumentIndex(pattern, next(pos)); stripCustom.append(START_FE).append(index); seekNonWs(pattern, pos); Format format = null; String formatDescription = null; if (c[pos.getIndex()] == START_FMT) { formatDescription = parseFormatDescription(pattern, next(pos)); format = getFormat(formatDescription); if (format == null) { stripCustom.append(START_FMT).append(formatDescription); } } foundFormats.add(format); foundDescriptions.add(format == null ? null : formatDescription); Validate.isTrue(foundFormats.size() == fmtCount); Validate.isTrue(foundDescriptions.size() == fmtCount); if (c[pos.getIndex()] != END_FE) { throw new IllegalArgumentException( \"Unreadable format element at position \" + start); } // fall through default: stripCustom.append(c[pos.getIndex()]); next(pos); } } super.applyPattern(stripCustom.toString()); toPattern = insertFormats(super.toPattern(), foundDescriptions); if (containsElements(foundFormats)) { Format[] origFormats = getFormats(); // only loop over what we know we have, as MessageFormat on Java 1.3 // seems to provide an extra format element: int i = 0; for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) { Format f = (Format) it.next(); if (f != null) { origFormats[i] = f; } } super.setFormats(origFormats); } }"
      }
    ]
  },
  {
    "PatchId": "Math_70_SimFix_patch_45841_2.diff",
    "BugId": "Math_70",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); }",
        "PatCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {// start of generated patchreturn solve(f,initial,max);// end of generated patch/* start of original code return solve(min, max); end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_jKali_patch_0_2.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) {if (true)return; com.google.javascript.rhino.Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Avatar_Patch_306792_9.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x1); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_21432971_1069.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "create|tableau",
        "OrgCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }",
        "PatCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((maximize) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_2312647_85_cp64.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.acos(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236218_14.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if ((this.getOriginalNumDecisionVariables() - this.getArtificialVariableOffset()) == 1) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Nopol_patch_319666_3.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { if ((ftol == atol) || (!(atol <= f0))) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_829044_26_cp20.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_1642446_60_cp44.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.copySign(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_8866969_1087_cp789.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxEndIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_TBar_Patch_3779318_448_cp354.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if ((ch == 'y') || !(ch == 'Y')) { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jGenProg_patch_3304000_3404.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { // flip array return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_49_jKali_patch_12000_48.diff",
    "BugId": "Math_49",
    "PatchedMethods": [
      {
        "DevIntention": "set|entry",
        "OrgCode": "public void setEntry(int index, double value) { checkIndex(index); if (!isDefaultValue(value)) { entries.put(index, value); } else if (entries.containsKey(index)) { entries.remove(index); } }",
        "PatCode": "public void setEntry(int index, double value) { checkIndex(index);if (true) { entries.put(index, value); } else if (entries.containsKey(index)) { entries.remove(index); } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Nopol_patch_276314_4.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables if ((org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables) != (2)) { for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jGenProg_patch_696000_1212.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; /** * Compute an interval containing all realEigenvalues of a block. * @param index index of the first row of the block * @param n number of rows of the block * @return an interval containing the realEigenvalues */ // find the bounds of the spectra of the local block // set thresholds // search lower eigenvalue // search has converged // search upper eigenvalue // search has converged /** * Count the number of realEigenvalues below a point. * @param t value below which we must count the number of realEigenvalues * @param index index of the first row of the block * @param n number of rows of the block * @return number of realEigenvalues smaller than t */ /** * Decompose the shifted tridiagonal matrix T-&lambda;I as LDL<sup>T</sup>. * <p>A shifted symmetric tridiagonal matrix T can be decomposed as * LDL<sup>T</sup> where L is a lower bidiagonal matrix with unit diagonal * and D is a diagonal matrix. This method is an implementation of * algorithm 4.4.7 from Dhillon's thesis.</p> * @param lambda shift to add to the matrix before decomposing it * to ensure it is positive definite * @param index index of the first row of the block * @param n number of rows of the block */ /** * Perform a dqds step, using current shift increment. * <p>This implementation is a translation of the LAPACK routine DLASQ5.</p> * @param start start index * @param end end index */ // unroll last two steps. /** * Perform a dqd step. * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p> * @param start start index * @param end end index */eMin = 0.0; work[j - k] = tmp;} j -= 4;} return true;} return false;} private double[] eigenvaluesRange(final int index, final int n) { final int lowerStart = 4 * main.length; final int upperStart = 5 * main.length; double lower = java.lang.Double.POSITIVE_INFINITY; double upper = java.lang.Double.NEGATIVE_INFINITY; for (int i = 0; i < n; ++i) { lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); final double absoluteTolerance = 4 * minPivot; final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); double left = lower - margin; double right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= 1) { right = middle;} else { left = middle;}} lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); left = lower - margin; right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= n) { right = middle;} else { left = middle;}} upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); return new double[]{ lower, upper };} private int countEigenValues(final double t, final int index, final int n) { double ratio = main[index] - t; int count = (ratio > 0) ? 0 : 1; for (int i = 1; i < n; ++i) { ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; if (ratio <= 0) { ++count;}} return count;} private void ldlTDecomposition(final double lambda, final int index, final int n) { double di = main[index] - lambda; work[0] = java.lang.Math.abs(di); for (int i = 1; i < n; ++i) { final int fourI = 4 * i; final double eiM1 = secondary[(index + i) - 1]; final double ratio = eiM1 / di; work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); di = (main[index + i] - lambda) - (eiM1 * ratio); work[fourI] = java.lang.Math.abs(di);}} private void dqds(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong] - tau; dMin = d; dMin1 = -work[(4 * start) + pingPong]; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; final double tmp = work[j4 + 1] / work[j4 - 2]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4] = work[j4 - 1] * tmp; eMin = java.lang.Math.min(work[j4], eMin);}} else { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 3] = d + work[j4]; final double tmp = work[j4 + 2] / work[j4 - 3]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4 - 1] = work[j4] * tmp; eMin = java.lang.Math.min(work[j4 - 1], eMin);}} dN2 = d; dMin2 = dMin; int j4 = ((4 * (end - 2)) - pingPong) - 1; int j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN2 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN1); dMin1 = dMin; j4 = j4 + 4; j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN1 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN); work[j4 + 2] = dN; work[((4 * end) - pingPong) - 1] = eMin;} private void dqd(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong]; dMin = d; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; d = work[j4 + 1]; dMin = d; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) { final double tmp = work[j4 + 1] / work[j4 - 2]; work[j4] = work[j4 - 1] * tmp; d *= tmp; } else { work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); d *= work[j4 + 1] / work[j4 - 2]; } dMin = Math.min(dMin, d); eMin = Math.min(eMin, work[j4]); } } else { for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) { work[j4 - 3] = d + work[j4]; if (work[j4 - 3] == 0.0) { work[j4 - 1] = 0.0; d = work[j4 + 2]; dMin = d; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) && (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) { final double tmp = work[j4 + 2] / work[j4 - 3]; work[j4 - 1] = work[j4] * tmp; d *= tmp; } else { work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); d *= work[j4 + 2] / work[j4 - 3]; } dMin = Math.min(dMin, d); eMin = Math.min(eMin, work[j4 - 1]); } } // Unroll last two steps dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; dN1 = work[j4p2 + 2]; dMin = dN1; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]); } dMin = Math.min(dMin, dN1); dMin1 = dMin; j4 = j4 + 4; j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN1 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; dN = work[j4p2 + 2]; dMin = dN; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN = dN1 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]); } dMin = Math.min(dMin, dN); work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin; }"
      },
      {
        "DevIntention": "eigenvalues|range",
        "OrgCode": "private double[] eigenvaluesRange(final int index, final int n) { // find the bounds of the spectra of the local block final int lowerStart = 4 * main.length; final int upperStart = 5 * main.length; double lower = Double.POSITIVE_INFINITY; double upper = Double.NEGATIVE_INFINITY; for (int i = 0; i < n; ++i) { lower = Math.min(lower, work[lowerStart + index +i]); upper = Math.max(upper, work[upperStart + index +i]); } // set thresholds final double tNorm = Math.max(Math.abs(lower), Math.abs(upper)); final double relativeTolerance = Math.sqrt(MathUtils.EPSILON); final double absoluteTolerance = 4 * minPivot; final int maxIter = 2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0)); final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot); // search lower eigenvalue double left = lower - margin; double right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) { // search has converged break; } final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= 1) { right = middle; } else { left = middle; } } lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left)); // search upper eigenvalue left = lower - margin; right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) { // search has converged break; } final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= n) { right = middle; } else { left = middle; } } upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right)); return new double[] { lower, upper }; }",
        "PatCode": "eMin = 0.0; work[j - k] = tmp;} j -= 4;} return true;} return false;} private double[] eigenvaluesRange(final int index, final int n) { final int lowerStart = 4 * main.length; final int upperStart = 5 * main.length; double lower = java.lang.Double.POSITIVE_INFINITY; double upper = java.lang.Double.NEGATIVE_INFINITY; for (int i = 0; i < n; ++i) { lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); final double absoluteTolerance = 4 * minPivot; final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); double left = lower - margin; double right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= 1) { right = middle;} else { left = middle;}} lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); left = lower - margin; right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= n) { right = middle;} else { left = middle;}} upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); return new double[]{ lower, upper };} private int countEigenValues(final double t, final int index, final int n) { double ratio = main[index] - t; int count = (ratio > 0) ? 0 : 1; for (int i = 1; i < n; ++i) { ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; if (ratio <= 0) { ++count;}} return count;} private void ldlTDecomposition(final double lambda, final int index, final int n) { double di = main[index] - lambda; work[0] = java.lang.Math.abs(di); for (int i = 1; i < n; ++i) { final int fourI = 4 * i; final double eiM1 = secondary[(index + i) - 1]; final double ratio = eiM1 / di; work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); di = (main[index + i] - lambda) - (eiM1 * ratio); work[fourI] = java.lang.Math.abs(di);}} private void dqds(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong] - tau; dMin = d; dMin1 = -work[(4 * start) + pingPong]; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; final double tmp = work[j4 + 1] / work[j4 - 2]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4] = work[j4 - 1] * tmp; eMin = java.lang.Math.min(work[j4], eMin);}} else { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 3] = d + work[j4]; final double tmp = work[j4 + 2] / work[j4 - 3]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4 - 1] = work[j4] * tmp; eMin = java.lang.Math.min(work[j4 - 1], eMin);}} dN2 = d; dMin2 = dMin; int j4 = ((4 * (end - 2)) - pingPong) - 1; int j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN2 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN1); dMin1 = dMin; j4 = j4 + 4; j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN1 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN); work[j4 + 2] = dN; work[((4 * end) - pingPong) - 1] = eMin;} private void dqd(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong]; dMin = d; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; d = work[j4 + 1]; dMin = d; eMin = 0.0;"
      },
      {
        "DevIntention": "count|eigen|values",
        "OrgCode": "private int countEigenValues(final double t, final int index, final int n) { double ratio = main[index] - t; int count = (ratio > 0) ? 0 : 1; for (int i = 1; i < n; ++i) { ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t; if (ratio <= 0) { ++count; } } return count; }",
        "PatCode": "eMin = 0.0; work[j - k] = tmp;} j -= 4;} return true;} return false;} private double[] eigenvaluesRange(final int index, final int n) { final int lowerStart = 4 * main.length; final int upperStart = 5 * main.length; double lower = java.lang.Double.POSITIVE_INFINITY; double upper = java.lang.Double.NEGATIVE_INFINITY; for (int i = 0; i < n; ++i) { lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); final double absoluteTolerance = 4 * minPivot; final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); double left = lower - margin; double right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= 1) { right = middle;} else { left = middle;}} lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); left = lower - margin; right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= n) { right = middle;} else { left = middle;}} upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); return new double[]{ lower, upper };} private int countEigenValues(final double t, final int index, final int n) { double ratio = main[index] - t; int count = (ratio > 0) ? 0 : 1; for (int i = 1; i < n; ++i) { ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; if (ratio <= 0) { ++count;}} return count;} private void ldlTDecomposition(final double lambda, final int index, final int n) { double di = main[index] - lambda; work[0] = java.lang.Math.abs(di); for (int i = 1; i < n; ++i) { final int fourI = 4 * i; final double eiM1 = secondary[(index + i) - 1]; final double ratio = eiM1 / di; work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); di = (main[index + i] - lambda) - (eiM1 * ratio); work[fourI] = java.lang.Math.abs(di);}} private void dqds(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong] - tau; dMin = d; dMin1 = -work[(4 * start) + pingPong]; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; final double tmp = work[j4 + 1] / work[j4 - 2]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4] = work[j4 - 1] * tmp; eMin = java.lang.Math.min(work[j4], eMin);}} else { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 3] = d + work[j4]; final double tmp = work[j4 + 2] / work[j4 - 3]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4 - 1] = work[j4] * tmp; eMin = java.lang.Math.min(work[j4 - 1], eMin);}} dN2 = d; dMin2 = dMin; int j4 = ((4 * (end - 2)) - pingPong) - 1; int j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN2 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN1); dMin1 = dMin; j4 = j4 + 4; j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN1 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN); work[j4 + 2] = dN; work[((4 * end) - pingPong) - 1] = eMin;} private void dqd(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong]; dMin = d; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; d = work[j4 + 1]; dMin = d; eMin = 0.0;"
      },
      {
        "DevIntention": "ldl|t|decomposition",
        "OrgCode": "private void ldlTDecomposition(final double lambda, final int index, final int n) { double di = main[index] - lambda; work[0] = Math.abs(di); for (int i = 1; i < n; ++i) { final int fourI = 4 * i; final double eiM1 = secondary[index + i - 1]; final double ratio = eiM1 / di; work[fourI - 2] = ratio * ratio * Math.abs(di); di = (main[index + i] - lambda) - eiM1 * ratio; work[fourI] = Math.abs(di); } }",
        "PatCode": "eMin = 0.0; work[j - k] = tmp;} j -= 4;} return true;} return false;} private double[] eigenvaluesRange(final int index, final int n) { final int lowerStart = 4 * main.length; final int upperStart = 5 * main.length; double lower = java.lang.Double.POSITIVE_INFINITY; double upper = java.lang.Double.NEGATIVE_INFINITY; for (int i = 0; i < n; ++i) { lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); final double absoluteTolerance = 4 * minPivot; final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); double left = lower - margin; double right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= 1) { right = middle;} else { left = middle;}} lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); left = lower - margin; right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= n) { right = middle;} else { left = middle;}} upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); return new double[]{ lower, upper };} private int countEigenValues(final double t, final int index, final int n) { double ratio = main[index] - t; int count = (ratio > 0) ? 0 : 1; for (int i = 1; i < n; ++i) { ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; if (ratio <= 0) { ++count;}} return count;} private void ldlTDecomposition(final double lambda, final int index, final int n) { double di = main[index] - lambda; work[0] = java.lang.Math.abs(di); for (int i = 1; i < n; ++i) { final int fourI = 4 * i; final double eiM1 = secondary[(index + i) - 1]; final double ratio = eiM1 / di; work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); di = (main[index + i] - lambda) - (eiM1 * ratio); work[fourI] = java.lang.Math.abs(di);}} private void dqds(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong] - tau; dMin = d; dMin1 = -work[(4 * start) + pingPong]; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; final double tmp = work[j4 + 1] / work[j4 - 2]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4] = work[j4 - 1] * tmp; eMin = java.lang.Math.min(work[j4], eMin);}} else { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 3] = d + work[j4]; final double tmp = work[j4 + 2] / work[j4 - 3]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4 - 1] = work[j4] * tmp; eMin = java.lang.Math.min(work[j4 - 1], eMin);}} dN2 = d; dMin2 = dMin; int j4 = ((4 * (end - 2)) - pingPong) - 1; int j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN2 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN1); dMin1 = dMin; j4 = j4 + 4; j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN1 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN); work[j4 + 2] = dN; work[((4 * end) - pingPong) - 1] = eMin;} private void dqd(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong]; dMin = d; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; d = work[j4 + 1]; dMin = d; eMin = 0.0;"
      },
      {
        "DevIntention": "dqds",
        "OrgCode": "private void dqds(final int start, final int end) { eMin = work[4 * start + pingPong + 4]; double d = work[4 * start + pingPong] - tau; dMin = d; dMin1 = -work[4 * start + pingPong]; if (pingPong == 0) { for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; final double tmp = work[j4 + 1] / work[j4 - 2]; d = d * tmp - tau; dMin = Math.min(dMin, d); work[j4] = work[j4 - 1] * tmp; eMin = Math.min(work[j4], eMin); } } else { for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) { work[j4 - 3] = d + work[j4]; final double tmp = work[j4 + 2] / work[j4 - 3]; d = d * tmp - tau; dMin = Math.min(dMin, d); work[j4 - 1] = work[j4] * tmp; eMin = Math.min(work[j4 - 1], eMin); } } // unroll last two steps. dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau; dMin = Math.min(dMin, dN1); dMin1 = dMin; j4 = j4 + 4; j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN1 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau; dMin = Math.min(dMin, dN); work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin; }",
        "PatCode": "eMin = 0.0; work[j - k] = tmp;} j -= 4;} return true;} return false;} private double[] eigenvaluesRange(final int index, final int n) { final int lowerStart = 4 * main.length; final int upperStart = 5 * main.length; double lower = java.lang.Double.POSITIVE_INFINITY; double upper = java.lang.Double.NEGATIVE_INFINITY; for (int i = 0; i < n; ++i) { lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); final double absoluteTolerance = 4 * minPivot; final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); double left = lower - margin; double right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= 1) { right = middle;} else { left = middle;}} lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); left = lower - margin; right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= n) { right = middle;} else { left = middle;}} upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); return new double[]{ lower, upper };} private int countEigenValues(final double t, final int index, final int n) { double ratio = main[index] - t; int count = (ratio > 0) ? 0 : 1; for (int i = 1; i < n; ++i) { ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; if (ratio <= 0) { ++count;}} return count;} private void ldlTDecomposition(final double lambda, final int index, final int n) { double di = main[index] - lambda; work[0] = java.lang.Math.abs(di); for (int i = 1; i < n; ++i) { final int fourI = 4 * i; final double eiM1 = secondary[(index + i) - 1]; final double ratio = eiM1 / di; work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); di = (main[index + i] - lambda) - (eiM1 * ratio); work[fourI] = java.lang.Math.abs(di);}} private void dqds(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong] - tau; dMin = d; dMin1 = -work[(4 * start) + pingPong]; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; final double tmp = work[j4 + 1] / work[j4 - 2]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4] = work[j4 - 1] * tmp; eMin = java.lang.Math.min(work[j4], eMin);}} else { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 3] = d + work[j4]; final double tmp = work[j4 + 2] / work[j4 - 3]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4 - 1] = work[j4] * tmp; eMin = java.lang.Math.min(work[j4 - 1], eMin);}} dN2 = d; dMin2 = dMin; int j4 = ((4 * (end - 2)) - pingPong) - 1; int j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN2 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN1); dMin1 = dMin; j4 = j4 + 4; j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN1 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN); work[j4 + 2] = dN; work[((4 * end) - pingPong) - 1] = eMin;} private void dqd(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong]; dMin = d; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; d = work[j4 + 1]; dMin = d; eMin = 0.0;"
      },
      {
        "DevIntention": "dqd",
        "OrgCode": "private void dqd(final int start, final int end) { eMin = work[4 * start + pingPong + 4]; double d = work[4 * start + pingPong]; dMin = d; if (pingPong == 0) { for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; d = work[j4 + 1]; dMin = d; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) { final double tmp = work[j4 + 1] / work[j4 - 2]; work[j4] = work[j4 - 1] * tmp; d *= tmp; } else { work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]); d *= work[j4 + 1] / work[j4 - 2]; } dMin = Math.min(dMin, d); eMin = Math.min(eMin, work[j4]); } } else { for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) { work[j4 - 3] = d + work[j4]; if (work[j4 - 3] == 0.0) { work[j4 - 1] = 0.0; d = work[j4 + 2]; dMin = d; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) && (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) { final double tmp = work[j4 + 2] / work[j4 - 3]; work[j4 - 1] = work[j4] * tmp; d *= tmp; } else { work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]); d *= work[j4 + 2] / work[j4 - 3]; } dMin = Math.min(dMin, d); eMin = Math.min(eMin, work[j4 - 1]); } } // Unroll last two steps dN2 = d; dMin2 = dMin; int j4 = 4 * (end - 2) - pingPong - 1; int j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN2 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; dN1 = work[j4p2 + 2]; dMin = dN1; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN1 = dN2 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]); } dMin = Math.min(dMin, dN1); dMin1 = dMin; j4 = j4 + 4; j4p2 = j4 + 2 * pingPong - 1; work[j4 - 2] = dN1 + work[j4p2]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; dN = work[j4p2 + 2]; dMin = dN; eMin = 0.0; } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) && (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) { final double tmp = work[j4p2 + 2] / work[j4 - 2]; work[j4] = work[j4p2] * tmp; dN = dN1 * tmp; } else { work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]); } dMin = Math.min(dMin, dN); work[j4 + 2] = dN; work[4 * end - pingPong - 1] = eMin; }",
        "PatCode": "eMin = 0.0; work[j - k] = tmp;} j -= 4;} return true;} return false;} private double[] eigenvaluesRange(final int index, final int n) { final int lowerStart = 4 * main.length; final int upperStart = 5 * main.length; double lower = java.lang.Double.POSITIVE_INFINITY; double upper = java.lang.Double.NEGATIVE_INFINITY; for (int i = 0; i < n; ++i) { lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); final double absoluteTolerance = 4 * minPivot; final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); double left = lower - margin; double right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= 1) { right = middle;} else { left = middle;}} lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); left = lower - margin; right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { break;} final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= n) { right = middle;} else { left = middle;}} upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); return new double[]{ lower, upper };} private int countEigenValues(final double t, final int index, final int n) { double ratio = main[index] - t; int count = (ratio > 0) ? 0 : 1; for (int i = 1; i < n; ++i) { ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; if (ratio <= 0) { ++count;}} return count;} private void ldlTDecomposition(final double lambda, final int index, final int n) { double di = main[index] - lambda; work[0] = java.lang.Math.abs(di); for (int i = 1; i < n; ++i) { final int fourI = 4 * i; final double eiM1 = secondary[(index + i) - 1]; final double ratio = eiM1 / di; work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); di = (main[index + i] - lambda) - (eiM1 * ratio); work[fourI] = java.lang.Math.abs(di);}} private void dqds(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong] - tau; dMin = d; dMin1 = -work[(4 * start) + pingPong]; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; final double tmp = work[j4 + 1] / work[j4 - 2]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4] = work[j4 - 1] * tmp; eMin = java.lang.Math.min(work[j4], eMin);}} else { for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { work[j4 - 3] = d + work[j4]; final double tmp = work[j4 + 2] / work[j4 - 3]; d = (d * tmp) - tau; dMin = java.lang.Math.min(dMin, d); work[j4 - 1] = work[j4] * tmp; eMin = java.lang.Math.min(work[j4 - 1], eMin);}} dN2 = d; dMin2 = dMin; int j4 = ((4 * (end - 2)) - pingPong) - 1; int j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN2 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN1); dMin1 = dMin; j4 = j4 + 4; j4p2 = (j4 + (2 * pingPong)) - 1; work[j4 - 2] = dN1 + work[j4p2]; work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; dMin = java.lang.Math.min(dMin, dN); work[j4 + 2] = dN; work[((4 * end) - pingPong) - 1] = eMin;} private void dqd(final int start, final int end) { eMin = work[((4 * start) + pingPong) + 4]; double d = work[(4 * start) + pingPong]; dMin = d; if (pingPong == 0) { for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { work[j4 - 2] = d + work[j4 - 1]; if (work[j4 - 2] == 0.0) { work[j4] = 0.0; d = work[j4 + 1]; dMin = d; eMin = 0.0;"
      }
    ]
  },
  {
    "PatchId": "Chart_7_jGenProg_patch_4862000_47592.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { .getTime();"
      },
      {
        "DevIntention": "recalculate|bounds",
        "OrgCode": "private void recalculateBounds() { this.minStartIndex = -1; this.minMiddleIndex = -1; this.minEndIndex = -1; this.maxStartIndex = -1; this.maxMiddleIndex = -1; this.maxEndIndex = -1; for (int i = 0; i < this.data.size(); i++) { TimePeriodValue tpv = (TimePeriodValue) this.data.get(i); updateBounds(tpv.getPeriod(), i); } }",
        "PatCode": "if (index >= 0) {this.data.remove(index);fireSeriesChanged();} this.minEndIndex = index;}} else { this.minEndIndex = index;} if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd().getTime(); if (end > maxEnd) { this.maxEndIndex = index;}} else { this.maxEndIndex = index;}} private void recalculateBounds() { this.minStartIndex = -1; this.minMiddleIndex = -1; this.minEndIndex = -1; this.maxStartIndex = -1; this.maxMiddleIndex = -1; this.maxEndIndex = -1; for (int i = 0; i < this.data.size(); i++) { org.jfree.data.time.TimePeriodValue tpv = ((org.jfree.data.time.TimePeriodValue) (this.data.get(i))); updateBounds(tpv.getPeriod(), i);}} public void add(org.jfree.data.time.TimePeriod period, double value) { org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); add(item);} public void add(org.jfree.data.time.TimePeriod period, java.lang.Number value) { org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); add(item);} public void update(int index, java.lang.Number value) { org.jfree.data.time.TimePeriodValue item = getDataItem(index); item.setValue(value); fireSeriesChanged();} public void delete(int start, int end) { for (int i = 0; i <= (end - start); i++) { this.data.remove(start);} recalculateBounds(); fireSeriesChanged();} public boolean equals(java.lang.Object obj) { if (obj == this) { return true;} if (!(obj instanceof org.jfree.data.time.TimePeriodValues)) { return false;} if (!super.equals(obj)) { return false;} org.jfree.data.time.TimePeriodValues that = ((org.jfree.data.time.TimePeriodValues) (obj)); if (!org.jfree.chart.util.ObjectUtilities.equal(this.getDomainDescription(), that.getDomainDescription())) { return false;} if (!org.jfree.chart.util.ObjectUtilities.equal(this.getRangeDescription(), that.getRangeDescription())) { return false;} int count = getItemCount(); if (count != that.getItemCount()) { return false;} for (int i = 0; i < count; i++) { if (!getDataItem(i).equals(that.getDataItem(i))) { return false;}} return true;} public int hashCode() { int result; result = (this.domain != null) ? this.domain.hashCode() : 0; result = (29 * result) + (this.range != null ? this.range.hashCode() : 0); result = (29 * result) + this.data.hashCode(); result = (29 * result) + this.minStartIndex; result = (29 * result) + this.maxStartIndex; result = (29 * result) + this.minMiddleIndex; result = (29 * result) + this.maxMiddleIndex; result = (29 * result) + this.minEndIndex; result = (29 * result) + this.maxEndIndex; return result;} public java.lang.Object clone() throws java.lang.CloneNotSupportedException { java.lang.Object clone = createCopy(0, getItemCount() - 1); return clone;} public org.jfree.data.time.TimePeriodValues createCopy(int start, int end) throws java.lang.CloneNotSupportedException { org.jfree.data.time.TimePeriodValues copy = ((org.jfree.data.time.TimePeriodValues) (super.clone())); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { org.jfree.data.time.TimePeriodValue item = ((org.jfree.data.time.TimePeriodValue) (this.data.get(index))); org.jfree.data.time.TimePeriodValue clone = ((org.jfree.data.time.TimePeriodValue) (item.clone())); try { copy.add(clone);} catch (org.jfree.data.general.SeriesException e) { java.lang.System.err.println(\"Failed to add cloned item.\");}}} return copy;} public int getMinStartIndex() { return this.minStartIndex;} public int getMaxStartIndex() { return this.maxStartIndex;} public int getMinMiddleIndex() { return this.minMiddleIndex;} public int getMaxMiddleIndex() { return this.maxMiddleIndex;} public int getMinEndIndex() { return this.minEndIndex;} public int getMaxEndIndex() { return this.maxEndIndex;}}}"
      }
    ]
  },
  {
    "PatchId": "Math_50_jGenProg_patch_4821000_1444.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.if (x == x1) { this.allowed = org.apache.commons.math.analysis.solvers.AllowedSolution.ANY_SIDE; f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Nopol_patch_4357682_4.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { if ((x < 1) || (rtol == atol)) { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9956436_1066_cp826.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb >= initial && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_79_TBar_Patch_1076374_285_cp126.diff",
    "BugId": "Math_79",
    "PatchedMethods": [
      {
        "DevIntention": "distance",
        "OrgCode": "public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "PatCode": "public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { final float dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9254652_980_cp740.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa > b && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_28_FixMiner_Patch_14495712_174.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row != tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9554020_1018_cp778.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa >= lowerBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_Avatar_Patch_656254_136.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_97068_8.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { if ((this != null) && (param[0] <= 0)) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jGenProg_patch_962000_1672.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9803410_1048_cp808.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb < a && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_Avatar_Patch_665945_137.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null || exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jGenProg_patch_5551000_12664.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "assert|valid|resolve",
        "OrgCode": "public static JSType assertValidResolve( JSType type, StaticScope<JSType> scope) { ErrorReporter t = TestErrorReporter.forNoExpectedReports(); JSType resolvedType = type.resolve(t, scope); assertTypeEquals(\"JSType#resolve should not affect object equality\", type, resolvedType); Assert.assertEquals(\"JSType#resolve should not affect hash codes\", type.hashCode(), resolvedType.hashCode()); return resolvedType; } public static void assertTypeNotEquals(JSType a, JSType b) { assertTypeNotEquals(\"\", a, b); } public static void assertTypeNotEquals(String message, JSType a, JSType b) { Assert.assertFalse( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Type: \" + b + \"\\n\", a.isEquivalentTo(b)); Assert.assertFalse( message + \" Equals is not symmetric.\\n\" + \"Type: \" + b + \"\\n\", b.isEquivalentTo(a)); } public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); } public static void assertTypeEquals(String message, JSType a, JSType b) { Assert.assertTrue( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Expected: \" + a + \"\\n\" + \"Actual : \" + b, a.isEquivalentTo(b)); Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }",
        "PatCode": "public static JSType assertValidResolve( JSType type, StaticScope<JSType> scope) { ErrorReporter t = TestErrorReporter.forNoExpectedReports(); JSType resolvedType = type.resolve(t, scope); assertTypeEquals(\"JSType#resolve should not affect object equality\", type, resolvedType); Assert.assertEquals(\"JSType#resolve should not affect hash codes\", type.hashCode(), resolvedType.hashCode()); return resolvedType; } public static void assertTypeNotEquals(JSType a, JSType b) { assertTypeNotEquals(\"\", a, b); } public static void assertTypeNotEquals(String message, JSType a, JSType b) { Assert.assertFalse( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Type: \" + b + \"\\n\", a.isEquivalentTo(b)); Assert.assertFalse( message + \" Equals is not symmetric.\\n\" + \"Type: \" + b + \"\\n\", b.isEquivalentTo(a)); } public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); }com.google.javascript.rhino.testing.Asserts.assertTypeEquals(\"\", a, b); public static void assertTypeEquals(String message, JSType a, JSType b) { Assert.assertTrue( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Expected: \" + a + \"\\n\" + \"Actual : \" + b, a.isEquivalentTo(b)); Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18314585_930.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, this.numSlackVariables, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_Avatar_Patch_90948_20.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "draw|item",
        "OrgCode": "public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset data, int row, int column, int pass) { // defensive check if (!(data instanceof StatisticalCategoryDataset)) { throw new IllegalArgumentException( \"Requires StatisticalCategoryDataset.\"); } StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; PlotOrientation orientation = plot.getOrientation(); if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } else if (orientation == PlotOrientation.VERTICAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } }",
        "PatCode": "public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset data, int row, int column, int pass) { // defensive check if (!(data instanceof StatisticalCategoryDataset)) { throw new IllegalArgumentException( \"Requires StatisticalCategoryDataset.\"); } StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; PlotOrientation orientation = plot.getOrientation(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_jGenProg_patch_108000_464.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1165102_264_cp111.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec != numeric || (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_30_TBar_Patch_2194123_123_cp59.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1d) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_TBar_Patch_431204_20_cp14.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(doSolve()); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_955726_135_cp83.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((expPos < str.length() - 1)) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_1087584_83_cp16.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "optimize",
        "OrgCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }",
        "PatCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics if (this.function != null) {this.function = f;} this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_418558_8_cp8.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x1); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_20636170_1028.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize|constraints",
        "OrgCode": "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) { List<LinearConstraint> normalized = new ArrayList<LinearConstraint>(); for (LinearConstraint constraint : originalConstraints) { normalized.add(normalize(constraint)); } return normalized; }",
        "PatCode": "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) { List<LinearConstraint> normalized = new ArrayList<LinearConstraint>(); for (LinearConstraint constraint : originalConstraints) { if (normalized == null) { return null;}normalized.add(normalize(constraint)); } return normalized; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Nopol_patch_260042_1.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { if ((org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables) != (2)) { columnsToDrop.add(i); } } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2507884_304_cp224.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str.startsWith(\"--\"))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_38176_2_cp2.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "get|max|middle|index",
        "OrgCode": "public int getMaxMiddleIndex() { return this.maxMiddleIndex; }",
        "PatCode": "public int getMaxMiddleIndex() { return this.maxStartIndex; }"
      }
    ]
  },
  {
    "PatchId": "Math_62_kPAR_Patch_1281822_146_cp63.diff",
    "BugId": "Math_62",
    "PatchedMethods": [
      {
        "DevIntention": "optimize",
        "OrgCode": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException { optima = new UnivariateRealPointValuePair[starts]; totalEvaluations = 0; // Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { optima[i] = null; } final int usedEvaluations = optimizer.getEvaluations(); optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations); totalEvaluations += usedEvaluations; } sortPairs(goal); if (optima[0] == null) { throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts); } // Return the point with the best objective function value. return optima[0]; }",
        "PatCode": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException { optima = new UnivariateRealPointValuePair[starts]; totalEvaluations = 0; // Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { optima[i] = null; } final int usedEvaluations = optimizer.getEvaluations(); optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations); totalEvaluations += usedEvaluations; } sortPairs(goal); if (optima[0] == null) { throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts); } // Return the point with the best objective function value. return optima[0]; }"
      }
    ]
  },
  {
    "PatchId": "Math_63_TBar_Patch_434086_162_cp28.diff",
    "BugId": "Math_63",
    "PatchedMethods": [
      {
        "DevIntention": "equals",
        "OrgCode": "public static boolean equals(double[] x, double[] y) { if ((x == null) || (y == null)) { return !((x == null) ^ (y == null)); } if (x.length != y.length) { return false; } for (int i = 0; i < x.length; ++i) { if (!equals(x[i], y[i])) { return false; } } return true; }",
        "PatCode": "public static boolean equals(double[] x, double[] y) { if ((x == null) || (y == null)) { return !((x == null) ^ (y == null)); } if (x.length != y.length) { return false; } for (int i = 0; i < x.length; ++i) { if (!equals(x[i], y[i], i)) { return false; } } return true; }"
      }
    ]
  },
  {
    "PatchId": "Math_81_Nopol_patch_19439_1.diff",
    "BugId": "Math_81",
    "PatchedMethods": [
      {
        "DevIntention": "compute|shift|increment",
        "OrgCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }",
        "PatCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (org.apache.commons.math.linear.EigenDecompositionImpl.this.main!=null) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Nopol_patch_317995_2.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x1 == f1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_81_jGenProg_patch_5713000_3442.diff",
    "BugId": "Math_81",
    "PatchedMethods": [
      {
        "DevIntention": "compute|shift|increment",
        "OrgCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }",
        "PatCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_21608229_1073.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "create|tableau",
        "OrgCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }",
        "PatCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (!restrictToNonNegative)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_568058_71_cp4.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "optimize",
        "OrgCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }",
        "PatCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; if (this.goal != null) {this.goal = goalType;} this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }"
      }
    ]
  },
  {
    "PatchId": "Math_8_TBar_Patch_442274_12_cp5.diff",
    "BugId": "Math_8",
    "PatchedMethods": [
      {
        "DevIntention": "sample",
        "OrgCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i < sampleSize; i++) { out[i] = sample(); } return out; }",
        "PatCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i < sampleSize; i++) { } return out; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_1089407_8148.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width);java.lang.String str = (obj == null) ? getNullText() : obj.toString(); buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY]; int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Closure_2_TBar_Patch_4235403_111_cp54.diff",
    "BugId": "Closure_2",
    "PatchedMethods": [
      {
        "DevIntention": "check|interface|conflict|properties",
        "OrgCode": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { if (!interfaceType.getPropertyType(name).isEquivalentTo( oType.getPropertyType(name))) { compiler.report( t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString())); } } currentProperties.put(name, interfaceType); } for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); } }",
        "PatCode": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). if (implicitProto == null) { return;}currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { if (!interfaceType.getPropertyType(name).isEquivalentTo( oType.getPropertyType(name))) { compiler.report( t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString())); } } currentProperties.put(name, interfaceType); } for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); } }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_kPAR_Patch_5369519_847_cp295.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if ((dataset != null) && !(plot.getRowRenderingOrder().equals(SortOrder.ASCENDING))) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17569856_905.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "get|constraints",
        "OrgCode": "protected Collection<LinearConstraint> getConstraints() { return Collections.unmodifiableCollection(linearConstraints); }",
        "PatCode": "protected Collection<LinearConstraint> getConstraints() { if (linearConstraints == null) { throw new IllegalArgumentException(\"Null 'linearConstraints' argument.\");}return Collections.unmodifiableCollection(linearConstraints); }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_34000_156.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {if (width > 0) { ensureCapacity(size + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_20139818_986.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint == null) { throw new IllegalArgumentException(\"Null 'constraint' argument.\");}if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_Avatar_Patch_11606570_1586.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Chart_17_Nopol_patch_16724_1.diff",
    "BugId": "Chart_17",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "PatCode": "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { throw new IllegalArgumentException(\"Requires start <= end.\"); } } TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_Avatar_Patch_2363590_455.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "get|mean|value",
        "OrgCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { result = masd.getMean(); } return result; }",
        "PatCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(this.minimumRangeValue, column); if (masd != null) { result = masd.getMean(); } return result; }"
      }
    ]
  },
  {
    "PatchId": "Time_7_Nopol_patch_153904_2.diff",
    "BugId": "Time_7",
    "PatchedMethods": [
      {
        "DevIntention": "compute|millis",
        "OrgCode": "public long computeMillis(boolean resetFields, String text) { SavedField[] savedFields = iSavedFields; int count = iSavedFieldsCount; if (iSavedFieldsShared) { iSavedFields = savedFields = (SavedField[])iSavedFields.clone(); iSavedFieldsShared = false; } sort(savedFields, count); if (count > 0) { // alter base year for parsing if first field is month or day DurationField months = DurationFieldType.months().getField(iChrono); DurationField days = DurationFieldType.days().getField(iChrono); DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); return computeMillis(resetFields, text); } } long millis = iMillis; try { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e; } if (iOffset != null) { millis -= iOffset; } else if (iZone != null) { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')'; if (text != null) { message = \"Cannot parse \\\"\" + text + \"\\\": \" + message; } throw new IllegalInstantException(message); } } return millis; }",
        "PatCode": "public long computeMillis(boolean resetFields, String text) { SavedField[] savedFields = iSavedFields; int count = iSavedFieldsCount; if (iSavedFieldsShared) { iSavedFields = savedFields = (SavedField[])iSavedFields.clone(); iSavedFieldsShared = false; } sort(savedFields, count); if (count > 0) { // alter base year for parsing if first field is month or day DurationField months = DurationFieldType.months().getField(iChrono); DurationField days = DurationFieldType.days().getField(iChrono); DurationField first = savedFields[0].iField.getDurationField(); if (resetFields) { if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); return computeMillis(resetFields, text); } } } long millis = iMillis; try { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e; } if (iOffset != null) { millis -= iOffset; } else if (iZone != null) { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')'; if (text != null) { message = \"Cannot parse \\\"\" + text + \"\\\": \" + message; } throw new IllegalInstantException(message); } } return millis; }"
      }
    ]
  },
  {
    "PatchId": "Chart_5_dynamoth_patch_19277_1.diff",
    "BugId": "Chart_5",
    "PatchedMethods": [
      {
        "DevIntention": "add|or|update",
        "OrgCode": "public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); } existing.setY(y); } else { // if the series is sorted, the negative index is a result from // Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... if (this.autoSort) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { this.data.add(new XYDataItem(x, y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } } fireSeriesChanged(); return overwritten; }",
        "PatCode": "public XYDataItem addOrUpdate(Number x, Number y) { if (x == null) { throw new IllegalArgumentException(\"Null 'x' argument.\"); } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0 && !this.allowDuplicateXValues) { XYDataItem existing = (XYDataItem) this.data.get(index); try { overwritten = (XYDataItem) existing.clone(); } catch (CloneNotSupportedException e) { throw new SeriesException(\"Couldn't clone XYDataItem!\"); } existing.setY(y); } else { // if the series is sorted, the negative index is a result from // Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list... if (false) { this.data.add(-index - 1, new XYDataItem(x, y)); } else { this.data.add(new XYDataItem(x, y)); } // check if this addition will exceed the maximum item count... if (getItemCount() > this.maximumItemCount) { this.data.remove(0); } } fireSeriesChanged(); return overwritten; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_TBar_Patch_223242_7_cp2.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(tryBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_81_jGenProg_patch_5180000_3168.diff",
    "BugId": "Math_81",
    "PatchedMethods": [
      {
        "DevIntention": "compute|shift|increment",
        "OrgCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }",
        "PatCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_1793658_231_cp159.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null || isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19357588_964.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { if (src == null) { return;}System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_Avatar_Patch_685358_139.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_TBar_Patch_26388257_2834_cp1207.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "init",
        "OrgCode": "private void init() { thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR); nameValues= new ConcurrentHashMap<Integer, KeyValue[]>(); StringBuilder regex= new StringBuilder(); List<Strategy> collector = new ArrayList<Strategy>(); Matcher patternMatcher= formatPattern.matcher(pattern); if(!patternMatcher.lookingAt()) { throw new IllegalArgumentException(\"Invalid pattern\"); } currentFormatField= patternMatcher.group(); Strategy currentStrategy= getStrategy(currentFormatField); for(;;) { patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); if(!patternMatcher.lookingAt()) { nextStrategy = null; break; } String nextFormatField= patternMatcher.group(); nextStrategy = getStrategy(nextFormatField); if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); } currentFormatField= nextFormatField; currentStrategy= nextStrategy; } if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); } currentFormatField= null; strategies= collector.toArray(new Strategy[collector.size()]); parsePattern= Pattern.compile(regex.toString()); }",
        "PatCode": "private void init() { thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR); nameValues= new ConcurrentHashMap<Integer, KeyValue[]>(); StringBuilder regex= new StringBuilder(); List<Strategy> collector = new ArrayList<Strategy>(); Matcher patternMatcher= formatPattern.matcher(pattern); if(!patternMatcher.lookingAt()) { throw new IllegalArgumentException(\"Invalid pattern\"); } currentFormatField= patternMatcher.group(); Strategy currentStrategy= getStrategy(currentFormatField); for(;;) { patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd()); if(!patternMatcher.lookingAt()) { nextStrategy = null; break; } String nextFormatField= patternMatcher.group(); nextStrategy = getStrategy(nextFormatField); if(currentStrategy.addRegex(this, regex)) { collector.add(currentStrategy); } currentFormatField= nextFormatField; currentStrategy= nextStrategy; } if(currentStrategy == DAY_OF_WEEK_STRATEGY || (currentStrategy.addRegex(this, regex))) { collector.add(currentStrategy); } currentFormatField= null; strategies= collector.toArray(new Strategy[collector.size()]); parsePattern= Pattern.compile(regex.toString()); }"
      }
    ]
  },
  {
    "PatchId": "Math_53_jGenProg_patch_284000_1502.diff",
    "BugId": "Math_53",
    "PatchedMethods": [
      {
        "DevIntention": "add",
        "OrgCode": "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
        "PatCode": "public Complex add(Complex rhs) throws NullArgumentException { /** * Return the conjugate of this complex number. The conjugate of * \"A + Bi\" is \"A - Bi\". * <p> * {@link #NaN} is returned if either the real or imaginary * part of this Complex number equals <code>Double.NaN</code>.</p> * <p> * If the imaginary part is infinite, and the real part is not NaN, * the returned value has infinite imaginary part of the opposite * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code> * is <code>1 - NEGATIVE_INFINITY i</code></p> * * @return the conjugate of this Complex object */ /** * Return the quotient of this complex number and the given complex number. * <p> * Implements the definitional formula * <pre><code> * a + bi ac + bd + (bc - ad)i * ----------- = ------------------------- * c + di c<sup>2</sup> + d<sup>2</sup> * </code></pre> * but uses * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\"> * prescaling of operands</a> to limit the effects of overflows and * underflows in the computation.</p> * <p> * Infinite and NaN values are handled / returned according to the * following rules, applied in the order presented: * <ul> * <li>If either this or <code>rhs</code> has a NaN value in either part, * {@link #NaN} is returned.</li> * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned. * </li> * <li>If this and <code>rhs</code> are both infinite, * {@link #NaN} is returned.</li> * <li>If this is finite (i.e., has no infinite or NaN parts) and * <code>rhs</code> is infinite (one or both parts infinite), * {@link #ZERO} is returned.</li> * <li>If this is infinite and <code>rhs</code> is finite, NaN values are * returned in the parts of the result if the {@link java.lang.Double} * rules applied to the definitional formula force NaN results.</li> * </ul></p> * * @param rhs the other complex number * @return the complex number quotient * @throws NullArgumentException if <code>rhs</code> is null */ if (isNaN || rhs.isNaN) { return NaN;} org.apache.commons.math.util.MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());} public org.apache.commons.math.complex.Complex conjugate() { if (isNaN) { return org.apache.commons.math.complex.Complex.NaN;} return createComplex(real, -imaginary);} public org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws org.apache.commons.math.exception.NullArgumentException { org.apache.commons.math.util.MathUtils.checkNotNull(rhs); if (isNaN || rhs.isNaN) { return org.apache.commons.math.complex.Complex.NaN;} double c = rhs.getReal(); double d = rhs.getImaginary(); if (c == 0.0 && d == 0.0) { return NaN; } if (rhs.isInfinite() && !isInfinite()) { return ZERO; } if (FastMath.abs(c) < FastMath.abs(d)) { double q = c / d; double denominator = c * q + d; return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator); } else { double q = d / c; double denominator = d * q + c; return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator); } }"
      },
      {
        "DevIntention": "conjugate",
        "OrgCode": "public Complex conjugate() { if (isNaN) { return NaN; } return createComplex(real, -imaginary); }",
        "PatCode": "} org.apache.commons.math.util.MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());} public org.apache.commons.math.complex.Complex conjugate() { if (isNaN) { return org.apache.commons.math.complex.Complex.NaN;} return createComplex(real, -imaginary);} public org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws org.apache.commons.math.exception.NullArgumentException { org.apache.commons.math.util.MathUtils.checkNotNull(rhs); if (isNaN || rhs.isNaN) { return org.apache.commons.math.complex.Complex.NaN;} double c = rhs.getReal(); double d = rhs.getImaginary(); if (c == 0.0 && d == 0.0) {"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18487889_934.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, NEGATIVE_VAR_COLUMN_LABEL, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18137881_918.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, this.maxUlps, src.length); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_760399_117_cp65.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_Nopol_patch_18401_1.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { work[i + k] = work[j - k]; } work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17963739_914.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, DEFAULT_ULPS, src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_21564439_1072.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "create|tableau",
        "OrgCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }",
        "PatCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.LEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Math_30_TBar_Patch_1906900_115_cp51.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = (1.0 / 12.0) * n1n2prod * (n1 + n2 + 1); final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_451952_9_cp9.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(DEFAULT_ABSOLUTE_ACCURACY); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_24000_43.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1;if (true)return false; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9584929_1022_cp782.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa == upperBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jGenProg_patch_1117000_1830.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1;for (int i = 0; i < j; i += 4) j -= 4; return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1478868_296_cp143.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (numeric != str || (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_47000_46.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) {if (true)return false; for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_TBar_Patch_204334_12_cp6.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_70_FixMiner_Patch_815149_342.diff",
    "BugId": "Math_70",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); }",
        "PatCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return Math.PI; }"
      }
    ]
  },
  {
    "PatchId": "Math_8_TBar_Patch_930853_24_cp12.diff",
    "BugId": "Math_8",
    "PatchedMethods": [
      {
        "DevIntention": "sample",
        "OrgCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i < sampleSize; i++) { out[i] = sample(); } return out; }",
        "PatCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); return out; }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_Avatar_Patch_318206_116.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "estimate|length",
        "OrgCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max; }",
        "PatCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { if (mValues == null) return LONG; int len = mValues[i].length(); if (len > max) { max = len; } } return max; }"
      },
      {
        "DevIntention": "add|regex",
        "OrgCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }",
        "PatCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }"
      },
      {
        "DevIntention": "set|calendar",
        "OrgCode": "public void setCalendar(FastDateParser parser, Calendar cal, String value) { KeyValue[] textKeyValues= parser.getDisplayNames(field); int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR); if(idx<0) { StringBuilder sb= new StringBuilder(value); sb.append(\" not in (\"); for(KeyValue textKeyValue : textKeyValues) { sb.append(textKeyValue.key).append(' '); } sb.setCharAt(sb.length()-1, ')'); throw new IllegalArgumentException(sb.toString()); } cal.set(field, textKeyValues[idx].value); }",
        "PatCode": "public void setCalendar(FastDateParser parser, Calendar cal, String value) { KeyValue[] textKeyValues= parser.getDisplayNames(field); int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR); if(idx >= 0) { StringBuilder sb= new StringBuilder(value); sb.append(\" not in (\"); for(KeyValue textKeyValue : textKeyValues) { sb.append(textKeyValue.key).append(' '); } sb.setCharAt(sb.length()-1, ')'); throw new IllegalArgumentException(sb.toString()); } cal.set(field, textKeyValues[idx].value); }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_97058_3.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { if ((param[0] <= 0) && (param[0] != 2)) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17614505_906.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "get|constraints",
        "OrgCode": "protected Collection<LinearConstraint> getConstraints() { return Collections.unmodifiableCollection(linearConstraints); }",
        "PatCode": "protected Collection<LinearConstraint> getConstraints() { if (linearConstraints == null) { return null;}return Collections.unmodifiableCollection(linearConstraints); }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_432000_557.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) {if (true)return false; if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) { int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_62_kPAR_Patch_1851733_178_cp93.diff",
    "BugId": "Math_62",
    "PatchedMethods": [
      {
        "DevIntention": "optimize",
        "OrgCode": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException { optima = new UnivariateRealPointValuePair[starts]; totalEvaluations = 0; // Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { optima[i] = null; } final int usedEvaluations = optimizer.getEvaluations(); optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations); totalEvaluations += usedEvaluations; } sortPairs(goal); if (optima[0] == null) { throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts); } // Return the point with the best objective function value. return optima[0]; }",
        "PatCode": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException { optima = new UnivariateRealPointValuePair[starts]; totalEvaluations = 0; // Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, min, FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { optima[i] = null; } final int usedEvaluations = optimizer.getEvaluations(); optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations); totalEvaluations += usedEvaluations; } sortPairs(goal); if (optima[0] == null) { throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts); } // Return the point with the best objective function value. return optima[0]; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2856743_336_cp256.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(expPos > -1)) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_41_Nopol_patch_216727_1.diff",
    "BugId": "Math_41",
    "PatchedMethods": [
      {
        "DevIntention": "evaluate",
        "OrgCode": "public double evaluate(final double[] values, final double[] weights, final int begin, final int length) { if (test(values, weights, begin, length)) { Sum sum = new Sum(); // Compute initial estimate using definitional formula double sumw = sum.evaluate(weights,begin,length); double xbarw = sum.evaluate(values, weights, begin, length) / sumw; // Compute correction factor in second pass double correction = 0; for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } return xbarw + (correction/sumw); } return Double.NaN; }",
        "PatCode": "public double evaluate(final double[] values, final double[] weights, final int begin, final int length) { if (test(values, weights, begin, length)) { Sum sum = new Sum(); // Compute initial estimate using definitional formula double sumw = sum.evaluate(weights,begin,length); double xbarw = sum.evaluate(values, weights, begin, length) / sumw; // Compute correction factor in second pass double correction = 0; for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } if (xbarw < length) { return xbarw + (correction/sumw); } } return Double.NaN; }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_Avatar_Patch_766480_91.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "set|error|indicator|stroke",
        "OrgCode": "public void setErrorIndicatorStroke(Stroke stroke) { this.errorIndicatorStroke = stroke; notifyListeners(new RendererChangeEvent(this)); }",
        "PatCode": "public void setErrorIndicatorStroke(Stroke stroke) { this.errorIndicatorStroke = stroke; notifyListeners(new RendererChangeEvent(this)); }"
      }
    ]
  },
  {
    "PatchId": "Time_7_Nopol_patch_562963_4.diff",
    "BugId": "Time_7",
    "PatchedMethods": [
      {
        "DevIntention": "compute|millis",
        "OrgCode": "public long computeMillis(boolean resetFields, String text) { SavedField[] savedFields = iSavedFields; int count = iSavedFieldsCount; if (iSavedFieldsShared) { iSavedFields = savedFields = (SavedField[])iSavedFields.clone(); iSavedFieldsShared = false; } sort(savedFields, count); if (count > 0) { // alter base year for parsing if first field is month or day DurationField months = DurationFieldType.months().getField(iChrono); DurationField days = DurationFieldType.days().getField(iChrono); DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); return computeMillis(resetFields, text); } } long millis = iMillis; try { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e; } if (iOffset != null) { millis -= iOffset; } else if (iZone != null) { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')'; if (text != null) { message = \"Cannot parse \\\"\" + text + \"\\\": \" + message; } throw new IllegalInstantException(message); } } return millis; }",
        "PatCode": "public long computeMillis(boolean resetFields, String text) { SavedField[] savedFields = iSavedFields; int count = iSavedFieldsCount; if (iSavedFieldsShared) { iSavedFields = savedFields = (SavedField[])iSavedFields.clone(); iSavedFieldsShared = false; } sort(savedFields, count); if ((count > 0) && ((org.joda.time.format.DateTimeParserBucket.this.iMillis < org.joda.time.format.DateTimeParserBucket.this.iSavedFields.length) || ((2) != (count)))) { // alter base year for parsing if first field is month or day DurationField months = DurationFieldType.months().getField(iChrono); DurationField days = DurationFieldType.days().getField(iChrono); DurationField first = savedFields[0].iField.getDurationField(); if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { saveField(DateTimeFieldType.year(), iDefaultYear); return computeMillis(resetFields, text); } } long millis = iMillis; try { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, resetFields); } if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } } } catch (IllegalFieldValueException e) { if (text != null) { e.prependMessage(\"Cannot parse \\\"\" + text + '\"'); } throw e; } if (iOffset != null) { millis -= iOffset; } else if (iZone != null) { int offset = iZone.getOffsetFromLocal(millis); millis -= offset; if (offset != iZone.getOffset(millis)) { String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')'; if (text != null) { message = \"Cannot parse \\\"\" + text + \"\\\": \" + message; } throw new IllegalInstantException(message); } } return millis; }"
      }
    ]
  },
  {
    "PatchId": "Math_41_dynamoth_patch_990745_131.diff",
    "BugId": "Math_41",
    "PatchedMethods": [
      {
        "DevIntention": "evaluate",
        "OrgCode": "public double evaluate(final double[] values, final double[] weights, final int begin, final int length) { double var = Double.NaN; if (test(values, weights,begin, length)) { clear(); if (length == 1) { var = 0.0; } else if (length > 1) { Mean mean = new Mean(); double m = mean.evaluate(values, weights, begin, length); var = evaluate(values, weights, m, begin, length); } } return var; }",
        "PatCode": "public double evaluate(final double[] values, final double[] weights, final int begin, final int length) { double var = Double.NaN; if (values[0] <= length) { if (test(values, weights,begin, length)) { clear(); if (length == 1) { var = 0.0; } else if (length > 1) { Mean mean = new Mean(); double m = mean.evaluate(values, weights, begin, length); var = evaluate(values, weights, m, begin, length); } } } return var; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_jMutRepair_patch_8000_32.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex == 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_1876857_70_cp51.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.atanh(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19143075_957.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), this.numSlackVariables); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_jMutRepair_patch_84000_100.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if ((fa / fb) >= 0.0) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Nopol_patch_271830_2.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if ((org.apache.commons.math3.optimization.linear.SimplexTableau.NEGATIVE_VAR_COLUMN_LABEL.length()) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) { if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Math_2_TBar_Patch_6176765_146_cp120.diff",
    "BugId": "Math_2",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|numerical|variance",
        "OrgCode": "protected double calculateNumericalVariance() { final double N = getPopulationSize(); final double m = getNumberOfSuccesses(); final double n = getSampleSize(); return (n * m * (N - n) * (N - m)) / (N * N * (N - 1)); }",
        "PatCode": "protected double calculateNumericalVariance() { final double N = getPopulationSize(); final int m = getNumberOfSuccesses(); final int n = getSampleSize(); return (n * m * (N - n) * (N - m)) / (N * N * (N - 1)); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Avatar_Patch_138689_4.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(rtol); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_4680079_156_cp135.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && ((f1 >= 0))) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_97056_2.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { if ((param[0] != 2) && (param[0] <= 0)) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18619035_937.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.f, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9443980_1004_cp764.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa > initial && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_dynamoth_patch_16849_1.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "draw|item",
        "OrgCode": "public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset data, int row, int column, int pass) { // defensive check if (!(data instanceof StatisticalCategoryDataset)) { throw new IllegalArgumentException( \"Requires StatisticalCategoryDataset.\"); } StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; PlotOrientation orientation = plot.getOrientation(); if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } else if (orientation == PlotOrientation.VERTICAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } }",
        "PatCode": "public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset data, int row, int column, int pass) { // defensive check if (!(data instanceof StatisticalCategoryDataset)) { throw new IllegalArgumentException( \"Requires StatisticalCategoryDataset.\"); } StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; PlotOrientation orientation = plot.getOrientation(); if (false) { if (orientation == PlotOrientation.HORIZONTAL) { drawHorizontalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } else if (orientation == PlotOrientation.VERTICAL) { drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, statData, row, column); } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jKali_patch_115000_209.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "assert|valid|resolve",
        "OrgCode": "public static JSType assertValidResolve( JSType type, StaticScope<JSType> scope) { ErrorReporter t = TestErrorReporter.forNoExpectedReports(); JSType resolvedType = type.resolve(t, scope); assertTypeEquals(\"JSType#resolve should not affect object equality\", type, resolvedType); Assert.assertEquals(\"JSType#resolve should not affect hash codes\", type.hashCode(), resolvedType.hashCode()); return resolvedType; } public static void assertTypeNotEquals(JSType a, JSType b) { assertTypeNotEquals(\"\", a, b); } public static void assertTypeNotEquals(String message, JSType a, JSType b) { Assert.assertFalse( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Type: \" + b + \"\\n\", a.isEquivalentTo(b)); Assert.assertFalse( message + \" Equals is not symmetric.\\n\" + \"Type: \" + b + \"\\n\", b.isEquivalentTo(a)); } public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); } public static void assertTypeEquals(String message, JSType a, JSType b) { Assert.assertTrue( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Expected: \" + a + \"\\n\" + \"Actual : \" + b, a.isEquivalentTo(b)); Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }",
        "PatCode": "public static JSType assertValidResolve( JSType type, StaticScope<JSType> scope) { ErrorReporter t = TestErrorReporter.forNoExpectedReports(); JSType resolvedType = type.resolve(t, scope); assertTypeEquals(\"JSType#resolve should not affect object equality\", type, resolvedType); Assert.assertEquals(\"JSType#resolve should not affect hash codes\", type.hashCode(), resolvedType.hashCode()); return resolvedType; } public static void assertTypeNotEquals(JSType a, JSType b) { assertTypeNotEquals(\"\", a, b); } public static void assertTypeNotEquals(String message, JSType a, JSType b) { Assert.assertFalse( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Type: \" + b + \"\\n\", a.isEquivalentTo(b)); Assert.assertFalse( message + \" Equals is not symmetric.\\n\" + \"Type: \" + b + \"\\n\", b.isEquivalentTo(a)); } public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); }com.google.javascript.rhino.testing.Asserts.assertTypeEquals(\"\", a, b); public static void assertTypeEquals(String message, JSType a, JSType b) { Assert.assertTrue( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Expected: \" + a + \"\\n\" + \"Actual : \" + b, a.isEquivalentTo(b)); Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_jGenProg_patch_2363000_23664.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { .getTime(); /** * Recalculates the bounds for the collection of items. */ /** * Adds a new data item to the series and sends a {@link SeriesChangeEvent} * to all registered listeners. * * @param period the time period (<code>null</code> not permitted). * @param value the value. * * @see #add(TimePeriod, Number) */ /** * Adds a new data item to the series and sends a {@link SeriesChangeEvent} * to all registered listeners. * * @param period the time period (<code>null</code> not permitted). * @param value the value (<code>null</code> permitted). */ /** * Updates (changes) the value of a data item and sends a * {@link SeriesChangeEvent} to all registered listeners. * * @param index the index of the data item to update. * @param value the new value (<code>null</code> not permitted). */ /** * Deletes data from start until end index (end inclusive) and sends a * {@link SeriesChangeEvent} to all registered listeners. * * @param start the index of the first period to delete. * @param end the index of the last period to delete. */ /** * Tests the series for equality with another object. * * @param obj the object (<code>null</code> permitted). * * @return <code>true</code> or <code>false</code>. */ /** * Returns a hash code value for the object. * * @return The hashcode */ /** * Returns a clone of the collection. * <P> * Notes: * <ul> * <li>no need to clone the domain and range descriptions, since String * object is immutable;</li> * <li>we pass over to the more general method createCopy(start, end). * </li> * </ul> * * @return A clone of the time series. * * @throws CloneNotSupportedException if there is a cloning problem. */ /** * Creates a new instance by copying a subset of the data in this * collection. * * @param start the index of the first item to copy. * @param end the index of the last item to copy. * * @return A copy of a subset of the items. * * @throws CloneNotSupportedException if there is a cloning problem. */ /** * Returns the index of the time period with the minimum start milliseconds. * * @return The index. */ /** * Returns the index of the time period with the maximum start milliseconds. * * @return The index. */ /** * Returns the index of the time period with the minimum middle * milliseconds. * * @return The index.this.data.remove(0); this.minEndIndex = index;}} else { this.minEndIndex = index;} if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd().getTime(); if (end > maxEnd) { this.maxEndIndex = index;}} else { this.maxEndIndex = index;}} private void recalculateBounds() { this.minStartIndex = -1; this.minMiddleIndex = -1; this.minEndIndex = -1; this.maxStartIndex = -1; this.maxMiddleIndex = -1; this.maxEndIndex = -1; for (int i = 0; i < this.data.size(); i++) { org.jfree.data.time.TimePeriodValue tpv = ((org.jfree.data.time.TimePeriodValue) (this.data.get(i))); updateBounds(tpv.getPeriod(), i);}} public void add(org.jfree.data.time.TimePeriod period, double value) { org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); add(item);} public void add(org.jfree.data.time.TimePeriod period, java.lang.Number value) { org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); add(item);} public void update(int index, java.lang.Number value) { org.jfree.data.time.TimePeriodValue item = getDataItem(index); item.setValue(value); fireSeriesChanged();} public void delete(int start, int end) { for (int i = 0; i <= (end - start); i++) { this.data.remove(start);} recalculateBounds(); fireSeriesChanged();} public boolean equals(java.lang.Object obj) { if (obj == this) { return true;} if (!(obj instanceof org.jfree.data.time.TimePeriodValues)) { return false;} if (!super.equals(obj)) { return false;} org.jfree.data.time.TimePeriodValues that = ((org.jfree.data.time.TimePeriodValues) (obj)); if (!org.jfree.chart.util.ObjectUtilities.equal(this.getDomainDescription(), that.getDomainDescription())) { return false;} if (!org.jfree.chart.util.ObjectUtilities.equal(this.getRangeDescription(), that.getRangeDescription())) { return false;} int count = getItemCount(); if (count != that.getItemCount()) { return false;} for (int i = 0; i < count; i++) { if (!getDataItem(i).equals(that.getDataItem(i))) { return false;}} return true;} public int hashCode() { int result; result = (this.domain != null) ? this.domain.hashCode() : 0; result = (29 * result) + (this.range != null ? this.range.hashCode() : 0); result = (29 * result) + this.data.hashCode(); result = (29 * result) + this.minStartIndex; result = (29 * result) + this.maxStartIndex; result = (29 * result) + this.minMiddleIndex; result = (29 * result) + this.maxMiddleIndex; result = (29 * result) + this.minEndIndex; result = (29 * result) + this.maxEndIndex; return result;} public java.lang.Object clone() throws java.lang.CloneNotSupportedException { java.lang.Object clone = createCopy(0, getItemCount() - 1); return clone;} public org.jfree.data.time.TimePeriodValues createCopy(int start, int end) throws java.lang.CloneNotSupportedException { org.jfree.data.time.TimePeriodValues copy = ((org.jfree.data.time.TimePeriodValues) (super.clone())); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { org.jfree.data.time.TimePeriodValue item = ((org.jfree.data.time.TimePeriodValue) (this.data.get(index))); org.jfree.data.time.TimePeriodValue clone = ((org.jfree.data.time.TimePeriodValue) (item.clone())); try { copy.add(clone);} catch (org.jfree.data.general.SeriesException e) { java.lang.System.err.println(\"Failed to add cloned item.\");}}} return copy;} public int getMinStartIndex() { return this.minStartIndex;} public int getMaxStartIndex() { return this.maxStartIndex;}"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_97053_1.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { if (param[0] <= 0) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_12801666_2433_cp1120.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio <= DEFAULT_EPSILON || (ratio < minRatio)) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_12785376_2431_cp1118.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < DEFAULT_EPSILON || (ratio < minRatio)) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_82_jGenProg_patch_696000_3456.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|column",
        "OrgCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } } return minPos; }",
        "PatCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { /** * Returns the row with the minimum ratio as given by the minimum ratio test (MRT). * @param tableau simple tableau for the problem * @param col the column to test the ratio of. See {@link #getPivotColumn(SimplexTableau)} * @return row with the minimum ratio */ /** * Runs one iteration of the Simplex method on the given model. * @param tableau simple tableau for the problem * @throws OptimizationException if the maximal iteration count has been * exceeded or if the model is found not to have a bounded solution */goalType = goalType; minPos = i;}} return minPos;} private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) { double minRatio = java.lang.Double.MAX_VALUE; java.lang.Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i;}}} return minRatioPos;} protected void doIteration(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9939835_1064_cp824.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb > initial && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Lang_44_TBar_Patch_386167_140_cp30.diff",
    "BugId": "Lang_44",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String val) throws NumberFormatException { if (val == null) { return null; } if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); } if (val.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) { return createInteger(val); } char lastChar = val.charAt(val.length() - 1); String mant; String dec; String exp; int decPos = val.indexOf('.'); int expPos = val.indexOf('e') + val.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(val + \" is not a valid number.\"); } dec = val.substring(decPos + 1, expPos); } else { dec = val.substring(decPos + 1); } mant = val.substring(0, decPos); } else { if (expPos > -1) { mant = val.substring(0, expPos); } else { mant = val; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = val.substring(0, val.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(val + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException e) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // empty catch } //Fall through default : throw new NumberFormatException(val + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(val); } catch (NumberFormatException nfe) { // empty catch } try { return createLong(val); } catch (NumberFormatException nfe) { // empty catch } return createBigInteger(val); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(val); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // empty catch } try { Double d = createDouble(val); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } return createBigDecimal(val); } } }",
        "PatCode": "public static Number createNumber(String val) throws NumberFormatException { if (val == null) { return null; } if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); } if (val.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) { return createInteger(val); } char lastChar = val.charAt(val.length() - 1); String mant; String dec; String exp; int decPos = val.indexOf('.'); int expPos = val.indexOf('e') + val.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(val + \" is not a valid number.\"); } dec = val.substring(decPos + 1, expPos); } else { dec = val.substring(decPos + 1); } mant = val.substring(0, decPos); } else { if (expPos > -1) { mant = val.substring(0, expPos); } else { mant = val; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = val.substring(0, val.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec != numeric || (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(val + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException e) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // empty catch } //Fall through default : throw new NumberFormatException(val + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(val); } catch (NumberFormatException nfe) { // empty catch } try { return createLong(val); } catch (NumberFormatException nfe) { // empty catch } return createBigInteger(val); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(val); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // empty catch } try { Double d = createDouble(val); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } return createBigDecimal(val); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_13983985_2590_cp1264.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (entry >= this.epsilon && (MathUtils.compareTo(entry, 0, epsilon) >= 0)) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9538495_1016_cp776.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa > lowerBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_32000_44.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1;if (true)return false; return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Avatar_Patch_71866_1.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(fx); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_4596778_252_cp97.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(this.maxUlps, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_286068_4_cp4.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(atol); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_84_jMutRepair_patch_19000_12.diff",
    "BugId": "Math_84",
    "PatchedMethods": [
      {
        "DevIntention": "iterate|simplex",
        "OrgCode": "@Override protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { while (true) { incrementIterationsCounter(); // save the original vertex final RealPointValuePair[] original = simplex; final RealPointValuePair best = original[0]; // perform a reflection step final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator); if (comparator.compare(reflected, best) < 0) { // compute the expanded simplex final RealPointValuePair[] reflectedSimplex = simplex; final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); if (comparator.compare(reflected, expanded) <= 0) { // accept the reflected simplex simplex = reflectedSimplex; } return; } // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex // check convergence return; } } }",
        "PatCode": "@Override protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { while (true) { incrementIterationsCounter(); // save the original vertex final RealPointValuePair[] original = simplex; final RealPointValuePair best = original[0]; // perform a reflection step final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator); if (comparator.compare(reflected, best) < 0) { // compute the expanded simplex final RealPointValuePair[] reflectedSimplex = simplex; final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); if (comparator.compare(reflected, expanded) <= 0) { // accept the reflected simplex simplex = reflectedSimplex; } return; } // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);if (comparator.compare(contracted, best) <= 0) { // accept the contracted simplex // check convergence return; } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_Avatar_Patch_86434_9.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "get|max|middle|index",
        "OrgCode": "public int getMaxMiddleIndex() { return this.maxMiddleIndex; }",
        "PatCode": "public int getMaxMiddleIndex() { return this.maxEndIndex; }"
      }
    ]
  },
  {
    "PatchId": "Math_95_TBar_Patch_45130_10_cp4.diff",
    "BugId": "Math_95",
    "PatchedMethods": [
      {
        "DevIntention": "get|initial|domain",
        "OrgCode": "protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); return ret; }",
        "PatCode": "protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); return d; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_4507775_245_cp95.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(this.numSlackVariables, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_TBar_Patch_143129_3_cp1.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); matchingExitNode(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_21651212_1074.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "create|tableau",
        "OrgCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }",
        "PatCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || ((getNumObjectiveFunctions() == 1))) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Closure_13_jKali_patch_631000_355.diff",
    "BugId": "Closure_13",
    "PatchedMethods": [
      {
        "DevIntention": "get|compiler",
        "OrgCode": "PeepholeOptimizationsPass(AbstractCompiler compiler, AbstractPeepholeOptimization... optimizations) { this.compiler = compiler; this.peepholeOptimizations = optimizations; } public AbstractCompiler getCompiler() { return compiler; } @Override public void process(Node externs, Node root) { PeepholeChangeHandler handler = new PeepholeChangeHandler(); compiler.addChangeHandler(handler); beginTraversal(); traverse(root); endTraversal(); compiler.removeChangeHandler(handler); } private void traverse(Node node) { // The goal here is to avoid retraversing // the entire AST to catch newly created opportunities. // So we track whether a \"unit of code\" has changed, // and revisit immediately. if (!shouldVisit(node)) { return; } int visits = 0; do { Node c = node.getFirstChild(); while(c != null) { traverse(c); Node next = c.getNext(); c = next; } visit(node); visits++; Preconditions.checkState(visits < 10000, \"too many interations\"); } while (shouldRetraverse(node)); exitNode(node); } private boolean shouldRetraverse(Node node) { if (node.getParent() != null && node.isFunction() || node.isScript()) { ScopeState state = traversalState.peek(); if (state.changed) { // prepare to re-visit the scope: // when revisiting, only visit the immediate scope // this reduces the cost of getting to a fixed // point in global scope. state.changed = false; state.traverseChildScopes = false; return true; } } return false; } private boolean shouldVisit(Node node) { if (node.isFunction() || node.isScript()) { ScopeState previous = traversalState.peek(); if (!previous.traverseChildScopes) { return false; } traversalState.push(); } return true; } private void exitNode(Node node) { if (node.isFunction() || node.isScript()) { traversalState.pop(); } } public void visit(Node n) { Node currentVersionOfNode = n; boolean somethingChanged = false; do { somethingChanged = false; for (AbstractPeepholeOptimization optimization : peepholeOptimizations) { Node newVersionOfNode = optimization.optimizeSubtree(currentVersionOfNode); if (newVersionOfNode != currentVersionOfNode) { somethingChanged = true; currentVersionOfNode = newVersionOfNode; } if (currentVersionOfNode == null) { return; } } } while(somethingChanged); }",
        "PatCode": "PeepholeOptimizationsPass(AbstractCompiler compiler, AbstractPeepholeOptimization... optimizations) { this.compiler = compiler; this.peepholeOptimizations = optimizations; } public AbstractCompiler getCompiler() { return compiler; } @Override public void process(Node externs, Node root) { PeepholeChangeHandler handler = new PeepholeChangeHandler(); compiler.addChangeHandler(handler); beginTraversal(); traverse(root); endTraversal(); compiler.removeChangeHandler(handler); } private void traverse(Node node) { // The goal here is to avoid retraversing // the entire AST to catch newly created opportunities. // So we track whether a \"unit of code\" has changed, // and revisit immediately. if (!shouldVisit(node)) { } int visits = 0; do { Node c = node.getFirstChild(); while(c != null) { traverse(c); Node next = c.getNext(); c = next; } visit(node); visits++; Preconditions.checkState(visits < 10000, \"too many interations\"); } while (shouldRetraverse(node)); exitNode(node); } private boolean shouldRetraverse(Node node) { if (node.getParent() != null && node.isFunction() || node.isScript()) { ScopeState state = traversalState.peek(); if (state.changed) { // prepare to re-visit the scope: // when revisiting, only visit the immediate scope // this reduces the cost of getting to a fixed // point in global scope. state.changed = false; state.traverseChildScopes = false; return true; } } return false; } private boolean shouldVisit(Node node) { if (node.isFunction() || node.isScript()) { ScopeState previous = traversalState.peek(); if (!previous.traverseChildScopes) { return false; } traversalState.push(); } return true; } private void exitNode(Node node) { if (node.isFunction() || node.isScript()) { traversalState.pop(); } } public void visit(Node n) { Node currentVersionOfNode = n; boolean somethingChanged = false; do { somethingChanged = false; for (AbstractPeepholeOptimization optimization : peepholeOptimizations) { Node newVersionOfNode = optimization.optimizeSubtree(currentVersionOfNode); if (newVersionOfNode != currentVersionOfNode) { somethingChanged = true; currentVersionOfNode = newVersionOfNode; } if (currentVersionOfNode == null) { return; } } } while(somethingChanged); }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_17680_6.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (org.jfree.data.time.TimeSeries.this.data.size() == org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length()) { if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_Nopol_patch_72894_2.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (0 == exitType) { if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_81_jGenProg_patch_2963000_2210.diff",
    "BugId": "Math_81",
    "PatchedMethods": [
      {
        "DevIntention": "compute|shift|increment",
        "OrgCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }",
        "PatCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }"
      }
    ]
  },
  {
    "PatchId": "Math_57_TBar_Patch_16107545_238_cp138.diff",
    "BugId": "Math_57",
    "PatchedMethods": [
      {
        "DevIntention": "choose|initial|centers",
        "OrgCode": "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); // Choose one center uniformly at random from among the data points. final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. int sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } // Add one new data point as a center. Each point x is chosen with // probability proportional to D(x)2 final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "PatCode": "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); // Choose one center uniformly at random from among the data points. final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { // For each data point x, compute D(x), the distance between x and // the nearest center that has already been chosen. float sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } // Add one new data point as a center. Each point x is chosen with // probability proportional to D(x)2 final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_jKali_patch_16409_30.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; } // public static void main(String[] args) {// long start = System.currentTimeMillis();// boolean flag = true;// int count = 0;// for (int i = 0; i < 100000000; i++) {// flag = toBoolean(\"YES\");// }// long end = System.currentTimeMillis();// System.out.println((end - start) + \" \" + flag + \" \" + count);// }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0);if (true) { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; } // public static void main(String[] args) {// long start = System.currentTimeMillis();// boolean flag = true;// int count = 0;// for (int i = 0; i < 100000000; i++) {// flag = toBoolean(\"YES\");// }// long end = System.currentTimeMillis();// System.out.println((end - start) + \" \" + flag + \" \" + count);// }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18575445_936.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, serialVersionUID, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_72000_452.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {if (width > 0) { ensureCapacity(size + 5); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1557203_304_cp151.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_84_kPAR_Patch_347437_73_cp31.diff",
    "BugId": "Math_84",
    "PatchedMethods": [
      {
        "DevIntention": "iterate|simplex",
        "OrgCode": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { while (true) { incrementIterationsCounter(); // save the original vertex final RealPointValuePair[] original = simplex; final RealPointValuePair best = original[0]; // perform a reflection step final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator); if (comparator.compare(reflected, best) < 0) { // compute the expanded simplex final RealPointValuePair[] reflectedSimplex = simplex; final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); if (comparator.compare(reflected, expanded) <= 0) { // accept the reflected simplex simplex = reflectedSimplex; } return; } // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex // check convergence return; } } }",
        "PatCode": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { while (true) { incrementIterationsCounter(); // save the original vertex final RealPointValuePair[] original = simplex; final RealPointValuePair best = original[0]; // perform a reflection step final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator); if (comparator.compare(reflected, best) < 0) { // compute the expanded simplex final RealPointValuePair[] reflectedSimplex = simplex; final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); if (comparator.compare(reflected, expanded) <= 0) { // accept the reflected simplex simplex = reflectedSimplex; } return; } // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) <= 0) { // accept the contracted simplex // check convergence return; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_TBar_Patch_288825_15_cp9.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x1); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_Avatar_Patch_2253717_418.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "get|mean|value",
        "OrgCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { result = masd.getMean(); } return result; }",
        "PatCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd == null) { result = masd.getMean(); } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_2278532_84_cp63.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.asin(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_63_jKali_patch_62885_18.diff",
    "BugId": "Lang_63",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) { StringBuffer buffer = new StringBuffer(); boolean lastOutputSeconds = false; int sz = tokens.length; for (int i = 0; i < sz; i++) { Token token = tokens[i]; Object value = token.getValue(); int count = token.getCount(); if (value instanceof StringBuffer) { buffer.append(value.toString()); } else { if (value == y) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer .toString(years)); lastOutputSeconds = false; } else if (value == M) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer .toString(months)); lastOutputSeconds = false; } else if (value == d) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer .toString(days)); lastOutputSeconds = false; } else if (value == H) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer .toString(hours)); lastOutputSeconds = false; } else if (value == m) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer .toString(minutes)); lastOutputSeconds = false; } else if (value == s) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer .toString(seconds)); lastOutputSeconds = true; } else if (value == S) { if (lastOutputSeconds) { milliseconds += 1000; String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); buffer.append(str.substring(1)); } else { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); } lastOutputSeconds = false; } } } return buffer.toString(); } static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } } static final Object y = \"y\"; static final Object M = \"M\"; static final Object d = \"d\"; static final Object H = \"H\"; static final Object m = \"m\"; static final Object s = \"s\"; static final Object S = \"S\";",
        "PatCode": "static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) { StringBuffer buffer = new StringBuffer(); boolean lastOutputSeconds = false; int sz = tokens.length; for (int i = 0; i < sz; i++) { Token token = tokens[i]; Object value = token.getValue(); int count = token.getCount(); if (value instanceof StringBuffer) { buffer.append(value.toString()); } else { if (value == y) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer .toString(years)); lastOutputSeconds = false; } else if (value == M) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer .toString(months)); lastOutputSeconds = false; } else if (value == d) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer .toString(days)); lastOutputSeconds = false; } else if (value == H) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer .toString(hours)); lastOutputSeconds = false; } else if (value == m) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer .toString(minutes)); lastOutputSeconds = false; } else if (value == s) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer .toString(seconds)); lastOutputSeconds = true; } else if (value == S) { if (lastOutputSeconds) { milliseconds += 1000; String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); buffer.append(str.substring(1)); } else { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); } lastOutputSeconds = false; } } } return buffer.toString(); } static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } }end.add(field, newdiff); static final Object y = \"y\"; static final Object M = \"M\"; static final Object d = \"d\"; static final Object H = \"H\"; static final Object m = \"m\"; static final Object s = \"s\"; static final Object S = \"S\";"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18879243_943.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.numSlackVariables, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_6_TBar_Patch_211151_5_cp2.diff",
    "BugId": "Math_6",
    "PatchedMethods": [
      {
        "DevIntention": "get|iterations",
        "OrgCode": "public int getIterations() { return iterations.getCount(); }",
        "PatCode": "public int getIterations() { return this.evaluations.getCount(); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_SimFix_patch_661692_4.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.// start of generated patchif(f1==x1){x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol));f0=computeObjectiveValue(x0);}// end of generated patch/* start of original code if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } end of original code*/ break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_10159335_1090_cp850.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb >= upperBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2617072_314_cp234.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || (dec == null && exp == null)) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236237_20.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (this.getSlackVariableOffset() == (this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions())) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9025191_951_cp711.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa / fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_TBar_Patch_403182_19_cp13.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(f1); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_4014502_136_cp115.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && (FastMath.abs(f1) <= ftol)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_4_TBar_Patch_12840684_2083_cp985.diff",
    "BugId": "Chart_4",
    "PatchedMethods": [
      {
        "DevIntention": "get|data|range",
        "OrgCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }",
        "PatCode": "public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; // is it a domain axis? int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { // grab the plot's annotations Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // or is it a range axis? int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } // iterate through the datasets that map to the axis and get the union // of the ranges. Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } if (r == null) return result; Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_TBar_Patch_2980448_353_cp279.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_jMutRepair_patch_3000_9.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "get|mean|value",
        "OrgCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { result = masd.getMean(); } return result; }",
        "PatCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column);if (masd == null) { result = masd.getMean(); } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_58_jMutRepair_patch_22000_107.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); }if (param[2] == 0) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_Avatar_Patch_1411738_147.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_Nopol_patch_84822_4.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "check|tree|equals",
        "OrgCode": "public String checkTreeEquals(Node node2) { NodeMismatch diff = checkTreeEqualsImpl(node2); if (diff != null) { return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\" + node2.toStringTree() + \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() + \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree(); } return null; }",
        "PatCode": "public String checkTreeEquals(Node node2) { NodeMismatch diff = checkTreeEqualsImpl(node2); if (diff != null) { if (com.google.javascript.rhino.Node.this.type <= 42) { return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\" + node2.toStringTree() + \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() + \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree(); } } return null; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_jGenProg_patch_2437000_686.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));f0 = computeObjectiveValue(x0); f0 = f1; } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_105993_8_cp8.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "get|max|middle|index",
        "OrgCode": "public int getMaxMiddleIndex() { return this.maxMiddleIndex; }",
        "PatCode": "public int getMaxMiddleIndex() { return this.maxEndIndex; }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_120645_9.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[0] == 0) { if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jKali_patch_126000_215.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "assert|valid|resolve",
        "OrgCode": "public static JSType assertValidResolve( JSType type, StaticScope<JSType> scope) { ErrorReporter t = TestErrorReporter.forNoExpectedReports(); JSType resolvedType = type.resolve(t, scope); assertTypeEquals(\"JSType#resolve should not affect object equality\", type, resolvedType); Assert.assertEquals(\"JSType#resolve should not affect hash codes\", type.hashCode(), resolvedType.hashCode()); return resolvedType; } public static void assertTypeNotEquals(JSType a, JSType b) { assertTypeNotEquals(\"\", a, b); } public static void assertTypeNotEquals(String message, JSType a, JSType b) { Assert.assertFalse( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Type: \" + b + \"\\n\", a.isEquivalentTo(b)); Assert.assertFalse( message + \" Equals is not symmetric.\\n\" + \"Type: \" + b + \"\\n\", b.isEquivalentTo(a)); } public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); } public static void assertTypeEquals(String message, JSType a, JSType b) { Assert.assertTrue( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Expected: \" + a + \"\\n\" + \"Actual : \" + b, a.isEquivalentTo(b)); Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }",
        "PatCode": "public static JSType assertValidResolve( JSType type, StaticScope<JSType> scope) { ErrorReporter t = TestErrorReporter.forNoExpectedReports(); JSType resolvedType = type.resolve(t, scope); assertTypeEquals(\"JSType#resolve should not affect object equality\", type, resolvedType); Assert.assertEquals(\"JSType#resolve should not affect hash codes\", type.hashCode(), resolvedType.hashCode()); return resolvedType; } public static void assertTypeNotEquals(JSType a, JSType b) { assertTypeNotEquals(\"\", a, b); } public static void assertTypeNotEquals(String message, JSType a, JSType b) { Assert.assertFalse( message + (message.isEmpty() ? \"\" : \"\\n\") + \"Type: \" + b + \"\\n\", a.isEquivalentTo(b)); Assert.assertFalse( message + \" Equals is not symmetric.\\n\" + \"Type: \" + b + \"\\n\", b.isEquivalentTo(a)); } public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); } public static void assertTypeEquals(String message, JSType a, JSType b) {if (true)return; junit.framework.Assert.assertTrue((((((message + (message.isEmpty() ? \"\" : \"\\n\") + \"Expected: \" + a + \"\\n\" + \"Actual : \" + b, a.isEquivalentTo(b)); Assert.assertTrue( message + \" Equals is not symmetric.\\n\" + \"Expected: \" + b + \"\\n\" + \"Actual : \" + a, b.isEquivalentTo(a)); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_2981677_105_cp84.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((f1 >= 0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18791914_941.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.tableau, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_39000_45.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_Avatar_Patch_2323425_429.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "get|mean|value",
        "OrgCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { result = masd.getMean(); } return result; }",
        "PatCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); return result; }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_dynamoth_patch_1209108_2.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "assert|type|equals",
        "OrgCode": "protected final void assertTypeEquals(JSType a, JSType b) { Asserts.assertTypeEquals(a, b); }",
        "PatCode": "protected final void assertTypeEquals(JSType a, JSType b) { if (false) { Asserts.assertTypeEquals(a, b); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_1295686_9634.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString());int strLen = str.length(); ensureCapacity(size + 5); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_Nopol_patch_65105_1.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); if (exitType < exitType) { tryMinimizeExits(finallyBlock, exitType, labelName); } } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_26_TBar_Patch_16829647_3890_cp1444.diff",
    "BugId": "Chart_26",
    "PatchedMethods": [
      {
        "DevIntention": "draw",
        "OrgCode": "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { // if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; } // record the plot area... if (state == null) { // if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes state = new PlotRenderingInfo(null); } state.setPlotArea(area); // adjust the drawing area for the plot insets (if any)... RectangleInsets insets = getInsets(); insets.trim(area); // calculate the data area... AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); // if there is a renderer, it draws the background, otherwise use the // default background... if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); // don't let anyone draw outside the data area Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates() .get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } // draw the markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } // now render data items... boolean foundData = false; // set up the alpha-transparency... Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { for (int i = 0; i < this.datasets.size(); i++) { foundData = render(g2, dataArea, i, state) || foundData; } } else { // DatasetRenderingOrder.REVERSE for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } } // draw the foreground markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } // draw the annotations (if any)... drawAnnotations(g2, dataArea); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } // draw range crosshair if required... if (isRangeCrosshairVisible()) { // FIXME: this doesn't handle multiple range axes drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } // draw an outline around the plot area... if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } }",
        "PatCode": "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { // if the plot area is too small, just return... boolean b1 = (area.getWidth()!=MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; } // record the plot area... if (state == null) { // if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes state = new PlotRenderingInfo(null); } state.setPlotArea(area); // adjust the drawing area for the plot insets (if any)... RectangleInsets insets = getInsets(); insets.trim(area); // calculate the data area... AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); // if there is a renderer, it draws the background, otherwise use the // default background... if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); // don't let anyone draw outside the data area Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates() .get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } // draw the markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } // now render data items... boolean foundData = false; // set up the alpha-transparency... Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { for (int i = 0; i < this.datasets.size(); i++) { foundData = render(g2, dataArea, i, state) || foundData; } } else { // DatasetRenderingOrder.REVERSE for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } } // draw the foreground markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } // draw the annotations (if any)... drawAnnotations(g2, dataArea); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } // draw range crosshair if required... if (isRangeCrosshairVisible()) { // FIXME: this doesn't handle multiple range axes drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } // draw an outline around the plot area... if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_1116176_8312.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();if (strLen >= width) { ensureCapacity(size + 4); str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_8902671_1090_cp792.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxStartIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Avatar_Patch_206894_6.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(ftol); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_73_jGenProg_patch_84000_968.diff",
    "BugId": "Math_73",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); // return the initial guess if it is good enough double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } // return the first endpoint if it is good enough double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } // reduce interval if min and initial bracket the root if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } // return the second endpoint if it is good enough double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } // reduce interval if initial and max bracket the root if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } // full Brent algorithm starting with provided initial guess return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "PatCode": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); // return the initial guess if it is good enough double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } // return the first endpoint if it is good enough double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } // reduce interval if min and initial bracket the root if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } // return the second endpoint if it is good enough double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } // reduce interval if initial and max bracket the root if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial);} return solve(f, min, max); // full Brent algorithm starting with provided initial guess }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19484668_967.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { if (dest == null) { return;}System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252133_5.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - 1)) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135417_3.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.runningState == this.STATE_RUNNING) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_459000_561.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { // flip array return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_10084524_1082_cp842.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb == upperBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252136_6.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions())) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_FixMiner_Patch_531793_153.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null || isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_14651_2.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (endIndex < startIndex) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_633035_4780.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) {ensureCapacity(size + width); ensureCapacity(size + 4); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_76000_51.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k];if (true)return false; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Closure_57_SimFix_patch_1154756_3.diff",
    "BugId": "Closure_57",
    "PatchedMethods": [
      {
        "DevIntention": "extract|class|name|if|goog",
        "OrgCode": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null) { className = target.getString(); } } } } return className; }",
        "PatCode": "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName();// start of generated patchif(functionName.equals(qualifiedName)){Node target=callee.getNext();if(target!=null&&(target.getType()==Token.STRING||target.getType()==Token.REGEXP)){className=target.getString();}}// end of generated patch/* start of original code if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); if (target != null) { className = target.getString(); } } end of original code*/ } } return className; }"
      }
    ]
  },
  {
    "PatchId": "Math_97_dynamoth_patch_209878_1.diff",
    "BugId": "Math_97",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifyInterval(min, max); double ret = Double.NaN; double yMin = f.value(min); double yMax = f.value(max); // Verify bracketing double sign = yMin * yMax; if (sign >= 0) { // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else { // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); // either min or max is a root } return ret; }",
        "PatCode": "public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifyInterval(min, max); double ret = Double.NaN; double yMin = f.value(min); double yMax = f.value(max); // Verify bracketing double sign = yMin * yMax; if (this.functionValueAccuracy <= sign) { // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else { // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); // either min or max is a root } return ret; }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_12670531_2417_cp1104.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio == minRatio || (ratio < minRatio)) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1566872_305_cp152.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null || exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_Nopol_patch_19272_2.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_FixMiner_Patch_7179859_2354.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && Boolean.TRUE && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_132007_15.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "value",
        "OrgCode": "public double value(double x, double[] param) { validateParameters(param); final double diff = x - param[1]; final double i2s2 = 1 / (2 * param[2] * param[2]); return Gaussian.value(diff, param[0], i2s2); }",
        "PatCode": "public double value(double x, double[] param) { if ((param == null) || (param[0] <= 0)) { validateParameters(param); } final double diff = x - param[1]; final double i2s2 = 1 / (2 * param[2] * param[2]); return Gaussian.value(diff, param[0], i2s2); }"
      }
    ]
  },
  {
    "PatchId": "Math_79_SimFix_patch_1051148_2.diff",
    "BugId": "Math_79",
    "PatchedMethods": [
      {
        "DevIntention": "distance",
        "OrgCode": "public static double distance(int[] p1, int[] p2) { int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "PatCode": "public static double distance(int[] p1, int[] p2) {// start of generated patchint sum=0;for(int i=0;i<p1.length;i++){ final double dp=p1[i]-p2[i];sum+=dp*dp;}return Math.sqrt(sum);// end of generated patch/* start of original code int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18966020_945.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.epsilon, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_655232_73_cp6.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "optimize",
        "OrgCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }",
        "PatCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; if (this.goal == null) { return null;}this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19570701_969.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|constraint|type|counts",
        "OrgCode": "private int getConstraintTypeCounts(final Relationship relationship) { int count = 0; for (final LinearConstraint constraint : constraints) { if (constraint.getRelationship() == relationship) { ++count; } } return count; }",
        "PatCode": "private int getConstraintTypeCounts(final Relationship relationship) { int count = 0; if (constraints == null) { throw new IllegalArgumentException(\"Null 'constraints' argument.\");}for (final LinearConstraint constraint : constraints) { if (constraint.getRelationship() == relationship) { ++count; } } return count; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_jMutRepair_patch_19196_47.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; } // public static void main(String[] args) {// long start = System.currentTimeMillis();// boolean flag = true;// int count = 0;// for (int i = 0; i < 100000000; i++) {// flag = toBoolean(\"YES\");// }// long end = System.currentTimeMillis();// System.out.println((end - start) + \" \" + flag + \" \" + count);// }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0);if (ch <= 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; } // public static void main(String[] args) {// long start = System.currentTimeMillis();// boolean flag = true;// int count = 0;// for (int i = 0; i < 100000000; i++) {// flag = toBoolean(\"YES\");// }// long end = System.currentTimeMillis();// System.out.println((end - start) + \" \" + flag + \" \" + count);// }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_13885865_2578_cp1252.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (entry >= DEFAULT_EPSILON && (MathUtils.compareTo(entry, 0, epsilon) >= 0)) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_jGenProg_patch_5897000_7690.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_jGenProg_patch_5503000_53202.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; .getTime();"
      },
      {
        "DevIntention": "recalculate|bounds",
        "OrgCode": "private void recalculateBounds() { this.minStartIndex = -1; this.minMiddleIndex = -1; this.minEndIndex = -1; this.maxStartIndex = -1; this.maxMiddleIndex = -1; this.maxEndIndex = -1; for (int i = 0; i < this.data.size(); i++) { TimePeriodValue tpv = (TimePeriodValue) this.data.get(i); updateBounds(tpv.getPeriod(), i); } }",
        "PatCode": "if (index >= 0) {this.data.remove(index);fireSeriesChanged();}}} else { this.minEndIndex = index;} if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd().getTime(); if (end > maxEnd) { this.maxEndIndex = index;}} else { this.maxEndIndex = index;}} private void recalculateBounds() { this.minStartIndex = -1; this.minMiddleIndex = -1; this.minEndIndex = -1; this.maxStartIndex = -1; this.maxMiddleIndex = -1; this.maxEndIndex = -1; for (int i = 0; i < this.data.size(); i++) { org.jfree.data.time.TimePeriodValue tpv = ((org.jfree.data.time.TimePeriodValue) (this.data.get(i))); updateBounds(tpv.getPeriod(), i);}} public void add(org.jfree.data.time.TimePeriod period, double value) { org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); add(item);} public void add(org.jfree.data.time.TimePeriod period, java.lang.Number value) { org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); add(item);} public void update(int index, java.lang.Number value) { org.jfree.data.time.TimePeriodValue item = getDataItem(index); item.setValue(value); fireSeriesChanged();} public void delete(int start, int end) { for (int i = 0; i <= (end - start); i++) { this.data.remove(start);} recalculateBounds(); fireSeriesChanged();} public boolean equals(java.lang.Object obj) { if (obj == this) { return true;} if (!(obj instanceof org.jfree.data.time.TimePeriodValues)) { return false;} if (!super.equals(obj)) { return false;} org.jfree.data.time.TimePeriodValues that = ((org.jfree.data.time.TimePeriodValues) (obj)); if (!org.jfree.chart.util.ObjectUtilities.equal(this.getDomainDescription(), that.getDomainDescription())) { return false;} if (!org.jfree.chart.util.ObjectUtilities.equal(this.getRangeDescription(), that.getRangeDescription())) { return false;} int count = getItemCount(); if (count != that.getItemCount()) { return false;} for (int i = 0; i < count; i++) { if (!getDataItem(i).equals(that.getDataItem(i))) { return false;}} return true;} public int hashCode() { int result; result = (this.domain != null) ? this.domain.hashCode() : 0; result = (29 * result) + (this.range != null ? this.range.hashCode() : 0); result = (29 * result) + this.data.hashCode(); result = (29 * result) + this.minStartIndex; result = (29 * result) + this.maxStartIndex; result = (29 * result) + this.minMiddleIndex; result = (29 * result) + this.maxMiddleIndex; result = (29 * result) + this.minEndIndex; result = (29 * result) + this.maxEndIndex; return result;} public java.lang.Object clone() throws java.lang.CloneNotSupportedException { java.lang.Object clone = createCopy(0, getItemCount() - 1); return clone;} public org.jfree.data.time.TimePeriodValues createCopy(int start, int end) throws java.lang.CloneNotSupportedException { org.jfree.data.time.TimePeriodValues copy = ((org.jfree.data.time.TimePeriodValues) (super.clone())); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { org.jfree.data.time.TimePeriodValue item = ((org.jfree.data.time.TimePeriodValue) (this.data.get(index))); org.jfree.data.time.TimePeriodValue clone = ((org.jfree.data.time.TimePeriodValue) (item.clone())); try { copy.add(clone);} catch (org.jfree.data.general.SeriesException e) { java.lang.System.err.println(\"Failed to add cloned item.\");}}} return copy;} public int getMinStartIndex() { return this.minStartIndex;} public int getMaxStartIndex() { return this.maxStartIndex;} public int getMinMiddleIndex() { return this.minMiddleIndex;} public int getMaxMiddleIndex() { return this.maxMiddleIndex;} public int getMinEndIndex() { return this.minEndIndex;} public int getMaxEndIndex() { return this.maxEndIndex;}}}"
      }
    ]
  },
  {
    "PatchId": "Chart_15_TBar_Patch_1501916_247_cp127.diff",
    "BugId": "Chart_15",
    "PatchedMethods": [
      {
        "DevIntention": "set|darker|sides",
        "OrgCode": "public void setDarkerSides(boolean darker) { this.darkerSides = darker; notifyListeners(new PlotChangeEvent(this)); }",
        "PatCode": "public void setDarkerSides(boolean darker) { this.darkerSides = darker; notifyListeners(new PlotChangeEvent(this)); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2266624_282_cp202.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || (!Character.isDigit(lastChar))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_Avatar_Patch_2818599_1236.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) { if (obj instanceof Date) { return format((Date) obj, toAppendTo); } else if (obj instanceof Calendar) { return format((Calendar) obj, toAppendTo); } else if (obj instanceof Long) { return format(((Long) obj).longValue(), toAppendTo); } else { throw new IllegalArgumentException(\"Unknown class: \" + (obj == null ? \"<null>\" : obj.getClass().getName())); } }",
        "PatCode": "public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) { if (obj instanceof Date) { return format((Date) obj, toAppendTo); } else if (obj instanceof Calendar) { return format((Calendar) obj, toAppendTo); } else if (obj instanceof Long) { return format(((Long) obj).longValue(), toAppendTo); } else { throw new IllegalArgumentException(\"Unknown class: \" + (obj == null ? \"<null>\" : obj.getClass().getName())); } }"
      },
      {
        "DevIntention": "estimate|length",
        "OrgCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max; }",
        "PatCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { if (mValues == null) return LONG; int len = mValues[i].length(); if (len > max) { max = len; } } return max; }"
      },
      {
        "DevIntention": "get|display|names",
        "OrgCode": "KeyValue[] getDisplayNames(int field) { Integer fieldInt = Integer.valueOf(field); KeyValue[] fieldKeyValues= nameValues.get(fieldInt); if(fieldKeyValues==null) { DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale); switch(field) { case Calendar.ERA: // DateFormatSymbols#getEras() only returns AD/BC or translations // It does not work for the Thai Buddhist or Japanese Imperial calendars. // see: https://issues.apache.org/jira/browse/TRINIDAD-2126 Calendar c = Calendar.getInstance(locale); // N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale)); String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale)); fieldKeyValues= createKeyValues(longEras, shortEras); break; case Calendar.DAY_OF_WEEK: fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays()); break; case Calendar.AM_PM: fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null); break; case Calendar.MONTH: fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths()); break; default: throw new IllegalArgumentException(\"Invalid field value \"+field); } KeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues); if(prior!=null) { fieldKeyValues= prior; } } return fieldKeyValues; }",
        "PatCode": "KeyValue[] getDisplayNames(int field) { Integer fieldInt = Integer.valueOf(field); KeyValue[] fieldKeyValues= nameValues.get(this.currentFormatField); if(fieldKeyValues==null) { DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale); switch(field) { case Calendar.ERA: // DateFormatSymbols#getEras() only returns AD/BC or translations // It does not work for the Thai Buddhist or Japanese Imperial calendars. // see: https://issues.apache.org/jira/browse/TRINIDAD-2126 Calendar c = Calendar.getInstance(locale); // N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale)); String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale)); fieldKeyValues= createKeyValues(longEras, shortEras); break; case Calendar.DAY_OF_WEEK: fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays()); break; case Calendar.AM_PM: fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null); break; case Calendar.MONTH: fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths()); break; default: throw new IllegalArgumentException(\"Invalid field value \"+field); } KeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues); if(prior!=null) { fieldKeyValues= prior; } } return fieldKeyValues; }"
      },
      {
        "DevIntention": "add|regex",
        "OrgCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }",
        "PatCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252138_7.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getSlackVariableOffset())) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236222_15.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - 1)) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_jGenProg_patch_2065000_7748.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2551426_308_cp228.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str.startsWith(\"-0x\"))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_319574_5_cp5.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(ftol); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_TBar_Patch_291814_8_cp3.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(allCatchNodes, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1282777_276_cp123.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec != str || (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_jGenProg_patch_229000_72.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));f0 = computeObjectiveValue(x0); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_53_jGenProg_patch_146000_390.diff",
    "BugId": "Math_53",
    "PatchedMethods": [
      {
        "DevIntention": "add",
        "OrgCode": "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
        "PatCode": "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /** * Return the conjugate of this complex number. The conjugate of * \"A + Bi\" is \"A - Bi\". * <p> * {@link #NaN} is returned if either the real or imaginary * part of this Complex number equals <code>Double.NaN</code>.</p> * <p> * If the imaginary part is infinite, and the real part is not NaN, * the returned value has infinite imaginary part of the opposite * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code> * is <code>1 - NEGATIVE_INFINITY i</code></p> * * @return the conjugate of this Complex object */ /** * Return the quotient of this complex number and the given complex number. * <p> * Implements the definitional formula * <pre><code> * a + bi ac + bd + (bc - ad)i * ----------- = ------------------------- * c + di c<sup>2</sup> + d<sup>2</sup> * </code></pre> * but uses * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\"> * prescaling of operands</a> to limit the effects of overflows and * underflows in the computation.</p> * <p> * Infinite and NaN values are handled / returned according to the * following rules, applied in the order presented: * <ul> * <li>If either this or <code>rhs</code> has a NaN value in either part, * {@link #NaN} is returned.</li> * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned. * </li> * <li>If this and <code>rhs</code> are both infinite, * {@link #NaN} is returned.</li> * <li>If this is finite (i.e., has no infinite or NaN parts) and * <code>rhs</code> is infinite (one or both parts infinite), * {@link #ZERO} is returned.</li> * <li>If this is infinite and <code>rhs</code> is finite, NaN values are * returned in the parts of the result if the {@link java.lang.Double} * rules applied to the definitional formula force NaN results.</li> * </ul></p> * * @param rhs the other complex number * @return the complex number quotient * @throws NullArgumentException if <code>rhs</code> is null */ if (isNaN || rhs.isNaN) { return NaN;} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());} public org.apache.commons.math.complex.Complex conjugate() { if (isNaN) { return org.apache.commons.math.complex.Complex.NaN;} return createComplex(real, -imaginary);} public org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws org.apache.commons.math.exception.NullArgumentException { org.apache.commons.math.util.MathUtils.checkNotNull(rhs); if (isNaN || rhs.isNaN) { return org.apache.commons.math.complex.Complex.NaN;} double c = rhs.getReal(); double d = rhs.getImaginary(); if (c == 0.0 && d == 0.0) { return NaN; } if (rhs.isInfinite() && !isInfinite()) { return ZERO; } if (FastMath.abs(c) < FastMath.abs(d)) { double q = c / d; double denominator = c * q + d; return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator); } else { double q = d / c; double denominator = d * q + c; return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator); } }"
      },
      {
        "DevIntention": "conjugate",
        "OrgCode": "public Complex conjugate() { if (isNaN) { return NaN; } return createComplex(real, -imaginary); }",
        "PatCode": "} return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());} public org.apache.commons.math.complex.Complex conjugate() { if (isNaN) { return org.apache.commons.math.complex.Complex.NaN;} return createComplex(real, -imaginary);} public org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws org.apache.commons.math.exception.NullArgumentException { org.apache.commons.math.util.MathUtils.checkNotNull(rhs); if (isNaN || rhs.isNaN) { return org.apache.commons.math.complex.Complex.NaN;} double c = rhs.getReal(); double d = rhs.getImaginary(); if (c == 0.0 && d == 0.0) {"
      }
    ]
  },
  {
    "PatchId": "Chart_15_jKali_patch_2990000_1202.diff",
    "BugId": "Chart_15",
    "PatchedMethods": [
      {
        "DevIntention": "draw",
        "OrgCode": "public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info) { notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); // record the chart area, if info is requested... if (info != null) { info.clear(); info.setChartArea(chartArea); } // ensure no drawing occurs outside chart area... Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); // draw the chart background... if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } // draw the title and subtitles... Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; // draw the plot (axes and data visualisation) PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }",
        "PatCode": "public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info) { notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); // record the chart area, if info is requested... if (info != null) { info.clear(); info.setChartArea(chartArea); } // ensure no drawing occurs outside chart area... Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); // draw the chart background... if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } // draw the title and subtitles... Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; // draw the plot (axes and data visualisation) PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_4213291_142_cp121.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && !(inverted)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_jGenProg_patch_2294000_4820.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "render",
        "OrgCode": "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info) { boolean foundData = false; CategoryDataset currentDataset = getDataset(index); CategoryItemRenderer renderer = getRenderer(index); CategoryAxis domainAxis = getDomainAxisForDataset(index); ValueAxis rangeAxis = getRangeAxisForDataset(index); boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset); if (hasData && renderer != null) { foundData = true; CategoryItemRendererState state = renderer.initialise(g2, dataArea, this, index, info); int columnCount = currentDataset.getColumnCount(); int rowCount = currentDataset.getRowCount(); int passCount = renderer.getPassCount(); for (int pass = 0; pass < passCount; pass++) { if (this.columnRenderingOrder == SortOrder.ASCENDING) { for (int column = 0; column < columnCount; column++) { if (this.rowRenderingOrder == SortOrder.ASCENDING) { for (int row = 0; row < rowCount; row++) { renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass); } } else { for (int row = rowCount - 1; row >= 0; row--) { renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass); } } } } else { for (int column = columnCount - 1; column >= 0; column--) { if (this.rowRenderingOrder == SortOrder.ASCENDING) { for (int row = 0; row < rowCount; row++) { renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass); } } else { for (int row = rowCount - 1; row >= 0; row--) { renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass); } } } } } } return foundData; }",
        "PatCode": "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info) { boolean foundData = false; CategoryDataset currentDataset = getDataset(index); CategoryItemRenderer renderer = getRenderer(index); CategoryAxis domainAxis = getDomainAxisForDataset(index); ValueAxis rangeAxis = getRangeAxisForDataset(index); boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset); if (hasData && renderer != null) { foundData = true; CategoryItemRendererState state = renderer.initialise(g2, dataArea, this, index, info); int columnCount = currentDataset.getColumnCount(); int rowCount = currentDataset.getRowCount(); int passCount = renderer.getPassCount(); for (int pass = 0; pass < passCount; pass++) { if (this.columnRenderingOrder == SortOrder.ASCENDING) { } else { for (int column = columnCount - 1; column >= 0; column--) { if (this.rowRenderingOrder == SortOrder.ASCENDING) { for (int row = 0; row < rowCount; row++) { renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass); } } else { for (int row = rowCount - 1; row >= 0; row--) { renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass); } } } } } } return foundData; }"
      }
    ]
  },
  {
    "PatchId": "Math_81_Nopol_patch_26599_3.diff",
    "BugId": "Math_81",
    "PatchedMethods": [
      {
        "DevIntention": "compute|shift|increment",
        "OrgCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }",
        "PatCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { a2 = 0.0; } if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }"
      }
    ]
  },
  {
    "PatchId": "Math_95_TBar_Patch_206408_49_cp25.diff",
    "BugId": "Math_95",
    "PatchedMethods": [
      {
        "DevIntention": "get|initial|domain",
        "OrgCode": "protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); return ret; }",
        "PatCode": "protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d + 2.0); return ret; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_Nopol_patch_23587_1.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } if ((org.apache.commons.lang.math.NumberUtils.DOUBLE_MINUS_ONE) != (expPos)) { throw new NumberFormatException(str + \" is not a valid number.\"); } case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236226_16.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions())) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_771272_118_cp66.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((!Character.isDigit(lastChar))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_62_TBar_Patch_1119328_134_cp68.diff",
    "BugId": "Math_62",
    "PatchedMethods": [
      {
        "DevIntention": "optimize",
        "OrgCode": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException { optima = new UnivariateRealPointValuePair[starts]; totalEvaluations = 0; // Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { optima[i] = null; } final int usedEvaluations = optimizer.getEvaluations(); optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations); totalEvaluations += usedEvaluations; } sortPairs(goal); if (optima[0] == null) { throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts); } // Return the point with the best objective function value. return optima[0]; }",
        "PatCode": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException { optima = new UnivariateRealPointValuePair[starts]; totalEvaluations = 0; // Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { optima[i] = null; } final int usedEvaluations = optimizer.getEvaluations(); optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations); totalEvaluations += usedEvaluations; } sortPairs(goal); if (optima[0] == null) { throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts); } // Return the point with the best objective function value. return optima[0]; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_1509052_56_cp40.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.nextAfter(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_Avatar_Patch_2210114_1043.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_82_jGenProg_patch_2510000_10256.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|column",
        "OrgCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } } return minPos; }",
        "PatCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { /** * Returns the row with the minimum ratio as given by the minimum ratio test (MRT). * @param tableau simple tableau for the problem * @param col the column to test the ratio of. See {@link #getPivotColumn(SimplexTableau)} * @return row with the minimum ratio */ /** * Runs one iteration of the Simplex method on the given model. * @param tableau simple tableau for the problem * @throws OptimizationException if the maximal iteration count has been * exceeded or if the model is found not to have a bounded solutionf = f; minPos = i;}} return minPos;} private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) { double minRatio = java.lang.Double.MAX_VALUE; java.lang.Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i;}}} return minRatioPos;}"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17088073_893.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "optimize",
        "OrgCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }",
        "PatCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; if (this.linearConstraints == null) { return null;}this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_18773_3_cp1.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18007210_915.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, this.numDecisionVariables, src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_69_Nopol_patch_16126_3.diff",
    "BugId": "Math_69",
    "PatchedMethods": [
      {
        "DevIntention": "compute|correlation|matrix",
        "OrgCode": "public RealMatrix computeCorrelationMatrix(RealMatrix matrix) { int nVars = matrix.getColumnDimension(); RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars); for (int i = 0; i < nVars; i++) { for (int j = 0; j < i; j++) { double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); outMatrix.setEntry(i, j, corr); outMatrix.setEntry(j, i, corr); } outMatrix.setEntry(i, i, 1d); } return outMatrix; }",
        "PatCode": "public RealMatrix computeCorrelationMatrix(RealMatrix matrix) { int nVars = matrix.getColumnDimension(); RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars); if ((nVars) != (2)) { for (int i = 0; i < nVars; i++) { for (int j = 0; j < i; j++) { double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); outMatrix.setEntry(i, j, corr); outMatrix.setEntry(j, i, corr); } outMatrix.setEntry(i, i, 1d); } } return outMatrix; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_9947423_963_cp649.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k>4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Mockito_29_Avatar_Patch_643309_75.diff",
    "BugId": "Mockito_29",
    "PatchedMethods": [
      {
        "DevIntention": "describe|to",
        "OrgCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); description.appendText(wanted.toString()); appendQuoting(description); description.appendText(\")\"); }",
        "PatCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); if (wanted == null) { return;}description.appendText(wanted.toString()); appendQuoting(description); description.appendText(\")\"); }"
      }
    ]
  },
  {
    "PatchId": "Math_15_TBar_Patch_4576042_106_cp99.diff",
    "BugId": "Math_15",
    "PatchedMethods": [
      {
        "DevIntention": "pow",
        "OrgCode": "public static double pow(double x, double y) { final double lns[] = new double[2]; if (y == 0.0) { return 1.0; } if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { // -zero long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY; } if (y > 0) { return 0.0; } return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; } return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY; } } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } /* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { return pow(-x, y); } if (y == (long) y) { // If y is an integer return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } } /* Split y into ya and yb such that y = ya+yb */ double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } /* Compute ln(x) */ final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } double lna = lns[0]; double lnb = lns[1]; /* resplit lns */ double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; // y*ln(x) = (aa+ab) final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); //result = result + result * z; return result; }",
        "PatCode": "public static double pow(double x, double y) { final double lns[] = new double[2]; if (y == 0.0) { return 1.0; } if (x != x) { // X is NaN return x; } if (x == 0) { long bits = Double.doubleToLongBits(x); if ((bits & 0x8000000000000000L) != 0) { // -zero long yi = (long) y; if (y < 0 && y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } if (y > 0 && y == yi && (yi & 1) == 1) { return -0.0; } } if (y < 0) { return Double.POSITIVE_INFINITY; } if (y > 0) { return 0.0; } return Double.NaN; } if (x == Double.POSITIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0.0) { return 0.0; } else { return Double.POSITIVE_INFINITY; } } if (y == Double.POSITIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x > 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } if (x == Double.NEGATIVE_INFINITY) { if (y != y) { // y is NaN return y; } if (y < 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return -0.0; } return 0.0; } if (y > 0) { long yi = (long) y; if (y == yi && (yi & 1) == 1) { return Double.NEGATIVE_INFINITY; } return Double.POSITIVE_INFINITY; } } if (y == Double.NEGATIVE_INFINITY) { if (x * x == 1.0) { return Double.NaN; } if (x * x < 1.0) { return Double.POSITIVE_INFINITY; } else { return 0.0; } } /* Handle special case x<0 */ if (x < 0) { // y is an even integer in this case if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) { return pow(-x, y); } if (y == (long) y) { // If y is an integer return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y); } else { return Double.NaN; } } /* Split y into ya and yb such that y = ya+yb */ double ya; double yb; if (y < 8e298 && y > -8e298) { double tmp1 = y * HEX_40000000; ya = y + tmp1 - tmp1; yb = y - ya; } else { double tmp1 = y * 9.31322574615478515625E-10; double tmp2 = tmp1 * 9.31322574615478515625E-10; ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000; yb = y - ya; } /* Compute ln(x) */ final double lores = log(x, lns); if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN return lores; } double lna = lns[0]; double lnb = lns[1]; /* resplit lns */ double tmp1 = lna * HEX_40000000; double tmp2 = lna + tmp1 - tmp1; lnb += lna - tmp2; lna = tmp2; // y*ln(x) = (aa+ab) final double aa = lna * ya; final double ab = lna * yb + lnb * ya + lnb * yb; lna = aa+ab; lnb = -(lna - aa - ab); double z = 1.0 / 120.0; z = z * lnb + (1.0 / 24.0); z = z * lnb + (1.0 / 6.0); z = z * lnb + 0.5; z = z * lnb + 1.0; z = z * lnb; final double result = exp(lna, z, null); //result = result + result * z; return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18185554_926.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 1, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_Avatar_Patch_253348_2.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(tryBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18357668_931.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, this.numArtificialVariables, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Avatar_Patch_105394_2.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jGenProg_patch_20842000_28322.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "illegal|state|exception",
        "OrgCode": "RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { super(registry, null, null); setPrettyPrint(true); for (String property : properties.keySet()) { RecordProperty prop = properties.get(property); if (prop == null) { throw new IllegalStateException( \"RecordProperty associated with a property should not be null!\"); } defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode()); } // Freeze the record type. isFrozen = true; } @Override public boolean isEquivalentTo(JSType other) { if (!other.isRecordType()) { return false; } // Compare properties. RecordType otherRecord = other.toMaybeRecordType(); if (otherRecord == this) { return true; } Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { return false; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { return false; } } return true; } @Override public ObjectType getImplicitPrototype() { return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); } @Override boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); } @Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); } JSType getGreatestSubtypeHelper(JSType that) { if (that.isRecordType()) { RecordType thatRecord = that.toMaybeRecordType(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type // is returned. for (String property : properties.keySet()) { if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return registry.getNativeObjectType(JSTypeNative.NO_TYPE); } builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } for (String property : thatRecord.properties.keySet()) { if (!hasProperty(property)) { builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property)); } } return builder.build(); } JSType greatestSubtype = registry.getNativeType( JSTypeNative.NO_OBJECT_TYPE); JSType thatRestrictedToObj = registry.getNativeType(JSTypeNative.OBJECT_TYPE) .getGreatestSubtype(that); if (!thatRestrictedToObj.isEmptyType()) { // In this branch, the other type is some object type. We find // the greatest subtype with the following algorithm: // 1) For each property \"x\" of this record type, take the union // of all classes with a property \"x\" with a compatible property type. // and which are a subtype of {@code that}. // 2) Take the intersection of all of these unions. for (Map.Entry<String, JSType> entry : properties.entrySet()) { String propName = entry.getKey(); JSType propType = entry.getValue(); UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { JSType altPropType = alt.getPropertyType(propName); if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) { builder.addAlternate(alt); } } greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); } } return greatestSubtype; } @Override RecordType toMaybeRecordType() { return this; } @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true; } // Top of the record types is the empty record, or OBJECT_TYPE. if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } // A type is a subtype of a record type if it itself is a record // type and it has at least the same members as the parent record type // with the same types. if (!that.isRecordType()) { return false; } return RecordType.isSubtype(this, that.toMaybeRecordType()); }",
        "PatCode": "RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) { super(registry, null, null); setPrettyPrint(true); for (String property : properties.keySet()) { RecordProperty prop = properties.get(property); if (prop == null) { throw new IllegalStateException( \"RecordProperty associated with a property should not be null!\"); } defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode()); } // Freeze the record type. isFrozen = true; } @Override public boolean isEquivalentTo(JSType other) { if (!other.isRecordType()) { return false; } // Compare properties. RecordType otherRecord = other.toMaybeRecordType(); if (otherRecord == this) { return true; } Set<String> keySet = properties.keySet(); Map<String, JSType> otherProps = otherRecord.properties; if (!otherProps.keySet().equals(keySet)) { return false; } for (String key : keySet) { if (!otherProps.get(key).isEquivalentTo(properties.get(key))) { return false; } } return true; } @Override public ObjectType getImplicitPrototype() { return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE); } @Override boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode) { if (isFrozen) { return false; } if (!inferred) { properties.put(propertyName, type); } return super.defineProperty(propertyName, type, inferred, propertyNode); } @Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } // The greatest subtype consists of those *unique* properties of both // record types. If any property conflicts, then the NO_TYPE type // is returned. // In this branch, the other type is some object type. We find // the greatest subtype with the following algorithm: // 1) For each property \"x\" of this record type, take the union // of all classes with a property \"x\" with a compatible property type. // and which are a subtype of {@code that}. // 2) Take the intersection of all of these unions. // Top of the record types is the empty record, or OBJECT_TYPE. // A type is a subtype of a record type if it itself is a record // type and it has at least the same members as the parent record type // with the same types."
      }
    ]
  },
  {
    "PatchId": "Math_50_TBar_Patch_232465_13_cp7.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(fx); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_21_TBar_Patch_11078322_202_cp181.diff",
    "BugId": "Closure_21",
    "PatchedMethods": [
      {
        "DevIntention": "visit",
        "OrgCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }",
        "PatCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_13_TBar_Patch_6731471_904_cp457.diff",
    "BugId": "Chart_13",
    "PatchedMethods": [
      {
        "DevIntention": "arrange|f|f",
        "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }",
        "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getHeight() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_1610258_59_cp43.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.IEEEremainder(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_12_SimFix_patch_78615_1.diff",
    "BugId": "Chart_12",
    "PatchedMethods": [
      {
        "DevIntention": "multiple|pie|plot",
        "OrgCode": "public MultiplePiePlot(CategoryDataset dataset) { super(); this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); }",
        "PatCode": "public MultiplePiePlot(CategoryDataset dataset) { super();// start of generated patchif(dataset!=null){dataset.addChangeListener(this);}this.dataset=dataset;PiePlot piePlot=new PiePlot(null);this.pieChart=new JFreeChart(piePlot);// end of generated patch/* start of original code this.dataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); end of original code*/ this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_SimFix_patch_359541_1.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); // start of generated patchif(fa*upperBound>=0.0){throw new ConvergenceException(\"number of iterations={0}, maximum iterations={1}, \"+\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb);}// end of generated patch/* start of original code if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } end of original code*/ return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_88_jMutRepair_patch_26000_65.diff",
    "BugId": "Math_88",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { double rhs = tableau.getEntry(i, tableau.getWidth() - 1); if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) { double ratio = rhs / tableau.getEntry(i, col); if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { double rhs = tableau.getEntry(i, tableau.getWidth() - 1); if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) { double ratio = rhs / tableau.getEntry(i, col);if (ratio <= minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_FixMiner_Patch_107394_21.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { if (cAvailableLocaleSet == null) { return true;}return cAvailableLocaleSet.contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1547580_303_cp150.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_13869510_2576_cp1250.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (entry > DEFAULT_EPSILON && (MathUtils.compareTo(entry, 0, epsilon) >= 0)) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_8782809_1062_cp782.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxStartIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_SimFix_patch_29201_2.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' :// start of generated patchif(dec==null&&exp==null&&(numeric.charAt(0)=='-'||Character.isDigit(numeric.charAt(0)))){try{return createLong(numeric);}catch (NumberFormatException nfe) {}return createBigInteger(numeric);}// end of generated patch/* start of original code if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } end of original code*/ throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_961688_30_cp24.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), f1)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252118_1.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if ((this.getOriginalNumDecisionVariables() - 1) == 1) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Chart_13_jKali_patch_38000_121.diff",
    "BugId": "Chart_13",
    "PatchedMethods": [
      {
        "DevIntention": "arrange|f|f",
        "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }",
        "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0];if (false) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17833553_911.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "get|original|num|decision|variables",
        "OrgCode": "protected final int getOriginalNumDecisionVariables() { return f.getCoefficients().getDimension(); }",
        "PatCode": "protected final int getOriginalNumDecisionVariables() { if (f == null) { throw new IllegalArgumentException(\"Null 'f' argument.\");}return f.getCoefficients().getDimension(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_FixMiner_Patch_61483_7.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_Avatar_Patch_3850336_660.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Nopol_patch_217308_1.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (-1 == x1) { if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_13_jGenProg_patch_681000_312.diff",
    "BugId": "Closure_13",
    "PatchedMethods": [
      {
        "DevIntention": "get|compiler",
        "OrgCode": "PeepholeOptimizationsPass(AbstractCompiler compiler, AbstractPeepholeOptimization... optimizations) { this.compiler = compiler; this.peepholeOptimizations = optimizations; } public AbstractCompiler getCompiler() { return compiler; } @Override public void process(Node externs, Node root) { PeepholeChangeHandler handler = new PeepholeChangeHandler(); compiler.addChangeHandler(handler); beginTraversal(); traverse(root); endTraversal(); compiler.removeChangeHandler(handler); } private void traverse(Node node) { // The goal here is to avoid retraversing // the entire AST to catch newly created opportunities. // So we track whether a \"unit of code\" has changed, // and revisit immediately. if (!shouldVisit(node)) { return; } int visits = 0; do { Node c = node.getFirstChild(); while(c != null) { traverse(c); Node next = c.getNext(); c = next; } visit(node); visits++; Preconditions.checkState(visits < 10000, \"too many interations\"); } while (shouldRetraverse(node)); exitNode(node); } private boolean shouldRetraverse(Node node) { if (node.getParent() != null && node.isFunction() || node.isScript()) { ScopeState state = traversalState.peek(); if (state.changed) { // prepare to re-visit the scope: // when revisiting, only visit the immediate scope // this reduces the cost of getting to a fixed // point in global scope. state.changed = false; state.traverseChildScopes = false; return true; } } return false; } private boolean shouldVisit(Node node) { if (node.isFunction() || node.isScript()) { ScopeState previous = traversalState.peek(); if (!previous.traverseChildScopes) { return false; } traversalState.push(); } return true; } private void exitNode(Node node) { if (node.isFunction() || node.isScript()) { traversalState.pop(); } } public void visit(Node n) { Node currentVersionOfNode = n; boolean somethingChanged = false; do { somethingChanged = false; for (AbstractPeepholeOptimization optimization : peepholeOptimizations) { Node newVersionOfNode = optimization.optimizeSubtree(currentVersionOfNode); if (newVersionOfNode != currentVersionOfNode) { somethingChanged = true; currentVersionOfNode = newVersionOfNode; } if (currentVersionOfNode == null) { return; } } } while(somethingChanged); }",
        "PatCode": "PeepholeOptimizationsPass(AbstractCompiler compiler, AbstractPeepholeOptimization... optimizations) { this.compiler = compiler; this.peepholeOptimizations = optimizations; } public AbstractCompiler getCompiler() { return compiler; } @Override public void process(Node externs, Node root) { PeepholeChangeHandler handler = new PeepholeChangeHandler(); compiler.addChangeHandler(handler); beginTraversal(); traverse(root); endTraversal(); compiler.removeChangeHandler(handler); } private void traverse(Node node) { // The goal here is to avoid retraversing // the entire AST to catch newly created opportunities. // So we track whether a \"unit of code\" has changed, // and revisit immediately. if (!shouldVisit(node)) { } int visits = 0; do { Node c = node.getFirstChild(); while(c != null) { traverse(c); Node next = c.getNext(); c = next; } visit(node); visits++; Preconditions.checkState(visits < 10000, \"too many interations\"); } while (shouldRetraverse(node)); exitNode(node); } private boolean shouldRetraverse(Node node) { if (node.getParent() != null && node.isFunction() || node.isScript()) { ScopeState state = traversalState.peek(); if (state.changed) { // prepare to re-visit the scope: // when revisiting, only visit the immediate scope // this reduces the cost of getting to a fixed // point in global scope. state.changed = false; state.traverseChildScopes = false; return true; } } return false; } private boolean shouldVisit(Node node) { if (node.isFunction() || node.isScript()) { ScopeState previous = traversalState.peek(); if (!previous.traverseChildScopes) { return false; } traversalState.push(); } return true; } private void exitNode(Node node) { if (node.isFunction() || node.isScript()) { traversalState.pop(); } } public void visit(Node n) { Node currentVersionOfNode = n; boolean somethingChanged = false; do { somethingChanged = false; for (AbstractPeepholeOptimization optimization : peepholeOptimizations) { Node newVersionOfNode = optimization.optimizeSubtree(currentVersionOfNode); if (newVersionOfNode != currentVersionOfNode) { somethingChanged = true; currentVersionOfNode = newVersionOfNode; } if (currentVersionOfNode == null) { return; } } } while(somethingChanged); }"
      }
    ]
  },
  {
    "PatchId": "Math_28_FixMiner_Patch_12408681_105.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_97063_5.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { if ((param[0] <= 0) && (param[0] != 1)) { throw new NotStrictlyPositiveException(param[2]); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_Nopol_patch_19291_2.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (str!=null) { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_TBar_Patch_317345_16_cp10.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(rtol); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_61000_48.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1;for (int i = 0; i < j; i += 4) j -= 4; return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236232_18.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getArtificialVariableOffset())) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_dynamoth_patch_120645_1.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { if (false) { return result; } } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_jKali_patch_65000_22.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); }if (true)return; /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10489751_1066_cp707.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 / n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9647746_1030_cp790.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa >= upperBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_28_jMutRepair_patch_0_2.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) {if (row != tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_1047811_7828.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {if (width > 0) { buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY]; ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2244947_280_cp200.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17174791_895.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "optimize",
        "OrgCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }",
        "PatCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; if (constraints == null) { throw new IllegalArgumentException(\"Null 'constraints' argument.\");}this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_jGenProg_patch_4568000_10558.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "assert|type|equals",
        "OrgCode": "public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); }",
        "PatCode": "public static void assertTypeEquals(JSType a, JSType b) { /** * For the given equivalent types, run all type operations that * should have trivial solutions (getGreatestSubtype, isEquivalentTo, etc) */junit.framework.Assert.assertTrue(b.isEquivalentTo(b));} public static void assertTypeEquals(java.lang.String message, com.google.javascript.rhino.jstype.JSType a, com.google.javascript.rhino.jstype.JSType b) { junit.framework.Assert.assertTrue((((((message + (message.isEmpty() ? \"\" : \"\\n\")) + \"Expected: \") + a) + \"\\n\") + \"Actual : \") + b, a.isEquivalentTo(b)); junit.framework.Assert.assertTrue((((((message + \" Equals is not symmetric.\\n\") + \"Expected: \") + b) + \"\\n\") + \"Actual : \") + a, b.isEquivalentTo(a));} public static void assertEquivalenceOperations(com.google.javascript.rhino.jstype.JSType a, com.google.javascript.rhino.jstype.JSType b) { junit.framework.Assert.assertTrue(a.isEquivalentTo(b)); junit.framework.Assert.assertTrue(a.isEquivalentTo(a)); junit.framework.Assert.assertTrue(b.isEquivalentTo(b)); Assert.assertTrue(b.isEquivalentTo(a)); Assert.assertTrue(a.isSubtype(b)); Assert.assertTrue(a.isSubtype(a)); Assert.assertTrue(b.isSubtype(b)); Assert.assertTrue(b.isSubtype(a)); assertTypeEquals(a, a.getGreatestSubtype(b)); assertTypeEquals(a, a.getGreatestSubtype(a)); assertTypeEquals(a, b.getGreatestSubtype(b)); assertTypeEquals(a, b.getGreatestSubtype(a)); assertTypeEquals(a, a.getLeastSupertype(b)); assertTypeEquals(a, a.getLeastSupertype(a)); assertTypeEquals(a, b.getLeastSupertype(b)); assertTypeEquals(a, b.getLeastSupertype(a)); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_1891979_240_cp168.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_19460_8.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if ((org.jfree.data.time.TimeSeries.this.data.size() == 2) || (!((startIndex) != (org.jfree.data.time.TimeSeries.this.data.size())))) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_63_kPAR_Patch_35024_1_cp1.diff",
    "BugId": "Lang_63",
    "PatchedMethods": [
      {
        "DevIntention": "reduce|and|correct",
        "OrgCode": "static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } }",
        "PatCode": "static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( newdiff, newdiff ); return newdiff; } else { return 0; } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_SimFix_patch_1432931_2.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } // start of generated patchif(this.maxMiddleIndex>=0){long s=getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime();long e=getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime();long maxMiddle=s+(e-s)/2;if(middle>maxMiddle){this.maxMiddleIndex=index;}}else {this.maxMiddleIndex=index;}// end of generated patch/* start of original code if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } end of original code*/ if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_kPAR_Patch_2800171_379_cp193.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_432459_3432.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length();if (strLen >= width) { ensureCapacity(size + 5); str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_Nopol_patch_39174_1.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (com.google.javascript.jscomp.LightweightMessageFormatter.excerptFormatter!=null) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9834491_1052_cp812.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb > a && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_9020748_821_cp546.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19184115_958.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), this.numArtificialVariables); }"
      }
    ]
  },
  {
    "PatchId": "Mockito_29_TBar_Patch_926897_102_cp47.diff",
    "BugId": "Mockito_29",
    "PatchedMethods": [
      {
        "DevIntention": "describe|to",
        "OrgCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); description.appendText(wanted.toString()); appendQuoting(description); description.appendText(\")\"); }",
        "PatCode": "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); if (wanted == null) { return;}description.appendText(wanted.toString()); appendQuoting(description); description.appendText(\")\"); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_252922_3_cp3.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(rtol); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jMutRepair_patch_240000_394.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) {if ((1.5 * work[pingPong]) == work[(4 * (n - 1)) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_450000_560.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) {if (true)return false; // flip array return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_Avatar_Patch_2221332_1046.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * this.tType - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_611560_72_cp5.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "optimize",
        "OrgCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }",
        "PatCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; if (this.goal == null) { throw new IllegalArgumentException(\"Null 'this.goal' argument.\");}this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }"
      }
    ]
  },
  {
    "PatchId": "Lang_45_TBar_Patch_3250052_325_cp293.diff",
    "BugId": "Lang_45",
    "PatchedMethods": [
      {
        "DevIntention": "abbreviate",
        "OrgCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) { // initial parameter checks if (str == null) { return null; } if (str.length() == 0) { return StringUtils.EMPTY; } // if the lower value is greater than the length of the string, // set to the length of the string // if the upper value is -1 (i.e. no limit) or is greater // than the length of the string, set to the length of the string if (upper == -1 || upper > str.length()) { upper = str.length(); } // if upper is less than lower, raise it to lower if (upper < lower) { upper = lower; } StringBuffer result = new StringBuffer(); int index = StringUtils.indexOf(str, \" \", lower); if (index == -1) { result.append(str.substring(0, upper)); // only if abbreviation has occured do we append the appendToEnd value if (upper != str.length()) { result.append(StringUtils.defaultString(appendToEnd)); } } else if (index > upper) { result.append(str.substring(0, upper)); result.append(StringUtils.defaultString(appendToEnd)); } else { result.append(str.substring(0, index)); result.append(StringUtils.defaultString(appendToEnd)); } return result.toString(); }",
        "PatCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) { // initial parameter checks if (str == null) { return null; } if (str.length() == 0) { return StringUtils.EMPTY; } // if the lower value is greater than the length of the string, // set to the length of the string // if the upper value is -1 (i.e. no limit) or is greater // than the length of the string, set to the length of the string if (upper == -1 || upper > str.length()) { upper = str.length(); } // if upper is less than lower, raise it to lower if ((upper < lower) && (upper != str.length())) { upper = lower; } StringBuffer result = new StringBuffer(); int index = StringUtils.indexOf(str, \" \", lower); if (index == -1) { result.append(str.substring(0, upper)); // only if abbreviation has occured do we append the appendToEnd value if (upper != str.length()) { result.append(StringUtils.defaultString(appendToEnd)); } } else if (index > upper) { result.append(str.substring(0, upper)); result.append(StringUtils.defaultString(appendToEnd)); } else { result.append(str.substring(0, index)); result.append(StringUtils.defaultString(appendToEnd)); } return result.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Closure_21_TBar_Patch_10959362_200_cp179.diff",
    "BugId": "Closure_21",
    "PatchedMethods": [
      {
        "DevIntention": "visit",
        "OrgCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }",
        "PatCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_TBar_Patch_3684579_439_cp345.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch<='y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_4415206_148_cp127.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((x == x1) && (f1 >= 0)) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_kPAR_Patch_2772780_377_cp191.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxStartIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_Avatar_Patch_675649_138.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null || isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9270426_982_cp742.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa >= b && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Closure_129_jKali_patch_3000_4.diff",
    "BugId": "Closure_129",
    "PatchedMethods": [
      {
        "DevIntention": "is|equivalent|to",
        "OrgCode": "boolean isEquivalentTo( Node node, boolean compareJsType, boolean recur, boolean shallow) { if (type != node.getType() || getChildCount() != node.getChildCount() || this.getClass() != node.getClass()) { return false; } if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) { return false; } if (type == Token.INC || type == Token.DEC) { int post1 = this.getIntProp(INCRDECR_PROP); int post2 = node.getIntProp(INCRDECR_PROP); if (post1 != post2) { return false; } } else if (type == Token.STRING || type == Token.STRING_KEY) { if (type == Token.STRING_KEY) { int quoted1 = this.getIntProp(QUOTED_PROP); int quoted2 = node.getIntProp(QUOTED_PROP); if (quoted1 != quoted2) { return false; } } int slashV1 = this.getIntProp(SLASH_V); int slashV2 = node.getIntProp(SLASH_V); if (slashV1 != slashV2) { return false; } } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { return false; } } if (recur) { Node n, n2; for (n = first, n2 = node.first; n != null; n = n.next, n2 = n2.next) { if (!n.isEquivalentTo( n2, compareJsType, !(shallow && n.isFunction()), shallow)) { return false; } } } return true; }",
        "PatCode": "boolean isEquivalentTo( Node node, boolean compareJsType, boolean recur, boolean shallow) { if (type != node.getType() || getChildCount() != node.getChildCount() || this.getClass() != node.getClass()) { return false; } if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) { return false; } if (type == Token.INC || type == Token.DEC) { int post1 = this.getIntProp(INCRDECR_PROP); int post2 = node.getIntProp(INCRDECR_PROP); if (post1 != post2) { return false; } } else if (type == Token.STRING || type == Token.STRING_KEY) { if (type == Token.STRING_KEY) { int quoted1 = this.getIntProp(QUOTED_PROP); int quoted2 = node.getIntProp(QUOTED_PROP); if (quoted1 != quoted2) { return false; } } int slashV1 = this.getIntProp(SLASH_V); int slashV2 = node.getIntProp(SLASH_V); if (slashV1 != slashV2) { return false; } } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { } } if (recur) { Node n, n2; for (n = first, n2 = node.first; n != null; n = n.next, n2 = n2.next) { if (!n.isEquivalentTo( n2, compareJsType, !(shallow && n.isFunction()), shallow)) { return false; } } } return true; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_Avatar_Patch_3836423_659.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxStartIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_70_jGenProg_patch_23000_206.diff",
    "BugId": "Math_70",
    "PatchedMethods": [
      {
        "DevIntention": "solve",
        "OrgCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { return solve(min, max); }",
        "PatCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17044720_892.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "optimize",
        "OrgCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }",
        "PatCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; if (this.linearConstraints == null) { throw new IllegalArgumentException(\"Null 'this.linearConstraints' argument.\");}this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }"
      }
    ]
  },
  {
    "PatchId": "Math_8_TBar_Patch_581724_16_cp7.diff",
    "BugId": "Math_8",
    "PatchedMethods": [
      {
        "DevIntention": "sample",
        "OrgCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i < sampleSize; i++) { out[i] = sample(); } return out; }",
        "PatCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i==sampleSize; i++) { out[i] = sample(); } return out; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_10037016_1076_cp836.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb > lowerBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9679675_1034_cp794.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb == b && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2331840_288_cp208.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str == null)) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_13_Nopol_patch_38818_4.diff",
    "BugId": "Chart_13",
    "PatchedMethods": [
      {
        "DevIntention": "arrange|f|f",
        "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }",
        "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; if (null!=null) { if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }"
      }
    ]
  },
  {
    "PatchId": "Math_30_TBar_Patch_1978181_117_cp53.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * ((n1 + n2 + 1) / 12.0); final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_1475296_55_cp39.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.atan2(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10450260_1055_cp703.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * this.pingPong - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_SimFix_patch_3689113_2.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line// start of generated patchif(excerpt.equals(LINE)&&0<=charno&&charno-charno<sourceExcerpt.length()){for(int i=0;i<charno;i++){char c=sourceExcerpt.charAt(i);if(Character.isWhitespace(c)){b.append(c);}else {b.append(' ');}}b.append(\"^\\n\");}// end of generated patch/* start of original code if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } end of original code*/ } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_71_dynamoth_patch_414468_3.diff",
    "BugId": "Math_71",
    "PatchedMethods": [
      {
        "DevIntention": "set|initial|step|size",
        "OrgCode": "public void setInitialStepSize(final double initialStepSize) { if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { initialStep = -1.0; } else { initialStep = initialStepSize; } }",
        "PatCode": "public void setInitialStepSize(final double initialStepSize) { if (false) { if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { initialStep = -1.0; } else { initialStep = initialStepSize; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_jGenProg_patch_989000_276.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.if (x == x1) f0 = computeObjectiveValue(x0); break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_91000_53.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_9012095_820_cp545.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[j - k] = tmp;work[i + k] = work[j - k]; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_6595602_823_cp583.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = getMaxStartIndex(); } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_1174034_85_cp18.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "optimize",
        "OrgCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }",
        "PatCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics if (this.function == null) { return null;}this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9349697_992_cp752.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa > a && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Chart_26_jKali_patch_325000_270.diff",
    "BugId": "Chart_26",
    "PatchedMethods": [
      {
        "DevIntention": "draw",
        "OrgCode": "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { // if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; } // record the plot area... if (state == null) { // if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes state = new PlotRenderingInfo(null); } state.setPlotArea(area); // adjust the drawing area for the plot insets (if any)... RectangleInsets insets = getInsets(); insets.trim(area); // calculate the data area... AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); // if there is a renderer, it draws the background, otherwise use the // default background... if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); // don't let anyone draw outside the data area Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates() .get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } // draw the markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } // now render data items... boolean foundData = false; // set up the alpha-transparency... Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { for (int i = 0; i < this.datasets.size(); i++) { foundData = render(g2, dataArea, i, state) || foundData; } } else { // DatasetRenderingOrder.REVERSE for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } } // draw the foreground markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } // draw the annotations (if any)... drawAnnotations(g2, dataArea); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } // draw range crosshair if required... if (isRangeCrosshairVisible()) { // FIXME: this doesn't handle multiple range axes drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } // draw an outline around the plot area... if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } }",
        "PatCode": "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { // if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);if (true) { return; } // record the plot area... if (state == null) { // if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes state = new PlotRenderingInfo(null); } state.setPlotArea(area); // adjust the drawing area for the plot insets (if any)... RectangleInsets insets = getInsets(); insets.trim(area); // calculate the data area... AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); // if there is a renderer, it draws the background, otherwise use the // default background... if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); // don't let anyone draw outside the data area Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates() .get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } // draw the markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } // now render data items... boolean foundData = false; // set up the alpha-transparency... Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { for (int i = 0; i < this.datasets.size(); i++) { foundData = render(g2, dataArea, i, state) || foundData; } } else { // DatasetRenderingOrder.REVERSE for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } } // draw the foreground markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } // draw the annotations (if any)... drawAnnotations(g2, dataArea); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } // draw range crosshair if required... if (isRangeCrosshairVisible()) { // FIXME: this doesn't handle multiple range axes drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } // draw an outline around the plot area... if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_554857_4312.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString());int strLen = str.length(); buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY]; if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_41_dynamoth_patch_1125429_153.diff",
    "BugId": "Math_41",
    "PatchedMethods": [
      {
        "DevIntention": "evaluate",
        "OrgCode": "public double evaluate(final double[] values, final double[] weights, final int begin, final int length) { if (test(values, weights, begin, length)) { Sum sum = new Sum(); // Compute initial estimate using definitional formula double sumw = sum.evaluate(weights,begin,length); double xbarw = sum.evaluate(values, weights, begin, length) / sumw; // Compute correction factor in second pass double correction = 0; for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } return xbarw + (correction/sumw); } return Double.NaN; }",
        "PatCode": "public double evaluate(final double[] values, final double[] weights, final int begin, final int length) { if (test(values, weights, begin, length)) { Sum sum = new Sum(); // Compute initial estimate using definitional formula double sumw = sum.evaluate(weights,begin,length); double xbarw = sum.evaluate(values, weights, begin, length) / sumw; // Compute correction factor in second pass double correction = 0; for (int i = begin; i < begin + length; i++) { correction += weights[i] * (values[i] - xbarw); } if (xbarw < length) { return xbarw + (correction/sumw); } } return Double.NaN; }"
      }
    ]
  },
  {
    "PatchId": "Lang_46_Nopol_patch_17983_1.diff",
    "BugId": "Lang_46",
    "PatchedMethods": [
      {
        "DevIntention": "escape|java|style|string",
        "OrgCode": "private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (str == null) { return; } int sz; sz = str.length(); for (int i = 0; i < sz; i++) { char ch = str.charAt(i); // handle unicode if (ch > 0xfff) { out.write(\"\\\\u\" + hex(ch)); } else if (ch > 0xff) { out.write(\"\\\\u0\" + hex(ch)); } else if (ch > 0x7f) { out.write(\"\\\\u00\" + hex(ch)); } else if (ch < 32) { switch (ch) { case '\\b' : out.write('\\\\'); out.write('b'); break; case '\\n' : out.write('\\\\'); out.write('n'); break; case '\\t' : out.write('\\\\'); out.write('t'); break; case '\\f' : out.write('\\\\'); out.write('f'); break; case '\\r' : out.write('\\\\'); out.write('r'); break; default : if (ch > 0xf) { out.write(\"\\\\u00\" + hex(ch)); } else { out.write(\"\\\\u000\" + hex(ch)); } break; } } else { switch (ch) { case '\\'' : if (escapeSingleQuote) { out.write('\\\\'); } out.write('\\''); break; case '\"' : out.write('\\\\'); out.write('\"'); break; case '\\\\' : out.write('\\\\'); out.write('\\\\'); break; case '/' : out.write('\\\\'); out.write('/'); break; default : out.write(ch); break; } } } }",
        "PatCode": "private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (str == null) { return; } int sz; sz = str.length(); for (int i = 0; i < sz; i++) { char ch = str.charAt(i); // handle unicode if (ch > 0xfff) { out.write(\"\\\\u\" + hex(ch)); } else if (ch > 0xff) { out.write(\"\\\\u0\" + hex(ch)); } else if (ch > 0x7f) { out.write(\"\\\\u00\" + hex(ch)); } else if (ch < 32) { switch (ch) { case '\\b' : out.write('\\\\'); out.write('b'); break; case '\\n' : out.write('\\\\'); out.write('n'); break; case '\\t' : out.write('\\\\'); out.write('t'); break; case '\\f' : out.write('\\\\'); out.write('f'); break; case '\\r' : out.write('\\\\'); out.write('r'); break; default : if (ch > 0xf) { out.write(\"\\\\u00\" + hex(ch)); } else { out.write(\"\\\\u000\" + hex(ch)); } break; } } else { switch (ch) { case '\\'' : if (escapeSingleQuote) { out.write('\\\\'); } out.write('\\''); break; case '\"' : out.write('\\\\'); out.write('\"'); break; case '\\\\' : out.write('\\\\'); out.write('\\\\'); break; case '/' : if (escapeSingleQuote) { out.write('\\\\'); } out.write('/'); break; default : out.write(ch); break; } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_96_TBar_Patch_2060798_592_cp261.diff",
    "BugId": "Math_96",
    "PatchedMethods": [
      {
        "DevIntention": "equals",
        "OrgCode": "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { // ignore exception ret = false; } } return ret; }",
        "PatCode": "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { // ignore exception ret = false; } } return ret; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_10258671_1113_cp862.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18229397_927.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, DEFAULT_ULPS, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_8272369_358_cp241.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) && !((f1 <= 0))) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_Avatar_Patch_830416_11.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_7475584_334_cp217.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) && !(f1 <= 0)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252146_10.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if (this.getSlackVariableOffset() == (this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions())) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Chart_15_jGenProg_patch_4062000_14800.diff",
    "BugId": "Chart_15",
    "PatchedMethods": [
      {
        "DevIntention": "draw",
        "OrgCode": "public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info) { notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); // record the chart area, if info is requested... if (info != null) { info.clear(); info.setChartArea(chartArea); } // ensure no drawing occurs outside chart area... Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); // draw the chart background... if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } // draw the title and subtitles... Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; // draw the plot (axes and data visualisation) PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }",
        "PatCode": "public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info) { notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); // record the chart area, if info is requested... if (info != null) { info.clear(); info.setChartArea(chartArea); } // ensure no drawing occurs outside chart area... Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); // draw the chart background... if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } // draw the title and subtitles... Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; // draw the plot (axes and data visualisation) PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_3009542_350_cp270.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || (expPos < str.length() - 1)) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_132005_14.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "value",
        "OrgCode": "public double value(double x, double[] param) { validateParameters(param); final double diff = x - param[1]; final double i2s2 = 1 / (2 * param[2] * param[2]); return Gaussian.value(diff, param[0], i2s2); }",
        "PatCode": "public double value(double x, double[] param) { if ((param == null) || (param[0] == x)) { validateParameters(param); } final double diff = x - param[1]; final double i2s2 = 1 / (2 * param[2] * param[2]); return Gaussian.value(diff, param[0], i2s2); }"
      }
    ]
  },
  {
    "PatchId": "Lang_51_dynamoth_patch_15045_2.diff",
    "BugId": "Lang_51",
    "PatchedMethods": [
      {
        "DevIntention": "to|boolean",
        "OrgCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "PatCode": "public static boolean toBoolean(String str) { // Previously used equalsIgnoreCase, which was fast for interned 'true'. // Non interned 'true' matched 15 times slower. // // Optimisation provides same performance as before for interned 'true'. // Similar performance for null, 'false', and other strings not length 2/3/4. // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower. if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (true) { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9772202_1044_cp804.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb != a && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_8728457_1057_cp777.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_FixMiner_Patch_69669_5.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { f0 = computeObjectiveValue(x0);x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_63_jGenProg_patch_1855942_2592.diff",
    "BugId": "Lang_63",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) { StringBuffer buffer = new StringBuffer(); boolean lastOutputSeconds = false; int sz = tokens.length; for (int i = 0; i < sz; i++) { Token token = tokens[i]; Object value = token.getValue(); int count = token.getCount(); if (value instanceof StringBuffer) { buffer.append(value.toString()); } else { if (value == y) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer .toString(years)); lastOutputSeconds = false; } else if (value == M) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer .toString(months)); lastOutputSeconds = false; } else if (value == d) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer .toString(days)); lastOutputSeconds = false; } else if (value == H) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer .toString(hours)); lastOutputSeconds = false; } else if (value == m) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer .toString(minutes)); lastOutputSeconds = false; } else if (value == s) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer .toString(seconds)); lastOutputSeconds = true; } else if (value == S) { if (lastOutputSeconds) { milliseconds += 1000; String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); buffer.append(str.substring(1)); } else { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); } lastOutputSeconds = false; } } } return buffer.toString(); } static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } } static final Object y = \"y\"; static final Object M = \"M\"; static final Object d = \"d\"; static final Object H = \"H\"; static final Object m = \"m\"; static final Object s = \"s\"; static final Object S = \"S\";",
        "PatCode": "static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) { StringBuffer buffer = new StringBuffer(); boolean lastOutputSeconds = false; int sz = tokens.length; for (int i = 0; i < sz; i++) { Token token = tokens[i]; Object value = token.getValue(); int count = token.getCount(); if (value instanceof StringBuffer) { buffer.append(value.toString()); } else { if (value == y) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer .toString(years)); lastOutputSeconds = false; } else if (value == M) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer .toString(months)); lastOutputSeconds = false; } else if (value == d) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer .toString(days)); lastOutputSeconds = false; } else if (value == H) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer .toString(hours)); lastOutputSeconds = false; } else if (value == m) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer .toString(minutes)); lastOutputSeconds = false; } else if (value == s) { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer .toString(seconds)); lastOutputSeconds = true; } else if (value == S) { if (lastOutputSeconds) { milliseconds += 1000; String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds); buffer.append(str.substring(1)); } else { buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds)); } lastOutputSeconds = false; } } } return buffer.toString(); } static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add( field, -1 * difference ); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add( field, newdiff ); return newdiff; } else { return 0; } }end.add(field, newdiff); static final Object y = \"y\"; static final Object M = \"M\"; static final Object d = \"d\"; static final Object H = \"H\"; static final Object m = \"m\"; static final Object s = \"s\"; static final Object S = \"S\";"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_1439097_50_cp38.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.pow(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_129_dynamoth_patch_80439_1.diff",
    "BugId": "Closure_129",
    "PatchedMethods": [
      {
        "DevIntention": "is|equivalent|to",
        "OrgCode": "boolean isEquivalentTo( Node node, boolean compareJsType, boolean recur, boolean shallow) { if (type != node.getType() || getChildCount() != node.getChildCount() || this.getClass() != node.getClass()) { return false; } if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) { return false; } if (type == Token.INC || type == Token.DEC) { int post1 = this.getIntProp(INCRDECR_PROP); int post2 = node.getIntProp(INCRDECR_PROP); if (post1 != post2) { return false; } } else if (type == Token.STRING || type == Token.STRING_KEY) { if (type == Token.STRING_KEY) { int quoted1 = this.getIntProp(QUOTED_PROP); int quoted2 = node.getIntProp(QUOTED_PROP); if (quoted1 != quoted2) { return false; } } int slashV1 = this.getIntProp(SLASH_V); int slashV2 = node.getIntProp(SLASH_V); if (slashV1 != slashV2) { return false; } } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { return false; } } if (recur) { Node n, n2; for (n = first, n2 = node.first; n != null; n = n.next, n2 = n2.next) { if (!n.isEquivalentTo( n2, compareJsType, !(shallow && n.isFunction()), shallow)) { return false; } } } return true; }",
        "PatCode": "boolean isEquivalentTo( Node node, boolean compareJsType, boolean recur, boolean shallow) { if (type != node.getType() || getChildCount() != node.getChildCount() || this.getClass() != node.getClass()) { return false; } if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) { return false; } if (type == Token.INC || type == Token.DEC) { int post1 = this.getIntProp(INCRDECR_PROP); int post2 = node.getIntProp(INCRDECR_PROP); if (post1 != post2) { return false; } } else if (type == Token.STRING || type == Token.STRING_KEY) { if (type == Token.STRING_KEY) { int quoted1 = this.getIntProp(QUOTED_PROP); int quoted2 = node.getIntProp(QUOTED_PROP); if (quoted1 != quoted2) { return false; } } int slashV1 = this.getIntProp(SLASH_V); int slashV2 = node.getIntProp(SLASH_V); if (slashV1 != slashV2) { return false; } } else if (type == Token.CALL) { if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { if (false) { return false; } } } if (recur) { Node n, n2; for (n = first, n2 = node.first; n != null; n = n.next, n2 = n2.next) { if (!n.isEquivalentTo( n2, compareJsType, !(shallow && n.isFunction()), shallow)) { return false; } } } return true; }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_dynamoth_patch_135421_5.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (this.runningState != this.STATE_SUSPENDED) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_Nopol_patch_84450_1.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } if (org.apache.commons.lang.time.StopWatch.this.stopTime < org.apache.commons.lang.time.StopWatch.STATE_UNSPLIT) { stopTime = System.currentTimeMillis(); } this.runningState = STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1243363_272_cp119.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec != mant || (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jGenProg_patch_5647000_4846.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1321724_280_cp127.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (exp != numeric || (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1223833_270_cp117.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == exp || (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_dynamoth_patch_75311_2.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (false) { if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_kPAR_Patch_3801620_507_cp263.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_SimFix_patch_1449223_3.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } // start of generated patchif(this.maxMiddleIndex>=0){long s=getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime();long e=getDataItem(this.maxMiddleIndex).getPeriod().getEnd().getTime();long maxMiddle=s+(e-s)/2;if(middle>maxMiddle){this.maxMiddleIndex=index;}}else {this.maxMiddleIndex=index;}// end of generated patch/* start of original code if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } end of original code*/ if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_jMutRepair_patch_0_4.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.if (x > x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9973219_1068_cp828.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb != lowerBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_TBar_Patch_345606_17_cp11.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(atol); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_3877353_191_cp81.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_jGenProg_patch_6685000_8208.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)) ); if (function == null) { throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"function is null\");} return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Nopol_patch_275076_3.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "drop|phase1|objective",
        "OrgCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "PatCode": "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); // positive cost non-artificial variables for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); if (((2) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) && (0.0 < entry)) { columnsToDrop.add(i); } } // non-basic artificial variables for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_kPAR_Patch_2701925_369_cp186.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_1595248_209_cp141.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (!Character.isDigit(lastChar)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_FixMiner_Patch_522089_152.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_FixMiner_Patch_118372_22.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { if (cAvailableLocaleSet == null) { return false;}return cAvailableLocaleSet.contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_9168378_838_cp563.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; process2RowsBlock(k); work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_28_jGenProg_patch_176000_76.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1399853_288_cp135.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (exp != str || (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10244487_1012_cp681.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jKali_patch_441000_559.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) {if (false) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_TBar_Patch_21320997_2749_cp1183.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_SimFix_patch_173292_2.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.// start of generated patchif(x==ftol){x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol));f0=computeObjectiveValue(x0);}// end of generated patch/* start of original code if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } end of original code*/ break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9175723_970_cp730.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa >= fb && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Closure_126_jKali_patch_12000_4.diff",
    "BugId": "Closure_126",
    "PatchedMethods": [
      {
        "DevIntention": "try|minimize|exits",
        "OrgCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }",
        "PatCode": "void tryMinimizeExits(Node n, int exitType, String labelName) { // Just an 'exit'. if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } // Just an 'if'. if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } // Just a 'try/catch/finally'. if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* Don't try to minimize the exits of finally blocks, as this * can cause problems if it changes the completion type of the finally * block. See ECMA 262 Sections 8.9 & 12.14 */ if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild();if (true)return; tryMinimizeExits(finallyBlock, exitType, labelName);} } // Just a 'label'. if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } // TODO(johnlenz): The last case of SWITCH statement? // The rest assumes a block with at least one child, bail on anything else. if (!n.isBlock() || n.getLastChild() == null) { return; } // Multiple if-exits can be converted in a single pass. // Convert \"if (blah) break; if (blah2) break; other_stmt;\" to // become \"if (blah); else { if (blah2); else { other_stmt; } }\" // which will get converted to \"if (!blah && !blah2) { other_stmt; }\". for (Node c : n.children()) { // An 'if' block to process below. if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; // First, the true condition block. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); // Now the else block. // The if blocks may have changed, get them again. trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } // Now try to minimize the exits of the last child, if it is removed // look at what has become the last child. for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); // If the node is still the last child, we are done. if (c == n.getLastChild()) { break; } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_jGenProg_patch_1369000_388.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) {x0 = 0.5 * ((x0 + x1) - org.apache.commons.math.util.FastMath.max(rtol * org.apache.commons.math.util.FastMath.abs(x1), atol)); double y0 = computeObjectiveValue(x0); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_9975686_966_cp652.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2420958_296_cp216.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str.startsWith(\"0x\") || str.startsWith(\"-0x\"))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_33_TBar_Patch_299663_49_cp30.diff",
    "BugId": "Lang_33",
    "PatchedMethods": [
      {
        "DevIntention": "to|class",
        "OrgCode": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { classes[i] = array[i].getClass(); } return classes; }",
        "PatCode": "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { if (classes != null && array[i] != null) {classes[i] = array[i].getClass();} } return classes; }"
      }
    ]
  },
  {
    "PatchId": "Closure_21_Nopol_patch_91606_1.diff",
    "BugId": "Closure_21",
    "PatchedMethods": [
      {
        "DevIntention": "visit",
        "OrgCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }",
        "PatCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { if (com.google.javascript.jscomp.CheckSideEffects.PROTECTOR_FN.length()==0) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_8773312_758_cp520.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[n + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Chart_25_jGenProg_patch_36000_80.diff",
    "BugId": "Chart_25",
    "PatchedMethods": [
      {
        "DevIntention": "get|mean|value",
        "OrgCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { result = masd.getMean(); } return result; }",
        "PatCode": "public Number getMeanValue(int row, int column) { Number result = null; MeanAndStandardDeviation masd = (MeanAndStandardDeviation) this.data.getObject(row, column); if (masd != null) { } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_8355309_710_cp473.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[j - k] = tmp;work[i + k] = work[j - k]; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_63_FixMiner_Patch_1730971_286.diff",
    "BugId": "Math_63",
    "PatchedMethods": [
      {
        "DevIntention": "equals",
        "OrgCode": "public static boolean equals(double[] x, double[] y) { if ((x == null) || (y == null)) { return !((x == null) ^ (y == null)); } if (x.length != y.length) { return false; } for (int i = 0; i < x.length; ++i) { if (!equals(x[i], y[i])) { return false; } } return true; }",
        "PatCode": "public static boolean equals(double[] x, double[] y) { if ((x == null) || (y == null)) { return !((x == null) ^ (y == null)); } if (x.length != y.length) { return false; } for (int i = 0; i < x.length; ++i) { if (!equals(x[i], y[i], i)) { return false; } } return true; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_jKali_patch_4000_11.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the lineif (true) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_17701919_908.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "get|function",
        "OrgCode": "protected LinearObjectiveFunction getFunction() { return function; }",
        "PatCode": "protected LinearObjectiveFunction getFunction() { if (function == null) { return null;}return function; }"
      }
    ]
  },
  {
    "PatchId": "Math_28_TBar_Patch_18723844_558_cp426.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9396626_998_cp758.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa == initial && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Avatar_Patch_240348_7.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(f1); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_Avatar_Patch_11538576_1580.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (this.legendItemURLGenerator != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9631719_1028_cp788.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa > upperBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10020845_971_cp657.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { process1RowBlock(step); j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18660532_938.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.constraints, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9302094_986_cp746.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa == a && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_Nopol_patch_4727394_6.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (((f1 * fx) == -1) || (((f1 * fx) < 0) && (-1 < f0))) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_63_FixMiner_Patch_5542433_3350.diff",
    "BugId": "Math_63",
    "PatchedMethods": [
      {
        "DevIntention": "equals",
        "OrgCode": "public static boolean equals(double x, double y) { return (Double.isNaN(x) && Double.isNaN(y)) || x == y; }",
        "PatCode": "public static boolean equals(double x, double y) { return (Double.isNaN(EPSILON) && Double.isNaN(y)) || x == y; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_21520957_1071.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "create|tableau",
        "OrgCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }",
        "PatCode": "protected RealMatrix createTableau(final boolean maximize) { // create a matrix of the correct size int width = numDecisionVariables + numSlackVariables + numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS int height = constraints.size() + getNumObjectiveFunctions(); Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width); // initialize the objective function rows if (getNumObjectiveFunctions() == 2) { matrix.setEntry(0, 0, -1); } int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1; matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1); RealVector objectiveCoefficients = maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients(); copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]); matrix.setEntry(zIndex, width - 1, maximize ? f.getConstantTerm() : -1 * f.getConstantTerm()); if (!restrictToNonNegative) { matrix.setEntry(zIndex, getSlackVariableOffset() - 1, getInvertedCoefficientSum(objectiveCoefficients)); } // initialize the constraint rows int slackVar = 0; int artificialVar = 0; for (int i = 0; i < constraints.size(); i++) { LinearConstraint constraint = constraints.get(i); int row = getNumObjectiveFunctions() + i; // decision variable coefficients copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]); // x- if (!restrictToNonNegative) { matrix.setEntry(row, getSlackVariableOffset() - 1, getInvertedCoefficientSum(constraint.getCoefficients())); } // RHS matrix.setEntry(row, width - 1, constraint.getValue()); // slack variables if (constraint.getRelationship() == Relationship.LEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1); // slack } else if (constraint.getRelationship() == Relationship.GEQ) { matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess } // artificial variables if ((constraint.getRelationship() == Relationship.EQ) || (getNumObjectiveFunctions() == 2)) { matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1); matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); } } return matrix; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_541000_4258.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width);java.lang.String str = (obj == null) ? getNullText() : obj.toString(); buffer = new char[str.length() + org.apache.commons.lang.text.StrBuilder.CAPACITY]; int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_Avatar_Patch_3962648_695.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxStartIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_10225831_1010_cp679.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i>j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_252144_9.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { if (this.getSlackVariableOffset() == (this.getOriginalNumDecisionVariables() - 1)) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9460482_1006_cp766.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa >= initial && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Closure_115_SimFix_patch_123565_1.diff",
    "BugId": "Closure_115",
    "PatchedMethods": [
      {
        "DevIntention": "can|inline|reference|directly",
        "OrgCode": "private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext(); // Functions called via 'call' and 'apply' have a this-object as // the first parameter, but this is not part of the called function's // parameter list. if (!callNode.getFirstChild().isName()) { if (NodeUtil.isFunctionObjectCall(callNode)) { // TODO(johnlenz): Support replace this with a value. if (cArg == null || !cArg.isThis()) { return CanInlineResult.NO; } cArg = cArg.getNext(); } else { // \".apply\" call should be filtered before this. Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } } // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ] Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) { // For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) { if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop. if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } // Move to the next name. fnParam = fnParam.getNext(); } // For every call argument check for side-effects, even if there // isn't a named parameter to match. if (cArg != null) { if (NodeUtil.mayHaveSideEffects(cArg, compiler)) { return CanInlineResult.NO; } cArg = cArg.getNext(); } } return CanInlineResult.YES; }",
        "PatCode": "private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode) { if (!isDirectCallNodeReplacementPossible(fnNode)) { return CanInlineResult.NO; } Node block = fnNode.getLastChild(); boolean hasSideEffects = false; if (block.hasChildren()) { Preconditions.checkState(block.hasOneChild()); Node stmt = block.getFirstChild(); if (stmt.isReturn()) { hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); } } // CALL NODE: [ NAME, ARG1, ARG2, ... ] Node cArg = callNode.getFirstChild().getNext(); // Functions called via 'call' and 'apply' have a this-object as // the first parameter, but this is not part of the called function's // parameter list. if (!callNode.getFirstChild().isName()) { if (NodeUtil.isFunctionObjectCall(callNode)) { // TODO(johnlenz): Support replace this with a value. if (cArg == null || !cArg.isThis()) { return CanInlineResult.NO; } cArg = cArg.getNext(); } else { // \".apply\" call should be filtered before this. Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } } // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ] Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); while (cArg != null || fnParam != null) { // For each named parameter check if a mutable argument use more than one. if (fnParam != null) { if (cArg != null) {// start of generated patchif(cArg==null&&NodeUtil.canBeSideEffected(cArg)){return CanInlineResult.NO;}// end of generated patch/* start of original code if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { return CanInlineResult.NO; } end of original code*/ // Check for arguments that are evaluated more than once. // Note: Unlike block inlining, there it is not possible that a // parameter reference will be in a loop. if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount( block, fnParam.getString()) > 1) { return CanInlineResult.NO; } } // Move to the next name. fnParam = fnParam.getNext(); } // For every call argument check for side-effects, even if there // isn't a named parameter to match. if (cArg != null) { if (NodeUtil.mayHaveSideEffects(cArg, compiler)) { return CanInlineResult.NO; } cArg = cArg.getNext(); } } return CanInlineResult.YES; }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_Avatar_Patch_94070_11.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { if (cAvailableLocaleSet == null) { return false;}return cAvailableLocaleSet.contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Math_80_jMutRepair_patch_285000_442.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "eigenvalues|range",
        "OrgCode": "private double[] eigenvaluesRange(final int index, final int n) { // find the bounds of the spectra of the local block final int lowerStart = 4 * main.length; final int upperStart = 5 * main.length; double lower = Double.POSITIVE_INFINITY; double upper = Double.NEGATIVE_INFINITY; for (int i = 0; i < n; ++i) { lower = Math.min(lower, work[lowerStart + index +i]); upper = Math.max(upper, work[upperStart + index +i]); } // set thresholds final double tNorm = Math.max(Math.abs(lower), Math.abs(upper)); final double relativeTolerance = Math.sqrt(MathUtils.EPSILON); final double absoluteTolerance = 4 * minPivot; final int maxIter = 2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0)); final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot); // search lower eigenvalue double left = lower - margin; double right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) { // search has converged break; } final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= 1) { right = middle; } else { left = middle; } } lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left)); // search upper eigenvalue left = lower - margin; right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) { // search has converged break; } final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= n) { right = middle; } else { left = middle; } } upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right)); return new double[] { lower, upper }; }",
        "PatCode": "private double[] eigenvaluesRange(final int index, final int n) { // find the bounds of the spectra of the local block final int lowerStart = 4 * main.length; final int upperStart = 5 * main.length; double lower = Double.POSITIVE_INFINITY; double upper = Double.NEGATIVE_INFINITY; for (int i = 0; i < n; ++i) { lower = Math.min(lower, work[lowerStart + index +i]); upper = Math.max(upper, work[upperStart + index +i]); } // set thresholds final double tNorm = Math.max(Math.abs(lower), Math.abs(upper)); final double relativeTolerance = Math.sqrt(MathUtils.EPSILON); final double absoluteTolerance = 4 * minPivot; final int maxIter = 2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0)); final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot); // search lower eigenvalue double left = lower - margin; double right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left; if ((range < absoluteTolerance) || (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) { // search has converged break; } final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= 1) { right = middle; } else { left = middle; } } lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left)); // search upper eigenvalue left = lower - margin; right = upper + margin; for (int i = 0; i < maxIter; ++i) { final double range = right - left;if ((range < absoluteTolerance) || (range < (relativeTolerance / java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { // search has converged break; } final double middle = 0.5 * (left + right); if (countEigenValues(middle, index, n) >= n) { right = middle; } else { left = middle; } } upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right)); return new double[] { lower, upper }; }"
      }
    ]
  },
  {
    "PatchId": "Mockito_29_Avatar_Patch_214053_26.diff",
    "BugId": "Mockito_29",
    "PatchedMethods": [
      {
        "DevIntention": "same",
        "OrgCode": "public static <T> T same(T value) { return (T) reportMatcher(new Same(value)).<T>returnFor(value); }",
        "PatCode": "public static <T> T same(T value) { if (value == null) { return null;}return (T) reportMatcher(new Same(value)).<T>returnFor(value); }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2769121_328_cp248.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str.startsWith(\"0x\"))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9754867_1042_cp802.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb >= b && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_dynamoth_patch_123972_3.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (false) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19528419_968.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|constraint|type|counts",
        "OrgCode": "private int getConstraintTypeCounts(final Relationship relationship) { int count = 0; for (final LinearConstraint constraint : constraints) { if (constraint.getRelationship() == relationship) { ++count; } } return count; }",
        "PatCode": "private int getConstraintTypeCounts(final Relationship relationship) { int count = 0; if (constraints != null) {for (final LinearConstraint constraint : constraints) { if (constraint.getRelationship() == relationship) { ++count; } }} return count; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18050422_916.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, this.numSlackVariables, src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_8_jGenProg_patch_4495000_3540.diff",
    "BugId": "Math_8",
    "PatchedMethods": [
      {
        "DevIntention": "sample",
        "OrgCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i < sampleSize; i++) { out[i] = sample(); } return out; }}",
        "PatCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); for (int i = 0; i < sampleSize; i++) { } return out; }}"
      }
    ]
  },
  {
    "PatchId": "Math_58_dynamoth_patch_127805_12.diff",
    "BugId": "Math_58",
    "PatchedMethods": [
      {
        "DevIntention": "validate|parameters",
        "OrgCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[2] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }",
        "PatCode": "private void validateParameters(double[] param) { if (param == null) { throw new NullArgumentException(); } if (param.length != 3) { throw new DimensionMismatchException(param.length, 3); } if (param[0] <= 0) { throw new NotStrictlyPositiveException(param[2]); } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_SimFix_patch_459031_2.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); // start of generated patchif(fa*fb>=1.0){throw new ConvergenceException(\"number of iterations={0}, maximum iterations={1}, \"+\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb);}// end of generated patch/* start of original code if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } end of original code*/ return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_82_jGenProg_patch_870000_4332.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|column",
        "OrgCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { minValue = tableau.getEntry(0, i); minPos = i; } } return minPos; }",
        "PatCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { /** * Returns the row with the minimum ratio as given by the minimum ratio test (MRT). * @param tableau simple tableau for the problem * @param col the column to test the ratio of. See {@link #getPivotColumn(SimplexTableau)} * @return row with the minimum ratio */ /** * Runs one iteration of the Simplex method on the given model. * @param tableau simple tableau for the problem * @throws OptimizationException if the maximal iteration count has been * exceeded or if the model is found not to have a bounded solution */restrictToNonNegative = restrictToNonNegative; minPos = i;}} return minPos;} private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) { double minRatio = java.lang.Double.MAX_VALUE; java.lang.Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i;}}} return minRatioPos;} protected void doIteration(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException { incrementIterationsCounter(); Integer pivotCol = getPivotColumn(tableau); Integer pivotRow = getPivotRow(pivotCol, tableau); if (pivotRow == null) { throw new UnboundedSolutionException(); } // set the pivot element to 1 double pivotVal = tableau.getEntry(pivotRow, pivotCol); tableau.divideRow(pivotRow, pivotVal); // set the rest of the pivot column to 0 for (int i = 0; i < tableau.getHeight(); i++) { if (i != pivotRow) { double multiplier = tableau.getEntry(i, pivotCol); tableau.subtractRow(i, pivotRow, multiplier); } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_SimFix_patch_3772850_3.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line// start of generated patchif(excerpt.equals(LINE)&&0<=charno&&charno<='9'){for(int i=0;i<charno;i++){char c=sourceExcerpt.charAt(i);if(Character.isWhitespace(c)){b.append(c);}else {b.append(' ');}}b.append(\"^\\n\");}// end of generated patch/* start of original code if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } end of original code*/ } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_10005808_1072_cp832.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb < lowerBound && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_Avatar_Patch_3976557_696.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_jGenProg_patch_541000_210.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.if (x == x1) { f0 = f1; f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_85_jMutRepair_patch_80000_99.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if ((fa - fb) >= 0.0) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236215_13.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if ((this.getOriginalNumDecisionVariables() - this.getSlackVariableOffset()) == 1) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_127496_10_cp10.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "get|max|middle|index",
        "OrgCode": "public int getMaxMiddleIndex() { return this.maxMiddleIndex; }",
        "PatCode": "public int getMaxMiddleIndex() { return this.maxStartIndex; }"
      }
    ]
  },
  {
    "PatchId": "Chart_18_SimFix_patch_73162_1.diff",
    "BugId": "Chart_18",
    "PatchedMethods": [
      {
        "DevIntention": "remove|value",
        "OrgCode": "public void removeValue(int index) { this.keys.remove(index); this.values.remove(index); if (index < this.keys.size()) { rebuildIndex(); } }",
        "PatCode": "public void removeValue(int index) { this.keys.remove(index); this.values.remove(index);// start of generated patchif(index<=this.keys.size()){rebuildIndex();}// end of generated patch/* start of original code if (index < this.keys.size()) { rebuildIndex(); } end of original code*/ }"
      }
    ]
  },
  {
    "PatchId": "Math_57_jMutRepair_patch_131000_23.diff",
    "BugId": "Math_57",
    "PatchedMethods": [
      {
        "DevIntention": "equals",
        "OrgCode": "@Override public boolean equals(final Object other) { if (!(other instanceof EuclideanIntegerPoint)) { return false; } final int[] otherPoint = ((EuclideanIntegerPoint) other).getPoint(); if (point.length != otherPoint.length) { return false; } for (int i = 0; i < point.length; i++) { if (point[i] != otherPoint[i]) { return false; } } return true; }",
        "PatCode": "@Override public boolean equals(final Object other) { if (!(other instanceof EuclideanIntegerPoint)) { return false; } final int[] otherPoint = ((EuclideanIntegerPoint) other).getPoint(); if (point.length != otherPoint.length) { return false; } for (int i = 0; i < point.length; i++) {if (point[i] > otherPoint[i]) { return false; } } return true; }"
      }
    ]
  },
  {
    "PatchId": "Math_32_jKali_patch_2000_8.diff",
    "BugId": "Math_32",
    "PatchedMethods": [
      {
        "DevIntention": "compute|geometrical|properties",
        "OrgCode": "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); if ((Boolean) tree.getAttribute()) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { // there is at least one open-loop: the polygon is infinite setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { // all loops are closed, we compute some integrals around the shape double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { // the polygon as a finite outside surrounded by an infinite inside setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }",
        "PatCode": "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false);if (false) { // the instance covers the whole space setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { // there is at least one open-loop: the polygon is infinite setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { // all loops are closed, we compute some integrals around the shape double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { // the polygon as a finite outside surrounded by an infinite inside setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_20592342_1026.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize|constraints",
        "OrgCode": "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) { List<LinearConstraint> normalized = new ArrayList<LinearConstraint>(); for (LinearConstraint constraint : originalConstraints) { normalized.add(normalize(constraint)); } return normalized; }",
        "PatCode": "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) { List<LinearConstraint> normalized = new ArrayList<LinearConstraint>(); for (LinearConstraint constraint : originalConstraints) { if (normalized == null) { throw new IllegalArgumentException(\"Null 'normalized' argument.\");}normalized.add(normalize(constraint)); } return normalized; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Closure_10_jMutRepair_patch_468000_294.diff",
    "BugId": "Closure_10",
    "PatchedMethods": [
      {
        "DevIntention": "may|be|string",
        "OrgCode": "static boolean mayBeString(Node n) { return mayBeString(n, true); } static boolean mayBeString(Node n, boolean recurse) { if (recurse) { return allResultsMatch(n, MAY_BE_STRING_PREDICATE); } else { return mayBeStringHelper(n); } } static boolean mayBeStringHelper(Node n) { return !isNumericResult(n) && !isBooleanResult(n) && !isUndefined(n) && !n.isNull(); }",
        "PatCode": "static boolean mayBeString(Node n) { return mayBeString(n, true); } static boolean mayBeString(Node n, boolean recurse) {if (!recurse) { return allResultsMatch(n, MAY_BE_STRING_PREDICATE); } else { return mayBeStringHelper(n); } } static boolean mayBeStringHelper(Node n) { return !isNumericResult(n) && !isBooleanResult(n) && !isUndefined(n) && !n.isNull(); }"
      }
    ]
  },
  {
    "PatchId": "Math_2_Nopol_patch_245534_2.diff",
    "BugId": "Math_2",
    "PatchedMethods": [
      {
        "DevIntention": "inverse|cumulative|probability",
        "OrgCode": "public int inverseCumulativeProbability(final double p) throws OutOfRangeException { if (p < 0.0 || p > 1.0) { throw new OutOfRangeException(p, 0, 1); } int lower = getSupportLowerBound(); if (p == 0.0) { return lower; } if (lower == Integer.MIN_VALUE) { if (checkedCumulativeProbability(lower) >= p) { return lower; } } else { lower -= 1; // this ensures cumulativeProbability(lower) < p, which // is important for the solving step } int upper = getSupportUpperBound(); if (p == 1.0) { return upper; } // use the one-sided Chebyshev inequality to narrow the bracket // cf. AbstractRealDistribution.inverseCumulativeProbability(double) final double mu = getNumericalMean(); final double sigma = FastMath.sqrt(getNumericalVariance()); final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { double k = FastMath.sqrt((1.0 - p) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; } k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { upper = ((int) Math.ceil(tmp)) - 1; } } return solveInverseCumulativeProbability(p, lower, upper); }",
        "PatCode": "public int inverseCumulativeProbability(final double p) throws OutOfRangeException { if (p < 0.0 || p > 1.0) { throw new OutOfRangeException(p, 0, 1); } int lower = getSupportLowerBound(); if (p == 0.0) { return lower; } if (lower == Integer.MIN_VALUE) { if (checkedCumulativeProbability(lower) >= p) { return lower; } } else { lower -= 1; // this ensures cumulativeProbability(lower) < p, which // is important for the solving step } int upper = getSupportUpperBound(); if (p == 1.0) { return upper; } // use the one-sided Chebyshev inequality to narrow the bracket // cf. AbstractRealDistribution.inverseCumulativeProbability(double) final double mu = getNumericalMean(); final double sigma = FastMath.sqrt(getNumericalVariance()); final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { double k = FastMath.sqrt((1.0 - p) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; } k = 1.0 / k; tmp = mu + k * sigma; if (sigma == lower) { if (tmp < upper) { upper = ((int) Math.ceil(tmp)) - 1; } } } return solveInverseCumulativeProbability(p, lower, upper); }"
      }
    ]
  },
  {
    "PatchId": "Chart_9_Nopol_patch_15720_3.diff",
    "BugId": "Chart_9",
    "PatchedMethods": [
      {
        "DevIntention": "create|copy",
        "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if (endIndex < 0) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; // start is after last data item } } int endIndex = getIndex(end); if (endIndex < 0) { // end period is not in original series endIndex = -(endIndex + 1); // this is first item AFTER end period endIndex = endIndex - 1; // so this is last item BEFORE end } if ((endIndex < 0) || ((org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length()) != (org.jfree.data.time.TimeSeries.this.data.size()))) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_13967574_2588_cp1262.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (entry > this.epsilon && (MathUtils.compareTo(entry, 0, epsilon) >= 0)) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_TBar_Patch_1361180_284_cp131.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (exp != mant || (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_21_dynamoth_patch_61749_1.diff",
    "BugId": "Closure_21",
    "PatchedMethods": [
      {
        "DevIntention": "visit",
        "OrgCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }",
        "PatCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (n.isExprResult()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (parent.getType() == Token.COMMA) { if (isResultUsed) { return; } if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (false) { if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; } else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) { return; } } if ( (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_28_jGenProg_patch_1250000_418.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|column",
        "OrgCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { final double entry = tableau.getEntry(0, i); // check if the entry is strictly smaller than the current minimum // do not use a ulp/epsilon check if (entry < minValue) { minValue = entry; minPos = i; } } return minPos; }",
        "PatCode": "private Integer getPivotColumn(SimplexTableau tableau) { double minValue = 0; Integer minPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) { final double entry = tableau.getEntry(0, i); // check if the entry is strictly smaller than the current minimum // do not use a ulp/epsilon checkif (entry < minValue) minPos = i; } return minPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_28_FixMiner_Patch_18410173_393.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_kPAR_Patch_698193_74_cp7.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "optimize",
        "OrgCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; this.goal = goalType; this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }",
        "PatCode": "public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException { // store linear problem characteristics this.function = f; this.linearConstraints = constraints; if (goalType != null) {this.goal = goalType;} this.nonNegative = restrictToNonNegative; iterations = 0; // solve the problem return doOptimize(); }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_kPAR_Patch_3746722_503_cp259.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxStartIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_kPAR_Patch_2674157_367_cp184.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxStartIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_jGenProg_patch_5051000_1518.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) {f0 = computeObjectiveValue(x0); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_44_TBar_Patch_847882_182_cp72.diff",
    "BugId": "Lang_44",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String val) throws NumberFormatException { if (val == null) { return null; } if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); } if (val.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) { return createInteger(val); } char lastChar = val.charAt(val.length() - 1); String mant; String dec; String exp; int decPos = val.indexOf('.'); int expPos = val.indexOf('e') + val.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(val + \" is not a valid number.\"); } dec = val.substring(decPos + 1, expPos); } else { dec = val.substring(decPos + 1); } mant = val.substring(0, decPos); } else { if (expPos > -1) { mant = val.substring(0, expPos); } else { mant = val; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = val.substring(0, val.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(val + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException e) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // empty catch } //Fall through default : throw new NumberFormatException(val + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(val); } catch (NumberFormatException nfe) { // empty catch } try { return createLong(val); } catch (NumberFormatException nfe) { // empty catch } return createBigInteger(val); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(val); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // empty catch } try { Double d = createDouble(val); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } return createBigDecimal(val); } } }",
        "PatCode": "public static Number createNumber(String val) throws NumberFormatException { if (val == null) { return null; } if (val.length() == 0) { throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); } if (val.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) { return createInteger(val); } char lastChar = val.charAt(val.length() - 1); String mant; String dec; String exp; int decPos = val.indexOf('.'); int expPos = val.indexOf('e') + val.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(val + \" is not a valid number.\"); } dec = val.substring(decPos + 1, expPos); } else { dec = val.substring(decPos + 1); } mant = val.substring(0, decPos); } else { if (expPos > -1) { mant = val.substring(0, expPos); } else { mant = val; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = val.substring(0, val.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(val + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException e) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // empty catch } //Fall through default : throw new NumberFormatException(val + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < val.length() - 1) { exp = val.substring(expPos + 1, val.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(val); } catch (NumberFormatException nfe) { // empty catch } try { return createLong(val); } catch (NumberFormatException nfe) { // empty catch } return createBigInteger(val); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(val); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // empty catch } try { Double d = createDouble(val); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // empty catch } return createBigDecimal(val); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18270745_928.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, this.numDecisionVariables, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Lang_57_FixMiner_Patch_84093_17.diff",
    "BugId": "Lang_57",
    "PatchedMethods": [
      {
        "DevIntention": "is|available|locale",
        "OrgCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet.contains(locale); }",
        "PatCode": "public static boolean isAvailableLocale(Locale locale) { return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale); }"
      }
    ]
  },
  {
    "PatchId": "Lang_55_jKali_patch_103137_21.diff",
    "BugId": "Lang_55",
    "PatchedMethods": [
      {
        "DevIntention": "stop",
        "OrgCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); } stopTime = System.currentTimeMillis(); this.runningState = STATE_STOPPED; }",
        "PatCode": "public void stop() { if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) { throw new IllegalStateException(\"Stopwatch is not running. \"); }if (true)return; stopTime = java.lang.System.currentTimeMillis(); this.runningState = org.apache.commons.lang.time.StopWatch.STATE_STOPPED; }"
      }
    ]
  },
  {
    "PatchId": "Lang_43_jGenProg_patch_76000_32.diff",
    "BugId": "Lang_43",
    "PatchedMethods": [
      {
        "DevIntention": "append|quoted|string",
        "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex();char[] c = pattern.toCharArray(); pos.setIndex(pos.getIndex() + 1); if (escapingOn && c[start] == QUOTE) { return appendTo == null ? null : appendTo.append(QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_TBar_Patch_21302926_2746_cp1182.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } }if (dataset != null) { return result; } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_SimFix_patch_548232_3.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing.// start of generated patchif(x==x0){x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol));f0=computeObjectiveValue(x0);}// end of generated patch/* start of original code if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } end of original code*/ break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_Avatar_Patch_11516788_1579.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (this.legendItemToolTipGenerator != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Chart_26_TBar_Patch_15351883_3568_cp1315.diff",
    "BugId": "Chart_26",
    "PatchedMethods": [
      {
        "DevIntention": "draw",
        "OrgCode": "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { // if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; } // record the plot area... if (state == null) { // if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes state = new PlotRenderingInfo(null); } state.setPlotArea(area); // adjust the drawing area for the plot insets (if any)... RectangleInsets insets = getInsets(); insets.trim(area); // calculate the data area... AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); // if there is a renderer, it draws the background, otherwise use the // default background... if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); // don't let anyone draw outside the data area Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates() .get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } // draw the markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } // now render data items... boolean foundData = false; // set up the alpha-transparency... Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { for (int i = 0; i < this.datasets.size(); i++) { foundData = render(g2, dataArea, i, state) || foundData; } } else { // DatasetRenderingOrder.REVERSE for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } } // draw the foreground markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } // draw the annotations (if any)... drawAnnotations(g2, dataArea); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } // draw range crosshair if required... if (isRangeCrosshairVisible()) { // FIXME: this doesn't handle multiple range axes drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } // draw an outline around the plot area... if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } }",
        "PatCode": "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { // if the plot area is too small, just return... boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (this.rangeGridlinesVisible || b2) { return; } // record the plot area... if (state == null) { // if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes state = new PlotRenderingInfo(null); } state.setPlotArea(area); // adjust the drawing area for the plot insets (if any)... RectangleInsets insets = getInsets(); insets.trim(area); // calculate the data area... AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); // if there is a renderer, it draws the background, otherwise use the // default background... if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); // don't let anyone draw outside the data area Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates() .get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } // draw the markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } // now render data items... boolean foundData = false; // set up the alpha-transparency... Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { for (int i = 0; i < this.datasets.size(); i++) { foundData = render(g2, dataArea, i, state) || foundData; } } else { // DatasetRenderingOrder.REVERSE for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } } // draw the foreground markers... for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } // draw the annotations (if any)... drawAnnotations(g2, dataArea); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } // draw range crosshair if required... if (isRangeCrosshairVisible()) { // FIXME: this doesn't handle multiple range axes drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } // draw an outline around the plot area... if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18400005_932.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, this.maxUlps, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_2850190_101_cp80.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol))) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_46_dynamoth_patch_649139_1.diff",
    "BugId": "Closure_46",
    "PatchedMethods": [
      {
        "DevIntention": "assert|type|equals",
        "OrgCode": "public static void assertTypeEquals(JSType a, JSType b) { assertTypeEquals(\"\", a, b); }",
        "PatCode": "public static void assertTypeEquals(JSType a, JSType b) { if (false) { assertTypeEquals(\"\", a, b); } }"
      }
    ]
  },
  {
    "PatchId": "Math_7_Nopol_patch_463165_1.diff",
    "BugId": "Math_7",
    "PatchedMethods": [
      {
        "DevIntention": "accept|step",
        "OrgCode": "protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException { double previousT = interpolator.getGlobalPreviousTime(); final double currentT = interpolator.getGlobalCurrentTime(); // initialize the events states if needed if (! statesInitialized) { for (EventState state : eventsStates) { state.reinitializeBegin(interpolator); } statesInitialized = true; } // search for next events that may occur during the step final int orderingSign = interpolator.isForward() ? +1 : -1; SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() { /** {@inheritDoc} */ public int compare(EventState es0, EventState es1) { return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime()); } }); for (final EventState state : eventsStates) { if (state.evaluateStep(interpolator)) { // the event occurs during the current step occuringEvents.add(state); } } while (!occuringEvents.isEmpty()) { // handle the chronologically first event final Iterator<EventState> iterator = occuringEvents.iterator(); final EventState currentEvent = iterator.next(); iterator.remove(); // restrict the interpolator to the first part of the step, up to the event final double eventT = currentEvent.getEventTime(); interpolator.setSoftPreviousTime(previousT); interpolator.setSoftCurrentTime(eventT); // get state at event time interpolator.setInterpolatedTime(eventT); final double[] eventY = interpolator.getInterpolatedState().clone(); // advance all event states to current time currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop(); // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { handler.handleStep(interpolator, isLastStep); } if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; } boolean needReset = currentEvent.reset(eventT, eventY); if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; } // prepare handling of the remaining part of the step previousT = eventT; interpolator.setSoftPreviousTime(eventT); interpolator.setSoftCurrentTime(currentT); // check if the same event occurs again in the remaining part of the step if (currentEvent.evaluateStep(interpolator)) { // the event occurs during the current step occuringEvents.add(currentEvent); } } // last part of the step, after the last event interpolator.setInterpolatedTime(currentT); final double[] currentY = interpolator.getInterpolatedState(); for (final EventState state : eventsStates) { state.stepAccepted(currentT, currentY); isLastStep = isLastStep || state.stop(); } isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1); // handle the remaining part of the step, after all events if any for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, isLastStep); } return currentT; }",
        "PatCode": "protected double acceptStep(final AbstractStepInterpolator interpolator, final double[] y, final double[] yDot, final double tEnd) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException { double previousT = interpolator.getGlobalPreviousTime(); final double currentT = interpolator.getGlobalCurrentTime(); // initialize the events states if needed if (! statesInitialized) { for (EventState state : eventsStates) { state.reinitializeBegin(interpolator); } statesInitialized = true; } // search for next events that may occur during the step final int orderingSign = interpolator.isForward() ? +1 : -1; SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() { /** {@inheritDoc} */ public int compare(EventState es0, EventState es1) { return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime()); } }); for (final EventState state : eventsStates) { if (state.evaluateStep(interpolator)) { // the event occurs during the current step occuringEvents.add(state); } } while (!occuringEvents.isEmpty()) { // handle the chronologically first event final Iterator<EventState> iterator = occuringEvents.iterator(); final EventState currentEvent = iterator.next(); iterator.remove(); // restrict the interpolator to the first part of the step, up to the event final double eventT = currentEvent.getEventTime(); interpolator.setSoftPreviousTime(previousT); interpolator.setSoftCurrentTime(eventT); // get state at event time interpolator.setInterpolatedTime(eventT); final double[] eventY = interpolator.getInterpolatedState().clone(); // advance all event states to current time currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop(); // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { if (org.apache.commons.math3.ode.AbstractIntegrator.this.stepHandlers.size() == orderingSign) { handler.handleStep(interpolator, isLastStep); } } if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; } boolean needReset = currentEvent.reset(eventT, eventY); if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; } // prepare handling of the remaining part of the step previousT = eventT; interpolator.setSoftPreviousTime(eventT); interpolator.setSoftCurrentTime(currentT); // check if the same event occurs again in the remaining part of the step if (currentEvent.evaluateStep(interpolator)) { // the event occurs during the current step occuringEvents.add(currentEvent); } } // last part of the step, after the last event interpolator.setInterpolatedTime(currentT); final double[] currentY = interpolator.getInterpolatedState(); for (final EventState state : eventsStates) { state.stepAccepted(currentT, currentY); isLastStep = isLastStep || state.stop(); } isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1); // handle the remaining part of the step, after all events if any for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, isLastStep); } return currentT; }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_2375493_292_cp212.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(StringUtils.isBlank(str))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19441356_966.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { if (dest == null) { throw new IllegalArgumentException(\"Null 'dest' argument.\");}System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_18748163_940.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, this.columnLabels, getNumObjectiveFunctions(), src.length); }"
      }
    ]
  },
  {
    "PatchId": "Lang_63_kPAR_Patch_7438609_991_cp645.diff",
    "BugId": "Lang_63",
    "PatchedMethods": [
      {
        "DevIntention": "format|period",
        "OrgCode": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) { long millis = endMillis - startMillis; if (millis < 28 * DateUtils.MILLIS_PER_DAY) { return formatDuration(millis, format, padWithZeros); } Token[] tokens = lexx(format); // timezones get funky around 0, so normalizing everything to GMT // stops the hours being off Calendar start = Calendar.getInstance(timezone); start.setTime(new Date(startMillis)); Calendar end = Calendar.getInstance(timezone); end.setTime(new Date(endMillis)); // initial estimates int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); // each initial estimate is adjusted in case it is under 0 while (milliseconds < 0) { milliseconds += 1000; seconds -= 1; } while (seconds < 0) { seconds += 60; minutes -= 1; } while (minutes < 0) { minutes += 60; hours -= 1; } while (hours < 0) { hours += 24; days -= 1; } while (days < 0) { days += 31;//days += 31; // TODO: Need tests to show this is bad and the new code is good.// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.// Also it's contextual - if asked for no M in the format then I should probably // be doing no calculating here. months -= 1; } while (months < 0) { months += 12; years -= 1; } milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years); // This next block of code adds in values that // aren't requested. This allows the user to ask for the // number of months and get the real count and not just 0->11. if (!Token.containsTokenWithValue(tokens, y)) { if (Token.containsTokenWithValue(tokens, M)) { months += 12 * years; years = 0; } else { // TODO: this is a bit weak, needs work to know about leap years days += 365 * years; years = 0; } } if (!Token.containsTokenWithValue(tokens, M)) { days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); months = 0; } if (!Token.containsTokenWithValue(tokens, d)) { hours += 24 * days; days = 0; } if (!Token.containsTokenWithValue(tokens, H)) { minutes += 60 * hours; hours = 0; } if (!Token.containsTokenWithValue(tokens, m)) { seconds += 60 * minutes; minutes = 0; } if (!Token.containsTokenWithValue(tokens, s)) { milliseconds += 1000 * seconds; seconds = 0; } return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); }",
        "PatCode": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) { long millis = endMillis - startMillis; if (millis < 28 * DateUtils.MILLIS_PER_DAY) { return formatDuration(millis, format, padWithZeros); } Token[] tokens = lexx(format); // timezones get funky around 0, so normalizing everything to GMT // stops the hours being off Calendar start = Calendar.getInstance(timezone); start.setTime(new Date(startMillis)); Calendar end = Calendar.getInstance(timezone); end.setTime(new Date(endMillis)); // initial estimates int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); // each initial estimate is adjusted in case it is under 0 while (milliseconds < 0) { milliseconds += 1000; seconds -= 1; } while (seconds < 0) { seconds += 60; minutes -= 1; } while (minutes < 0) { minutes += 60; hours -= 1; } while (hours < 0) { hours += 24; days -= 1; } while (days < 0) { days += 31;//days += 31; // TODO: Need tests to show this is bad and the new code is good.// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.// Also it's contextual - if asked for no M in the format then I should probably // be doing no calculating here. months -= 1; } while (months < 0) { months += 12; years -= 1; } milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(end, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years); // This next block of code adds in values that // aren't requested. This allows the user to ask for the // number of months and get the real count and not just 0->11. if (!Token.containsTokenWithValue(tokens, y)) { if (Token.containsTokenWithValue(tokens, M)) { months += 12 * years; years = 0; } else { // TODO: this is a bit weak, needs work to know about leap years days += 365 * years; years = 0; } } if (!Token.containsTokenWithValue(tokens, M)) { days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); months = 0; } if (!Token.containsTokenWithValue(tokens, d)) { hours += 24 * days; days = 0; } if (!Token.containsTokenWithValue(tokens, H)) { minutes += 60 * hours; hours = 0; } if (!Token.containsTokenWithValue(tokens, m)) { seconds += 60 * minutes; minutes = 0; } if (!Token.containsTokenWithValue(tokens, s)) { milliseconds += 1000 * seconds; seconds = 0; } return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); }"
      }
    ]
  },
  {
    "PatchId": "Math_85_Nopol_patch_18172_1.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (-1 == fb) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_95_jGenProg_patch_1713000_3956.diff",
    "BugId": "Math_95",
    "PatchedMethods": [
      {
        "DevIntention": "get|initial|domain",
        "OrgCode": "protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); // use mean ret = d / (d - 2.0); return ret; }",
        "PatCode": "protected double getInitialDomain(double p) { double ret; double d = getDenominatorDegreesOfFreedom(); // use meanret = d / (d - 2.0); ret = 0.0; return ret; }"
      }
    ]
  },
  {
    "PatchId": "Math_62_Avatar_Patch_663421_273.diff",
    "BugId": "Math_62",
    "PatchedMethods": [
      {
        "DevIntention": "optimize",
        "OrgCode": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException { optima = new UnivariateRealPointValuePair[starts]; totalEvaluations = 0; // Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { optima[i] = null; } final int usedEvaluations = optimizer.getEvaluations(); optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations); totalEvaluations += usedEvaluations; } sortPairs(goal); if (optima[0] == null) { throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts); } // Return the point with the best objective function value. return optima[0]; }",
        "PatCode": "public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException { optima = new UnivariateRealPointValuePair[starts]; totalEvaluations = 0; // Multi-start loop. for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { optima[i] = null; } final int usedEvaluations = optimizer.getEvaluations(); optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations); totalEvaluations += usedEvaluations; } sortPairs(goal); if (optima[0] == null) { throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts); } // Return the point with the best objective function value. return optima[0]; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19269874_961.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      },
      {
        "DevIntention": "copy|array",
        "OrgCode": "private void copyArray(final double[] src, final double[] dest) { System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); }",
        "PatCode": "private void copyArray(final double[] src, final double[] dest) { if (src != null) {System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);} }"
      }
    ]
  },
  {
    "PatchId": "Math_82_TBar_Patch_12384523_2382_cp1069.diff",
    "BugId": "Math_82",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = rhs; minRatioPos = i; } } } return minRatioPos; }"
      }
    ]
  },
  {
    "PatchId": "Math_33_dynamoth_patch_4236208_11.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "normalize",
        "OrgCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }",
        "PatCode": "private LinearConstraint normalize(final LinearConstraint constraint) { if ((this.getOriginalNumDecisionVariables() - 1) == 1) { if (constraint.getValue() < 0) { return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()); } } return new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()); }"
      }
    ]
  },
  {
    "PatchId": "Math_49_Nopol_patch_112674_1.diff",
    "BugId": "Math_49",
    "PatchedMethods": [
      {
        "DevIntention": "set|entry",
        "OrgCode": "public void setEntry(int index, double value) { checkIndex(index); if (!isDefaultValue(value)) { entries.put(index, value); } else if (entries.containsKey(index)) { entries.remove(index); } }",
        "PatCode": "public void setEntry(int index, double value) { checkIndex(index); if (!isDefaultValue(value)) { entries.put(index, value); } else if (entries.containsKey(index)) { if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) { entries.remove(index); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_929846_29_cp23.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), ftol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_81_kPAR_Patch_3744498_630_cp348.diff",
    "BugId": "Math_81",
    "PatchedMethods": [
      {
        "DevIntention": "compute|shift|increment",
        "OrgCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] > b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }",
        "PatCode": "private void computeShiftIncrement(final int start, final int end, final int deflated) { final double cnst1 = 0.563; final double cnst2 = 1.010; final double cnst3 = 1.05; // a negative dMin forces the shift to take that absolute value // tType records the type of shift. if (dMin <= 0.0) { tau = -dMin; tType = -1; return; } int nn = 4 * end + pingPong - 1; switch (deflated) { case 0 : // no realEigenvalues deflated. if (dMin == dN || dMin == dN1) { double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]); double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]); double a2 = work[nn - 7] + work[nn - 5]; if (dMin == dN && dMin1 == dN1) { // cases 2 and 3. final double gap2 = dMin2 - a2 - dMin2 * 0.25; final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2)); if (gap1 > 0.0 && gap1 > b1) { tau = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin); tType = -2; } else { double s = 0.0; if (dN > b1) { s = dN - b1; } if (a2 > (b1 + b2)) { s = Math.min(s, a2 - (b1 + b2)); } tau = Math.max(s, 0.333 * dMin); tType = -3; } } else { // case 4. tType = -4; double s = 0.25 * dMin; double gam; int np; if (dMin == dN) { gam = dN; a2 = 0.0; if (work[nn - 5] > work[nn - 7]) { return; } b2 = work[nn - 5] / work[nn - 7]; np = nn - 9; } else { np = nn - 2 * pingPong; b2 = work[np - 2]; gam = dN1; if (work[np - 4] > work[np - 2]) { return; } a2 = work[np - 4] / work[np - 2]; if (work[nn - 9] > work[nn - 11]) { return; } b2 = work[nn - 9] / work[nn - 11]; np = nn - 13; } // approximate contribution to norm squared from i < nn-1. a2 = a2 + b2; for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if(b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; // rayleigh quotient residual bound. if (a2 < cnst1) { s = gam * (1 - Math.sqrt(a2)) / (1 + a2); } tau = s; } } else if (dMin == dN2) { // case 5. tType = -5; double s = 0.25 * dMin; // compute contribution to norm squared from i > nn-2. final int np = nn - 2 * pingPong; double b1 = work[np - 2]; double b2 = work[np - 6]; final double gam = dN2; if (work[np - 8] <= b2 || work[np - 4] > b1) { return; } double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1); // approximate contribution to norm squared from i < nn-2. if (end - start > 2) { b2 = work[nn - 13] / work[nn - 15]; a2 = a2 + b2; for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (b2 == 0.0) { break; } b1 = b2; if (work[i4] > work[i4 - 2]) { return; } b2 = b2 * (work[i4] / work[i4 - 2]); a2 = a2 + b2; if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) { break; } } a2 = cnst3 * a2; } if (a2 < cnst1) { tau = gam * (1 - Math.sqrt(a2)) / (1 + a2); } else { tau = s; } } else { // case 6, no information to guide us. if (tType == -6) { g += 0.333 * (1 - g); } else if (tType == -18) { g = 0.25 * 0.333; } else { g = 0.25; } tau = g * dMin; tType = -6; } break; case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. if (dMin1 == dN1 && dMin2 == dN2) { // cases 7 and 8. tType = -7; double s = 0.333 * dMin1; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0) { for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { final double oldB1 = b1; if (work[i4] > work[i4 - 2]) { return; } b1 = b1 * (work[i4] / work[i4 - 2]); b2 = b2 + b1; if (100 * Math.max(b1, oldB1) < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin1 / (1 + b2 * b2); final double gap2 = 0.5 * dMin2 - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); tType = -8; } } else { // case 9. tau = 0.25 * dMin1; if (dMin1 == dN1) { tau = 0.5 * dMin1; } tType = -9; } break; case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN. // cases 10 and 11. if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { tType = -10; final double s = 0.333 * dMin2; if (work[nn - 5] > work[nn - 7]) { return; } double b1 = work[nn - 5] / work[nn - 7]; double b2 = b1; if (b2 != 0.0){ for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) { if (work[i4] > work[i4 - 2]) { return; } b1 *= work[i4] / work[i4 - 2]; b2 += b1; if (100 * b1 < b2) { break; } } } b2 = Math.sqrt(cnst3 * b2); final double a2 = dMin2 / (1 + b2 * b2); final double gap2 = work[nn - 7] + work[nn - 9] - Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2; if (gap2 > 0.0 && gap2 > b2 * a2) { tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2)); } else { tau = Math.max(s, a2 * (1 - cnst2 * b2)); } } else { tau = 0.25 * dMin2; tType = -11; } break; default : // case 12, more than two realEigenvalues deflated. no information. tau = 0.0; tType = -12; } }"
      }
    ]
  },
  {
    "PatchId": "Closure_2_TBar_Patch_4310468_112_cp55.diff",
    "BugId": "Closure_2",
    "PatchedMethods": [
      {
        "DevIntention": "check|interface|conflict|properties",
        "OrgCode": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { if (!interfaceType.getPropertyType(name).isEquivalentTo( oType.getPropertyType(name))) { compiler.report( t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString())); } } currentProperties.put(name, interfaceType); } for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); } }",
        "PatCode": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType) { ObjectType implicitProto = interfaceType.getImplicitPrototype(); Set<String> currentPropertyNames; // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). if (implicitProto == null) implicitProto = interfaceType; currentPropertyNames = implicitProto.getOwnPropertyNames(); for (String name : currentPropertyNames) { ObjectType oType = properties.get(name); if (oType != null) { if (!interfaceType.getPropertyType(name).isEquivalentTo( oType.getPropertyType(name))) { compiler.report( t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE, functionName, name, oType.toString(), interfaceType.toString())); } } currentProperties.put(name, interfaceType); } for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) { checkInterfaceConflictProperties(t, n, functionName, properties, currentProperties, iType); } }"
      }
    ]
  },
  {
    "PatchId": "Math_88_kPAR_Patch_526592_155_cp50.diff",
    "BugId": "Math_88",
    "PatchedMethods": [
      {
        "DevIntention": "get|solution",
        "OrgCode": "protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables()); double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } } } } return new RealPointValuePair(coefficients, f.getValue(coefficients)); }",
        "PatCode": "protected RealPointValuePair getSolution() { double[] coefficients = new double[getOriginalNumDecisionVariables()]; Integer basicRow = getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables()); double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset()); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative); if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, i) == 1) { coefficients[i] = 0; } } } } return new RealPointValuePair(coefficients, f.getValue(coefficients)); }"
      }
    ]
  },
  {
    "PatchId": "Lang_10_Avatar_Patch_15480007_1950.diff",
    "BugId": "Lang_10",
    "PatchedMethods": [
      {
        "DevIntention": "parse|token",
        "OrgCode": "protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { // Scan a run of the same character, which indicates a time // pattern. buf.append(c); while (i + 1 < length) { char peek = pattern.charAt(i + 1); if (peek == c) { buf.append(c); i++; } else { break; } } } else { // This will identify token as text. buf.append('\\''); boolean inLiteral = false; for (; i < length; i++) { c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { // '' is treated as escaped ' i++; buf.append(c); } else { inLiteral = !inLiteral; } } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { i--; break; } else { buf.append(c); } } } indexRef[0] = i; return buf.toString(); }",
        "PatCode": "protected String parseToken(String pattern, int[] indexRef) { StringBuilder buf = new StringBuilder(); int i = indexRef[0]; int length = pattern.length(); char c = pattern.charAt(i); if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { // Scan a run of the same character, which indicates a time // pattern. buf.append(c); while (i + 1 < length) { char peek = pattern.charAt(i + 1); if (peek == c) { buf.append(c); i++; } else { break; } } } else { // This will identify token as text. buf.append('\\''); boolean inLiteral = false; for (; i < length; i++) { c = pattern.charAt(i); if (c == '\\'') { if (i + 1 < length && pattern.charAt(i + 1) == '\\'') { // '' is treated as escaped ' i++; buf.append(c); } else { inLiteral = !inLiteral; } } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { i--; break; } else { buf.append(c); } } } indexRef[0] = i; return buf.toString(); }"
      },
      {
        "DevIntention": "estimate|length",
        "OrgCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { int len = mValues[i].length(); if (len > max) { max = len; } } return max; }",
        "PatCode": "public int estimateLength() { int max = 0; for (int i=mValues.length; --i >= 0; ) { if (mValues == null) return LONG; int len = mValues[i].length(); if (len > max) { max = len; } } return max; }"
      },
      {
        "DevIntention": "escape|regex",
        "OrgCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "PatCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }"
      },
      {
        "DevIntention": "add|regex",
        "OrgCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }",
        "PatCode": "public boolean addRegex(FastDateParser parser, StringBuilder regex) { regex.append('('); for(KeyValue textKeyValue : parser.getDisplayNames(field)) { escapeRegex(regex, textKeyValue.key, false).append('|'); } regex.setCharAt(regex.length()-1, ')'); return true; }"
      }
    ]
  },
  {
    "PatchId": "Chart_7_TBar_Patch_6550157_816_cp579.diff",
    "BugId": "Chart_7",
    "PatchedMethods": [
      {
        "DevIntention": "update|bounds",
        "OrgCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = index; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }",
        "PatCode": "private void updateBounds(TimePeriod period, int index) { long start = period.getStart().getTime(); long end = period.getEnd().getTime(); long middle = start + ((end - start) / 2); if (this.minStartIndex >= 0) { long minStart = getDataItem(this.minStartIndex).getPeriod() .getStart().getTime(); if (start < minStart) { this.minStartIndex = index; } } else { this.minStartIndex = index; } if (this.maxStartIndex >= 0) { long maxStart = getDataItem(this.maxStartIndex).getPeriod() .getStart().getTime(); if (start > maxStart) { this.maxStartIndex = index; } } else { this.maxStartIndex = index; } if (this.minMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long minMiddle = s + (e - s) / 2; if (middle < minMiddle) { this.minMiddleIndex = index; } } else { this.minMiddleIndex = index; } if (this.maxMiddleIndex >= 0) { long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() .getTime(); long maxMiddle = s + (e - s) / 2; if (middle > maxMiddle) { this.maxMiddleIndex = this.maxStartIndex; } } else { this.maxMiddleIndex = index; } if (this.minEndIndex >= 0) { long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd() .getTime(); if (end < minEnd) { this.minEndIndex = index; } } else { this.minEndIndex = index; } if (this.maxEndIndex >= 0) { long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() .getTime(); if (end > maxEnd) { this.maxEndIndex = index; } } else { this.maxEndIndex = index; } }"
      }
    ]
  },
  {
    "PatchId": "Lang_58_kPAR_Patch_1804587_232_cp160.diff",
    "BugId": "Lang_58",
    "PatchedMethods": [
      {
        "DevIntention": "create|number",
        "OrgCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }",
        "PatCode": "public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { // this is protection for poorness in java.lang.BigDecimal. // it accepts this as a legal value, but it does not appear // to be in specification of class. OS X Java parses it to // a wrong value. return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } //Requesting a specific type.. String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if ((!Character.isDigit(lastChar)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { //Too big for a long } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { //If it's too big for a float or the float value = 0 and the string //has non-zeros in it, then float does not have the precision we want return f; } } catch (NumberFormatException nfe) { // ignore the bad number } //Fall through case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { // ignore the bad number } //Fall through default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { //User doesn't have a preference on the return type, so let's start //small and go from there... if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { //Must be an int,long,bigint try { return createInteger(str); } catch (NumberFormatException nfe) { // ignore the bad number } try { return createLong(str); } catch (NumberFormatException nfe) { // ignore the bad number } return createBigInteger(str); } else { //Must be a float,double,BigDec boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { // ignore the bad number } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { // ignore the bad number } return createBigDecimal(str); } } }"
      }
    ]
  },
  {
    "PatchId": "Math_33_Avatar_Patch_19613718_970.diff",
    "BugId": "Math_33",
    "PatchedMethods": [
      {
        "DevIntention": "get|constraint|type|counts",
        "OrgCode": "private int getConstraintTypeCounts(final Relationship relationship) { int count = 0; for (final LinearConstraint constraint : constraints) { if (constraint.getRelationship() == relationship) { ++count; } } return count; }",
        "PatCode": "private int getConstraintTypeCounts(final Relationship relationship) { int count = 0; if (constraints == null) { return 0;}for (final LinearConstraint constraint : constraints) { if (constraint.getRelationship() == relationship) { ++count; } } return count; }"
      },
      {
        "DevIntention": "get|basic|row",
        "OrgCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }",
        "PatCode": "protected Integer getBasicRow(final int col) { Integer row = null; for (int i = 0; i < getHeight(); i++) { final double entry = getEntry(i, col); if (Precision.equals(entry, 1d, maxUlps) && (row == null)) { row = i; } else if (!Precision.equals(entry, 0d, maxUlps)) { return null; } } return row; }"
      }
    ]
  },
  {
    "PatchId": "Closure_62_TBar_Patch_768256_13_cp13.diff",
    "BugId": "Closure_62",
    "PatchedMethods": [
      {
        "DevIntention": "format",
        "OrgCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno && charno < sourceExcerpt.length()) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "PatCode": "private String format(JSError error, boolean warning) { // extract source excerpt SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); // formatting the message StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); // padding equal to the excerpt and arrow at the end // charno == sourceExpert.length() means something is missing // at the end of the line if (excerpt.equals(LINE) && 0 <= charno) { for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }"
      }
    ]
  },
  {
    "PatchId": "Math_80_TBar_Patch_9956901_964_cp650.diff",
    "BugId": "Math_80",
    "PatchedMethods": [
      {
        "DevIntention": "flip|if|warranted",
        "OrgCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "PatCode": "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { // flip array int j = 4 * n - 1; for (int i = 0; i < j; i += 4) { for (int k = 0; k>=4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      }
    ]
  },
  {
    "PatchId": "Math_85_TBar_Patch_9881052_1058_cp818.diff",
    "BugId": "Math_85",
    "PatchedMethods": [
      {
        "DevIntention": "bracket",
        "OrgCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fa * fb >= 0.0 ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "PatCode": "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); if (fb == initial && (fa * fb >= 0.0) ) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }"
      }
    ]
  },
  {
    "PatchId": "Math_84_jMutRepair_patch_1000_8.diff",
    "BugId": "Math_84",
    "PatchedMethods": [
      {
        "DevIntention": "iterate|simplex",
        "OrgCode": "@Override protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { while (true) { incrementIterationsCounter(); // save the original vertex final RealPointValuePair[] original = simplex; final RealPointValuePair best = original[0]; // perform a reflection step final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator); if (comparator.compare(reflected, best) < 0) { // compute the expanded simplex final RealPointValuePair[] reflectedSimplex = simplex; final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); if (comparator.compare(reflected, expanded) <= 0) { // accept the reflected simplex simplex = reflectedSimplex; } return; } // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); if (comparator.compare(contracted, best) < 0) { // accept the contracted simplex // check convergence return; } } }",
        "PatCode": "@Override protected void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { while (true) { incrementIterationsCounter(); // save the original vertex final RealPointValuePair[] original = simplex; final RealPointValuePair best = original[0]; // perform a reflection step final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator); if (comparator.compare(reflected, best) < 0) { // compute the expanded simplex final RealPointValuePair[] reflectedSimplex = simplex; final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); if (comparator.compare(reflected, expanded) <= 0) { // accept the reflected simplex simplex = reflectedSimplex; } return; } // compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);if (comparator.compare(contracted, best) == 0) { // accept the contracted simplex // check convergence return; } } }"
      }
    ]
  },
  {
    "PatchId": "Chart_1_Avatar_Patch_11473047_1577.diff",
    "BugId": "Chart_1",
    "PatchedMethods": [
      {
        "DevIntention": "get|legend|items",
        "OrgCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (dataset != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }",
        "PatCode": "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); if (this.baseURLGenerator != null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_3047938_107_cp86.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (((f1 >= 0))) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Math_101_dynamoth_patch_20271_1.diff",
    "BugId": "Math_101",
    "PatchedMethods": [
      {
        "DevIntention": "parse",
        "OrgCode": "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); // parse whitespace parseAndIgnoreWhitespace(source, pos); // parse real Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { // invalid real number // set index back to initial, error index should already be set // character examined. pos.setIndex(initialIndex); return null; } // parse sign int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : // no sign // return real only complex number return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : // invalid sign // set index back to initial, error index should be the last // character examined. pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } // parse whitespace parseAndIgnoreWhitespace(source, pos); // parse imaginary Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { // invalid imaginary number // set index back to initial, error index should already be set // character examined. pos.setIndex(initialIndex); return null; } // parse imaginary character int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) { // set index back to initial, error index should be the start index // character examined. pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); }",
        "PatCode": "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); // parse whitespace parseAndIgnoreWhitespace(source, pos); // parse real Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { // invalid real number // set index back to initial, error index should already be set // character examined. pos.setIndex(initialIndex); return null; } // parse sign int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : // no sign // return real only complex number return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : // invalid sign // set index back to initial, error index should be the last // character examined. pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } // parse whitespace parseAndIgnoreWhitespace(source, pos); // parse imaginary Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { // invalid imaginary number // set index back to initial, error index should already be set // character examined. pos.setIndex(initialIndex); return null; } // parse imaginary character int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; if ( startIndex == source.length()) { // set index back to initial, error index should be the start index // character examined. pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); }"
      }
    ]
  },
  {
    "PatchId": "Chart_13_FixMiner_Patch_5311251_654.diff",
    "BugId": "Chart_13",
    "PatchedMethods": [
      {
        "DevIntention": "arrange|f|f",
        "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }",
        "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); }"
      }
    ]
  },
  {
    "PatchId": "Math_28_TBar_Patch_9199099_243_cp202.diff",
    "BugId": "Math_28",
    "PatchedMethods": [
      {
        "DevIntention": "get|pivot|row",
        "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row == tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }",
        "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) { // create a list of all the rows that tie for the lowest score in the minimum ratio test List<Integer> minRatioPositions = new ArrayList<Integer>(); double minRatio = Double.MAX_VALUE; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); if (Precision.compareTo(entry, 0d, maxUlps) > 0) { final double ratio = rhs / entry; // check if the entry is strictly equal to the current min ratio // do not use a ulp/epsilon check final int cmp = Double.compare(ratio, minRatio); if (cmp == 0) { minRatioPositions.add(i); } else if (cmp < 0) { minRatio = ratio; minRatioPositions = new ArrayList<Integer>(); minRatioPositions.add(i); } } } if (minRatioPositions.size() == 0) { return null; } else if (minRatioPositions.size() > 1) { // there's a degeneracy as indicated by a tie in the minimum ratio test // 1. check if there's an artificial variable that can be forced out of the basis for (Integer row : minRatioPositions) { for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { int column = i + tableau.getArtificialVariableOffset(); final double entry = tableau.getEntry(row, column); if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { return row; } } } // 2. apply Bland's rule to prevent cycling: // take the row for which the corresponding basic variable has the smallest index // // see http://www.stanford.edu/class/msande310/blandrule.pdf // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) // // Additional heuristic: if we did not get a solution after half of maxIterations // revert to the simple case of just returning the top-most row // This heuristic is based on empirical data gathered while investigating MATH-828. Integer minRow = null; int minIndex = tableau.getWidth(); for (Integer row : minRatioPositions) { int i = tableau.getNumObjectiveFunctions(); for (; i < tableau.getWidth() - 1 && minRow != row; i++) { if (row!=tableau.getBasicRow(i)) { if (i < minIndex) { minIndex = i; minRow = row; } } } } return minRow; } return minRatioPositions.get(0); }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_1013184_7598.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString());int strLen = str.length(); ensureCapacity(size + 4); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Math_30_TBar_Patch_2230742_124_cp60.diff",
    "BugId": "Math_30",
    "PatchedMethods": [
      {
        "DevIntention": "calculate|asymptotic|p|value",
        "OrgCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "PatCode": "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { final int n1n2prod = n1 * n2; // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1f) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      }
    ]
  },
  {
    "PatchId": "Math_50_kPAR_Patch_353932_6_cp6.diff",
    "BugId": "Math_50",
    "PatchedMethods": [
      {
        "DevIntention": "do|solve",
        "OrgCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }",
        "PatCode": "protected final double doSolve() { // Get initial solution double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); // If one of the bounds is the exact root, return it. Since these are // not under-approximations or over-approximations, we can return them // regardless of the allowed solutions. if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } // Verify bracketing of initial solution. verifyBracketing(x0, x1); // Get accuracies. final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); // Keep track of inverted intervals, meaning that the left bound is // larger than the right bound. boolean inverted = false; // Keep finding better approximations. while (true) { // Calculate the next approximation. final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); // If the new approximation is the exact root, return it. Since // this is not an under-approximation or an over-approximation, // we can return it regardless of the allowed solutions. if (fx == 0.0) { return x; } // Update the bounds with the new approximation. if (f1 * fx < 0) { // The value of x1 has switched to the other bound, thus inverting // the interval. x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: // Nothing. if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(f1); } break; default: // Should never happen. throw new MathInternalError(); } } // Update from [x0, x1] to [x0, x]. x1 = x; f1 = fx; // If the function value of the last approximation is too small, // given the function value accuracy, then we can't get closer to // the root than we already are. if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } // If the current interval is within the given accuracies, we // are satisfied with the current approximation. if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_22_jGenProg_patch_173000_178.diff",
    "BugId": "Closure_22",
    "PatchedMethods": [
      {
        "DevIntention": "visit",
        "OrgCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; } String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }",
        "PatCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {} else else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; } String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }"
      }
    ]
  },
  {
    "PatchId": "Closure_22_jKali_patch_84000_37.diff",
    "BugId": "Closure_22",
    "PatchedMethods": [
      {
        "DevIntention": "visit",
        "OrgCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; } String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }",
        "PatCode": "public void visit(NodeTraversal t, Node n, Node parent) { // VOID nodes appear when there are extra semicolons at the BLOCK level. // I've been unable to think of any cases where this indicates a bug, // and apparently some people like keeping these semicolons around, // so we'll allow it. if (n.isEmpty() || n.isComma()) { return; } if (parent == null) { return; } // Do not try to remove a block or an expr result. We already handle // these cases when we visit the child, and the peephole passes will // fix up the tree in more clever ways when these are removed. if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {} else else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; } String msg = \"This code lacks side-effects. Is there a bug?\"; if (n.isString()) { msg = \"Is there a missing '+' on the previous line?\"; } else if (isSimpleOp) { msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() + \"' operator is not being used.\"; } t.getCompiler().report( t.makeError(n, level, USELESS_CODE_ERROR, msg)); // TODO(johnlenz): determine if it is necessary to // try to protect side-effect free statements as well. if (!NodeUtil.isStatement(n)) { problemNodes.add(n); } } }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_467770_3668.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": " public org.apache.commons.lang.text.StrBuilder appendFixedWidthPadRight(java.lang.Object obj, int width, char padChar) { ensureCapacity(size + 5); if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_585261_4438.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": " public org.apache.commons.lang.text.StrBuilder appendFixedWidthPadRight(java.lang.Object obj, int width, char padChar) { ensureCapacity(size + 5); if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  },
  {
    "PatchId": "Lang_59_jGenProg_patch_880178_6564.diff",
    "BugId": "Lang_59",
    "PatchedMethods": [
      {
        "DevIntention": "append|fixed|width|pad|right",
        "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "PatCode": " public org.apache.commons.lang.text.StrBuilder appendFixedWidthPadRight(java.lang.Object obj, int width, char padChar) { buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY]; if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { str.getChars(0, strLen, buffer, size); } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }"
      }
    ]
  }
]
0<ml>Math-7_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java for ( final StepHandler handler : stepHandlers ) { handler . handleStep ( interpolator , isLastStep ) ; } <ml>a / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java b / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java for ( final StepHandler handler : stepHandlers ) { if ( org . apache . commons . math3 . ode . AbstractIntegrator . this . stepHandlers . size ( ) = = orderingSign ) { handler . handleStep ( interpolator , isLastStep ) ; } } 
0<ml>Math-82_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; <ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( org . apache . commons . math . optimization . linear . SimplexSolver . DEFAULT_EPSILON = = minValue ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ; 
0<ml>Chart-17_P_Patch_1_1.txt<ml>a / source / org / jfree / data / time / TimeSeries . java if ( end < start ) { throw new IllegalArgumentException ( " Requires start < = end . " ) ; } <ml>b / source / org / jfree / data / time / TimeSeries . java if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( " Requires start < = end . " ) ; } } 
0<ml>Chart-13_P_Patch_1_1.txt<ml>a / source / org / jfree / chart / block / BorderArrangement . java h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } <ml>b / source / org / jfree / chart / block / BorderArrangement . java h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( null ! = null ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } 
0<ml>Lang-58_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java } throw new NumberFormatException ( str + " is not a valid number . " ) ; case ' f ' : <ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java b / src / java / org / apache / commons / lang / math / NumberUtils . java } if ( ( numeric . length ( ) ) ! = ( org . apache . commons . lang . math . NumberUtils . SHORT_ONE ) ) { throw new NumberFormatException ( str + " is not a valid number . " ) ; } case ' f ' : 
0<ml>Chart-25_P_Patch_1_1.txt<ml>a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } <ml>a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java PlotOrientation orientation = plot . getOrientation ( ) ; if ( 3 = = 0 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } 
0<ml>Math-81_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { <ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java gam = dN ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { a2 = 0 . 0 ; } if ( work [ nn - 5 ] > work [ nn - 7 ] ) { 
0<ml>Math-49_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } <ml>a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java b / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java entries . put ( index , value ) ; } else { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } 
0<ml>Math-4_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / Line . java if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } <ml>a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / Line . java b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / Line . java if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( other . sin < 1 ) & & ( other . sin < 1 ) ) | | ( ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ! = ( d ) ) ) { return null ; } } 
0<ml>Chart-21_P_Patch_1_1.txt<ml>a / source / org / jfree / data / Range . java if ( ! ( this . lower = = range . lower ) ) { return false ; } <ml>b / source / org / jfree / data / Range . java if ( ! ( this . lower = = range . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } } 
0<ml>Math-78_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java / / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ; <ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java / / Fall back to bisection . if ( y0 < 1 ) { delta = 0 . 5 * dx ; } oldDelta = delta ; 
0<ml>Lang-55_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / time / StopWatch . java } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; <ml>a / src / java / org / apache / commons / lang / time / StopWatch . java b / src / java / org / apache / commons / lang / time / StopWatch . java } if ( org . apache . commons . lang . time . StopWatch . this . stopTime < 10 ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; 
0<ml>Lang-51_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / BooleanUtils . java char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } <ml>b / src / java / org / apache / commons / lang / BooleanUtils . java char ch = str . charAt ( 0 ) ; if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } 
0<ml>Math-80_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } <ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java for ( int i = 0 ; i < j ; i + = 4 ) { if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } } 
0<ml>Time-14_P_Patch_1_1.txt<ml>a / src / main / java / org / joda / time / chrono / BasicMonthOfYearDateTimeField . java / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; <ml>a / src / main / java / org / joda / time / chrono / BasicMonthOfYearDateTimeField . java b / src / main / java / org / joda / time / chrono / BasicMonthOfYearDateTimeField . java / / month is largest field and being added to , such as month - day if ( ( org . joda . time . chrono . BasicMonthOfYearDateTimeField . MIN < = fieldIndex ) | | ( ( ! ( 1 = = valueToAdd ) ) & & ( ( valueToAdd ) ! = ( - 1 ) ) ) ) { long instant = 0L ; 
0<ml>Math-42_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; } <ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java b / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java if ( getBasicRow ( col ) = = null ) { if ( 0 < org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } } 
0<ml>Math-105_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java if ( n = = 0 ) { xbar = x ; ybar = y ; <ml>a / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java b / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java if ( n = = 0 ) { if ( ( ( ! ( ( x ) ! = ( 1 ) ) ) & & ( ! ( ( x ) ! = ( 1 ) ) ) ) | | ( y < x ) ) { xbar = x ; } ybar = y ; 
0<ml>Lang-44_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / NumberUtils . java case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } <ml>b / src / java / org / apache / commons / lang / NumberUtils . java case ' L ' : if ( ( 1 ) ! = ( val . length ( ) ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } } 
0<ml>Math-69_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } <ml>a / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java b / src / main / java / org / apache / commons / math / stat / correlation / PearsonsCorrelation . java RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; if ( ( nVars ) ! = ( 2 ) ) { for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } } 
0<ml>Math-18_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java ! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = true ; break ; <ml>a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java ! Double . isInfinite ( uB [ i ] ) ) { if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . checkFeasableCount = = org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . iterations ) { hasFiniteBounds = true ; } break ; 
0<ml>Math-73_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverImpl . java protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( " invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } " , lower , initial , upper ) ; } <ml>a / src / main / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverImpl . java b / src / main / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverImpl . java protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ! ( lower < initial ) ) | | ( ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < = lower ) & & ( 1 = = lower ) ) ) { throw MathRuntimeException . createIllegalArgumentException ( " invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } " , lower , initial , upper ) ; } 
0<ml>Math-58_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java / / compute the Newton correction for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } <ml>a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java b / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java / / compute the Newton correction if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } } 
0<ml>Math-33_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } <ml>a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexTableau . java if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( 2 ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) { columnsToDrop . add ( i ) ; } } 
0<ml>Math-20_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; oldFac + = 1 . - ccov1 - ccovmu ; if ( isActiveCMA ) { <ml>a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . inputSigma ! = null ) { oldFac + = 1 . - ccov1 - ccovmu ; } if ( isActiveCMA ) { 
0<ml>Math-41_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / stat / descriptive / moment / Mean . java } return xbarw + ( correction / sumw ) ; } <ml>a / src / main / java / org / apache / commons / math / stat / descriptive / moment / Mean . java b / src / main / java / org / apache / commons / math / stat / descriptive / moment / Mean . java } if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } } 
0<ml>Math-87_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } <ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java if ( ! restrictToNonNegative ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables < height ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } 
0<ml>Math-2_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } <ml>a / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java b / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java tmp = mu + k * sigma ; if ( sigma = = lower ) { if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } 
0<ml>Chart-9_P_Patch_1_1.txt<ml>a / source / org / jfree / data / time / TimeSeries . java if ( end < start ) { throw new IllegalArgumentException ( " Requires start < = end . " ) ; } <ml>b / source / org / jfree / data / time / TimeSeries . java if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( " Requires start < = end . " ) ; } } 
0<ml>Lang-53_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / time / DateUtils . java / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } <ml>a / src / java / org / apache / commons / lang / time / DateUtils . java b / src / java / org / apache / commons / lang / time / DateUtils . java / / reset time if ( seconds < = org . apache . commons . lang . time . DateUtils . fields . length ) { if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } } 
0<ml>Chart-13_P_Patch_473_422.txt<ml> / tmp / Cardumen_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } else if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; } protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange2 ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } <ml> / tmp / Cardumen_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { contentSize =                                                                                                                                                                                                                                                                                 new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } else if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; } protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange2 ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } 
0<ml>Chart-6_P_Patch_659_644.txt<ml> / tmp / Cardumen_Defects4J_Chart_6 / source / org / jfree / chart / util / ShapeListjava public void setShape ( int index , java . awt . Shape shape ) { set ( index , shape ) ; } <ml> / tmp / Cardumen_Defects4J_Chart_6 / source / org / jfree / chart / util / ShapeListjava public void setShape ( int index , java . awt . Shape shape ) { set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; } 
0<ml>Math-85_P_Patch_3093_2946.txt<ml> / tmp / Cardumen_Defects4J_Math_85 / src / java / org / apache / commons / math / distribution / NormalDistributionImpljava if ( p < 0 . 5 ) { ret = - ( java . lang . Double . MAX_VALUE ) ; } else { ret = getMean ( ) ; } return ret ; <ml> / tmp / Cardumen_Defects4J_Math_85 / src / java / org / apache / commons / math / distribution / NormalDistributionImpljava if ( p < 0 . 5 ) { ret = - ( java . lang . Double . MAX_VALUE ) ; } else { ret = ( ( standardDeviation ) - ( standardDeviation ) ) / ( ( mean ) * ( java . lang . Math . sqrt ( 2 . 0 ) ) ) ; } return ret ; 
0<ml>Math-95_P_Patch_33_32.txt<ml> / tmp / Cardumen_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpljava protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; } <ml> / tmp / Cardumen_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpljava protected double getInitialDomain ( double p ) { double ret ; double d = p - 2 . 0 ; ret = d / ( d - 2 . 0 ) ; return ret ; } 
0<ml>Closure-63_P_Patch_33_33.txt<ml> / tmp / Cardumen_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( java . lang . Character . isWhitespace ( c ) ) { <ml> / tmp / Cardumen_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava if ( sourceExcerpt ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( java . lang . Character . isWhitespace ( c ) ) { 
0<ml>Chart-24_P_Patch_286_286.txt<ml> / tmp / Cardumen_Defects4J_Chart_24 / source / org / jfree / chart / renderer / GrayPaintScalejava public java . awt . Paint getPaint ( double value ) { double v = java . lang . Math . max ( value , this . lowerBound ) ; v = java . lang . Math . min ( v , this . upperBound ) ; int g = ( ( int ) ( ( ( value - ( this . lowerBound ) ) / ( ( this . upperBound ) - ( this . lowerBound ) ) ) * 255 . 0 ) ) ; return new java . awt . Color ( g , g , g ) ; } <ml> / tmp / Cardumen_Defects4J_Chart_24 / source / org / jfree / chart / renderer / GrayPaintScalejava public java . awt . Paint getPaint ( double value ) { double v = java . lang . Math . max ( value , this . lowerBound ) ; v = java . lang . Math . min ( v , this . upperBound ) ; int g = ( ( int ) ( ( ( java . lang . Math . min ( v , upperBound ) ) / ( ( this . upperBound ) - ( this . lowerBound ) ) ) * 255 . 0 ) ) ; return new java . awt . Color ( g , g , g ) ; } 
0<ml>Math-5_P_Patch_966_966.txt<ml> / tmp / Cardumen_Defects4J_Math_5 / src / main / java / org / apache / commons / math3 / complex / Complexjava @ java . lang . Override public boolean equals ( java . lang . Object other ) { if ( ( this ) = = other ) { return true ; } if ( other instanceof org . apache . commons . math3 . complex . Complex ) { <ml> / tmp / Cardumen_Defects4J_Math_5 / src / main / java / org / apache / commons / math3 / complex / Complexjava @ java . lang . Override public boolean equals ( java . lang . Object other ) { if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof org . apache . commons . math3 . complex . Complex ) { 
0<ml>Math-63_P_Patch_1_1.txt<ml> / tmp / Cardumen_Defects4J_Math_63 / src / main / java / org / apache / commons / math / util / MathUtilsjava public static boolean equals ( double x , double y ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( x = = y ) ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) ; } public static boolean equals ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x , y ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { assert ( maxUlps > 0 ) & & ( maxUlps < ( org . apache . commons . math . util . MathUtils . NAN_GAP ) ) ; long xInt = java . lang . Double . doubleToLongBits ( x ) ; long yInt = java . lang . Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - xInt ; } if ( yInt < 0 ) { yInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - yInt ; } final boolean isEqual = ( org . apache . commons . math . util . FastMath . abs ( ( xInt - yInt ) ) ) < = maxUlps ; return ( isEqual & & ( ! ( java . lang . Double . isNaN ( x ) ) ) ) & & ( ! ( java . lang . Double . isNaN ( y ) ) ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , maxUlps ) ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equals ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new java . lang . ArithmeticException ( " factorial value is too large to fit in a long " ) ; } return org . apache . commons . math . util . MathUtils . FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . MathUtils . factorial ( n ) ; } return org . apache . commons . math . util . FastMath . floor ( ( ( org . apache . commons . math . util . FastMath . exp ( org . apache . commons . math . util . MathUtils . factorialLog ( n ) ) ) + 0 . 5 ) ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . FastMath . log ( org . apache . commons . math . util . MathUtils . factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = org . apache . commons . math . util . FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = ( java . lang . Integer . MIN_VALUE ) ) | | ( v = = ( java . lang . Integer . MIN_VALUE ) ) ) { throw org . apache . commons . math . MathRuntimeException . createArithmeticException ( org . apache . commons . math . exception . util . LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return ( org . apache . commons . math . util . FastMath . abs ( u ) ) + ( org . apache . commons . math . util . FastMath . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( ( ( u & 1 ) = = 0 ) & & ( ( v & 1 ) = = 0 ) ) & & ( k < 31 ) ) { u / = 2 ; v / = 2 ; <ml> / tmp / Cardumen_Defects4J_Math_63 / src / main / java / org / apache / commons / math / util / MathUtilsjava public static boolean equals ( double x , double y ) { return (                                                                                                               ( ( ( ( ( NAN_GAP ) & 1 ) = = 0 ) & & ( ( ( NAN_GAP ) & 1 ) = = 0 ) ) & & ( ( NAN_GAP ) < 31 ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( x = = y ) ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) ; } public static boolean equals ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x , y ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { assert ( maxUlps > 0 ) & & ( maxUlps < ( org . apache . commons . math . util . MathUtils . NAN_GAP ) ) ; long xInt = java . lang . Double . doubleToLongBits ( x ) ; long yInt = java . lang . Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - xInt ; } if ( yInt < 0 ) { yInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - yInt ; } final boolean isEqual = ( org . apache . commons . math . util . FastMath . abs ( ( xInt - yInt ) ) ) < = maxUlps ; return ( isEqual & & ( ! ( java . lang . Double . isNaN ( x ) ) ) ) & & ( ! ( java . lang . Double . isNaN ( y ) ) ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , maxUlps ) ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equals ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new java . lang . ArithmeticException ( " factorial value is too large to fit in a long " ) ; } return org . apache . commons . math . util . MathUtils . FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . MathUtils . factorial ( n ) ; } return org . apache . commons . math . util . FastMath . floor ( ( ( org . apache . commons . math . util . FastMath . exp ( org . apache . commons . math . util . MathUtils . factorialLog ( n ) ) ) + 0 . 5 ) ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . FastMath . log ( org . apache . commons . math . util . MathUtils . factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = org . apache . commons . math . util . FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = ( java . lang . Integer . MIN_VALUE ) ) | | ( v = = ( java . lang . Integer . MIN_VALUE ) ) ) { throw org . apache . commons . math . MathRuntimeException . createArithmeticException ( org . apache . commons . math . exception . util . LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return ( org . apache . commons . math . util . FastMath . abs ( u ) ) + ( org . apache . commons . math . util . FastMath . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( ( ( u & 1 ) = = 0 ) & & ( ( v & 1 ) = = 0 ) ) & & ( k < 31 ) ) { u / = 2 ; v / = 2 ; 
0<ml>Closure-62_P_Patch_33_33.txt<ml> / tmp / Cardumen_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( java . lang . Character . isWhitespace ( c ) ) { <ml> / tmp / Cardumen_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava if ( sourceExcerpt ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( java . lang . Character . isWhitespace ( c ) ) { 
0<ml>Math-73_P_Patch_13_13.txt<ml> / tmp / Cardumen_Defects4J_Math_73 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolverjava return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } <ml> / tmp / Cardumen_Defects4J_Math_73 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolverjava return solve ( f , max , max ) ; } 
0<ml>Lang-27_P_Patch_2940_1929.txt<ml> / tmp / jGenProg_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > ( - 1 ) ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; } <ml> / tmp / jGenProg_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > ( - 1 ) ) {   mant = str ; } else { mant = str ; } dec = null ; } 
0<ml>Math-50_P_Patch_5_4.txt<ml> / tmp / jGenProg_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : <ml> / tmp / jGenProg_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava case REGULA_FALSI : if ( x = = x1 ) {  f0 = computeObjectiveValue ( x0 ) ; x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : 
0<ml>Chart-13_P_Patch_2461_1666.txt<ml> / tmp / jGenProg_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else { if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } } else if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; } protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange2 ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) { this . centerBlock = null ; this . topBlock = null ; this . bottomBlock = null ; this . leftBlock = null ; this . rightBlock = null ; } <ml> / tmp / jGenProg_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else {                                                                                                                                                                                                                                                                                         this . rightBlock = null ; if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } } else if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { throw new java . lang . RuntimeException ( " Not implemented . " ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; } protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange2 ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) { this . centerBlock = null ; this . topBlock = null ; this . bottomBlock = null ; this . leftBlock = null ; this . rightBlock = null ; } 
0<ml>Lang-39_P_Patch_2239_1901.txt<ml> / tmp / jGenProg_Defects4J_Lang_39 / src / java / org / apache / commons / lang3 / StringUtilsjava int increase = 0 ; for ( int i = 0 ; i < ( searchList . length ) ; i + + ) { int greater = ( replacementList [ i ] . length ( ) ) - ( searchList [ i ] . length ( ) ) ; if ( greater > 0 ) { increase + = 3 * greater ; } } increase = java . lang . Math . min ( increase , ( ( text . length ( ) ) / 5 ) ) ; <ml> / tmp / jGenProg_Defects4J_Lang_39 / src / java / org / apache / commons / lang3 / StringUtilsjava int increase = 0 ;       increase = java . lang . Math . min ( increase , ( ( text . length ( ) ) / 5 ) ) ; 
0<ml>Chart-25_P_Patch_5_3.txt<ml> / tmp / jGenProg_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRendererjava org . jfree . data . statistics . StatisticalCategoryDataset statData = ( ( org . jfree . data . statistics . StatisticalCategoryDataset ) ( data ) ) ; org . jfree . chart . plot . PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = ( org . jfree . chart . plot . PlotOrientation . HORIZONTAL ) ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = ( org . jfree . chart . plot . PlotOrientation . VERTICAL ) ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } <ml> / tmp / jGenProg_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRendererjava org . jfree . data . statistics . StatisticalCategoryDataset statData = ( ( org . jfree . data . statistics . StatisticalCategoryDataset ) ( data ) ) ; org . jfree . chart . plot . PlotOrientation orientation = plot . getOrientation ( ) ;         } 
0<ml>Math-81_P_Patch_16_12.txt<ml> / tmp / jGenProg_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava double a2 = ( ( work [ ( np - 8 ) ] ) / b2 ) * ( 1 + ( ( work [ ( np - 4 ) ] ) / b1 ) ) ; if ( ( end - start ) > 2 ) { b2 = ( work [ ( nn - 13 ) ] ) / ( work [ ( nn - 15 ) ] ) ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = ( ( ( 4 * start ) + 2 ) + ( pingPong ) ) ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( ( work [ i4 ] ) > ( work [ ( i4 - 2 ) ] ) ) { return ; } b2 = b2 * ( ( work [ i4 ] ) / ( work [ ( i4 - 2 ) ] ) ) ; a2 = a2 + b2 ; if ( ( ( 100 * ( java . lang . Math . max ( b2 , b1 ) ) ) < a2 ) | | ( cnst1 < a2 ) ) { break ; } } a2 = cnst3 * a2 ; } if ( a2 < cnst1 ) { tau = ( gam * ( 1 - ( java . lang . Math . sqrt ( a2 ) ) ) ) / ( 1 + a2 ) ; <ml> / tmp / jGenProg_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava double a2 = ( ( work [ ( np - 8 ) ] ) / b2 ) * ( 1 + ( ( work [ ( np - 4 ) ] ) / b1 ) ) ;                    if ( a2 < cnst1 ) { tau = ( gam * ( 1 - ( java . lang . Math . sqrt ( a2 ) ) ) ) / ( 1 + a2 ) ; 
0<ml>Math-85_P_Patch_5_2.txt<ml> / tmp / jGenProg_Defects4J_Math_85 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtilsjava ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb ) > = 0 . 0 ) { throw new org . apache . commons . math . ConvergenceException ( ( " number of iterations = { 0 } , maximum iterations = { 1 } , " + ( " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " ) ) , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; <ml> / tmp / jGenProg_Defects4J_Math_85 / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtilsjava ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb ) > = 0 . 0 ) {       } return new double [ ] { a , b } ; 
0<ml>Math-95_P_Patch_72_42.txt<ml> / tmp / jGenProg_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpljava double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; } <ml> / tmp / jGenProg_Defects4J_Math_95 / src / java / org / apache / commons / math / distribution / FDistributionImpljava double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; ret = 0 . 0 ; return ret ; } 
0<ml>Chart-5_P_Patch_37_27.txt<ml> / tmp / jGenProg_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeriesjava if ( this . autoSort ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; <ml> / tmp / jGenProg_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeriesjava if ( this . autoSort ) { add ( x , y , true ) ;  } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; 
0<ml>Math-84_P_Patch_803_248.txt<ml> / tmp / jGenProg_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectionaljava return ; } } <ml> / tmp / jGenProg_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectionaljava return ; } return ; } 
0<ml>Math-73_P_Patch_25_22.txt<ml> / tmp / jGenProg_Defects4J_Math_73 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolverjava if ( ( yInitial * yMax ) < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } <ml> / tmp / jGenProg_Defects4J_Math_73 / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolverjava if ( ( yInitial * yMax ) < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , max ) ;  } 
0<ml>Closure-22_P_Patch_64_46.txt<ml> / tmp / jGenProg_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava if ( n = = ( parent . getLastChild ( ) ) ) { for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) { continue ; } if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | <ml> / tmp / jGenProg_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava if ( n = = ( parent . getLastChild ( ) ) ) {         } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | 
0<ml>Math-60_P_Patch_133_92.txt<ml> / tmp / jGenProg_Defects4J_Math_60 / src / main / java / org / apache / commons / math / util / ContinuedFractionjava double r = p2 / q2 ; if ( java . lang . Double . isNaN ( r ) ) { throw new org . apache . commons . math . ConvergenceException ( org . apache . commons . math . exception . util . LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } relativeError = org . apache . commons . math . util . FastMath . abs ( ( ( r / c ) - 1 . 0 ) ) ; c = p2 / q2 ; p0 = p1 ; p1 = p2 ; q0 = q1 ; q1 = q2 ; } if ( n > = maxIterations ) { throw new org . apache . commons . math . MaxIterationsExceededException ( maxIterations , org . apache . commons . math . exception . util . LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; } return c ; <ml> / tmp / jGenProg_Defects4J_Math_60 / src / main / java / org / apache / commons / math / util / ContinuedFractionjava double r = p2 / q2 ; if ( java . lang . Double . isNaN ( r ) ) {             throw new org . apache . commons . math . MaxIterationsExceededException ( maxIterations , org . apache . commons . math . exception . util . LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; } relativeError = org . apache . commons . math . util . FastMath . abs ( ( ( r / c ) - 1 . 0 ) ) ; c = p2 / q2 ; p0 = p1 ; p1 = p2 ; q0 = q1 ; q1 = q2 ; } if ( n > = maxIterations ) { throw new org . apache . commons . math . MaxIterationsExceededException ( maxIterations , org . apache . commons . math . exception . util . LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; } return c ; 
0<ml>Math-8_P_Patch_9_5.txt<ml> / tmp / jGenProg_Defects4J_Math_8 / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistributionjava final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ; <ml> / tmp / jGenProg_Defects4J_Math_8 / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistributionjava final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) {  } return out ; 
0<ml>Chart-3_P_Patch_4211_3698.txt<ml> / tmp / jGenProg_Defects4J_Chart_3 / source / org / jfree / data / time / TimeSeriesjava public void add ( org . jfree . data . time . TimeSeriesDataItem item ) { add ( item , true ) ; } public void add ( org . jfree . data . time . TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new java . lang . IllegalArgumentException ( " Null ' item ' argument . " ) ; } item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( item . clone ( ) ) ) ; java . lang . Class c = item . getPeriod ( ) . getClass ( ) ; if ( ( this . timePeriodClass ) = = null ) { this . timePeriodClass = c ; } else if ( ! ( this . timePeriodClass . equals ( c ) ) ) { java . lang . StringBuffer b = new java . lang . StringBuffer ( ) ; b . append ( " You are trying to add data where the time period class " ) ; b . append ( " is " ) ; b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; b . append ( " , but the TimeSeries is expecting an instance of " ) ; b . append ( this . timePeriodClass . getName ( ) ) ; b . append ( " . " ) ; throw new org . jfree . data . general . SeriesException ( b . toString ( ) ) ; } boolean added = false ; int count = getItemCount ( ) ; if ( count = = 0 ) { this . data . add ( item ) ; added = true ; } else { org . jfree . data . time . RegularTimePeriod last = getTimePeriod ( ( ( getItemCount ( ) ) - 1 ) ) ; if ( ( item . getPeriod ( ) . compareTo ( last ) ) > 0 ) { this . data . add ( item ) ; added = true ; } else { int index = java . util . Collections . binarySearch ( this . data , item ) ; if ( index < 0 ) { this . data . add ( ( ( - index ) - 1 ) , item ) ; added = true ; } else { java . lang . StringBuffer b = new java . lang . StringBuffer ( ) ; b . append ( " You are attempting to add an observation for " ) ; b . append ( " the time period " ) ; b . append ( item . getPeriod ( ) . toString ( ) ) ; b . append ( " but the series already contains an observation " ) ; b . append ( " for that time period . Duplicates are not " ) ; b . append ( " permitted . Try using the addOrUpdate ( ) method . " ) ; throw new org . jfree . data . general . SeriesException ( b . toString ( ) ) ; } } } if ( added ) { updateBoundsForAddedItem ( item ) ; if ( ( getItemCount ( ) ) > ( this . maximumItemCount ) ) { org . jfree . data . time . TimeSeriesDataItem d = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( 0 ) ) ) ; updateBoundsForRemovedItem ( d ) ; } removeAgedItems ( false ) ; if ( notify ) { fireSeriesChanged ( ) ; } } } public void add ( org . jfree . data . time . RegularTimePeriod period , double value ) { add ( period , value , true ) ; } public void add ( org . jfree . data . time . RegularTimePeriod period , double value , boolean notify ) { org . jfree . data . time . TimeSeriesDataItem item = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; add ( item , notify ) ; } public void add ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { add ( period , value , true ) ; } public void add ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value , boolean notify ) { org . jfree . data . time . TimeSeriesDataItem item = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; add ( item , notify ) ; } public void update ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { org . jfree . data . time . TimeSeriesDataItem temp = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; int index = java . util . Collections . binarySearch ( this . data , temp ) ; if ( index < 0 ) { throw new org . jfree . data . general . SeriesException ( ( " There is no existing value for the " + " specified ' period ' . " ) ) ; } update ( index , value ) ; } public void update ( int index , java . lang . Number value ) { org . jfree . data . time . TimeSeriesDataItem item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . get ( index ) ) ) ; boolean iterate = false ; java . lang . Number oldYN = item . getValue ( ) ; if ( oldYN ! = null ) { double oldY = oldYN . doubleValue ( ) ; if ( ! ( java . lang . Double . isNaN ( oldY ) ) ) { iterate = ( oldY < = ( this . minY ) ) | | ( oldY > = ( this . maxY ) ) ; } } item . setValue ( value ) ; if ( iterate ) { findBoundsByIteration ( ) ; } else if ( value ! = null ) { double yy = value . doubleValue ( ) ; this . minY = minIgnoreNaN ( this . minY , yy ) ; this . maxY = maxIgnoreNaN ( this . maxY , yy ) ; } fireSeriesChanged ( ) ; } public org . jfree . data . time . TimeSeries addAndOrUpdate ( org . jfree . data . time . TimeSeries series ) { org . jfree . data . time . TimeSeries overwritten = new org . jfree . data . time . TimeSeries ( ( " Overwritten values from : " + ( getKey ( ) ) ) ) ; for ( int i = 0 ; i < ( series . getItemCount ( ) ) ; i + + ) { org . jfree . data . time . TimeSeriesDataItem item = series . getRawDataItem ( i ) ; org . jfree . data . time . TimeSeriesDataItem oldItem = addOrUpdate ( item . getPeriod ( ) , item . getValue ( ) ) ; if ( oldItem ! = null ) { overwritten . add ( oldItem ) ; } } return overwritten ; } public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . RegularTimePeriod period , double value ) { return addOrUpdate ( period , new java . lang . Double ( value ) ) ; } public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { return addOrUpdate ( new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ) ; } public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . TimeSeriesDataItem item ) { if ( item = = null ) { throw new java . lang . IllegalArgumentException ( " Null ' period ' argument . " ) ; } java . lang . Class periodClass = item . getPeriod ( ) . getClass ( ) ; if ( ( this . timePeriodClass ) = = null ) { this . timePeriodClass = periodClass ; } else if ( ! ( this . timePeriodClass . equals ( periodClass ) ) ) { java . lang . String msg = ( ( ( ( " You are trying to add data where the time " + " period class is " ) + ( periodClass . getName ( ) ) ) + " , but the TimeSeries is expecting an instance of " ) + ( this . timePeriodClass . getName ( ) ) ) + " . " ; throw new org . jfree . data . general . SeriesException ( msg ) ; } org . jfree . data . time . TimeSeriesDataItem overwritten = null ; int index = java . util . Collections . binarySearch ( this . data , item ) ; if ( index > = 0 ) { org . jfree . data . time . TimeSeriesDataItem existing = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . get ( index ) ) ) ; overwritten = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( existing . clone ( ) ) ) ; boolean iterate = false ; java . lang . Number oldYN = existing . getValue ( ) ; double oldY = ( oldYN ! = null ) ? oldYN . doubleValue ( ) : java . lang . Double . NaN ; if ( ! ( java . lang . Double . isNaN ( oldY ) ) ) { iterate = ( oldY < = ( this . minY ) ) | | ( oldY > = ( this . maxY ) ) ; } existing . setValue ( item . getValue ( ) ) ; if ( iterate ) { findBoundsByIteration ( ) ; } else if ( ( item . getValue ( ) ) ! = null ) { double yy = item . getValue ( ) . doubleValue ( ) ; this . minY = minIgnoreNaN ( this . minY , yy ) ; this . maxY = minIgnoreNaN ( this . maxY , yy ) ; } } else { item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( item . clone ( ) ) ) ; this . data . add ( ( ( - index ) - 1 ) , item ) ; updateBoundsForAddedItem ( item ) ; if ( ( getItemCount ( ) ) > ( this . maximumItemCount ) ) { org . jfree . data . time . TimeSeriesDataItem d = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( 0 ) ) ) ; updateBoundsForRemovedItem ( d ) ; } } removeAgedItems ( false ) ; fireSeriesChanged ( ) ; return overwritten ; } public void removeAgedItems ( boolean notify ) { if ( ( getItemCount ( ) ) > 1 ) { long latest = getTimePeriod ( ( ( getItemCount ( ) ) - 1 ) ) . getSerialIndex ( ) ; boolean removed = false ; while ( ( latest - ( getTimePeriod ( 0 ) . getSerialIndex ( ) ) ) > ( this . maximumItemAge ) ) { this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ; } } } } public void removeAgedItems ( long latest , boolean notify ) { if ( this . data . isEmpty ( ) ) { return ; } long index = java . lang . Long . MAX_VALUE ; try { java . lang . reflect . Method m = org . jfree . data . time . RegularTimePeriod . class . getDeclaredMethod ( " createInstance " , new java . lang . Class [ ] { java . lang . Class . class , java . util . Date . class , java . util . TimeZone . class } ) ; org . jfree . data . time . RegularTimePeriod newest = ( ( org . jfree . data . time . RegularTimePeriod ) ( m . invoke ( this . timePeriodClass , new java . lang . Object [ ] { this . timePeriodClass , new java . util . Date ( latest ) , java . util . TimeZone . getDefault ( ) } ) ) ) ; index = newest . getSerialIndex ( ) ; } catch ( java . lang . NoSuchMethodException e ) { e . printStackTrace ( ) ; } catch ( java . lang . IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { e . printStackTrace ( ) ; } boolean removed = false ; while ( ( ( getItemCount ( ) ) > 0 ) & & ( ( index - ( getTimePeriod ( 0 ) . getSerialIndex ( ) ) ) > ( this . maximumItemAge ) ) ) { this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ; } } } public void clear ( ) { if ( ( this . data . size ( ) ) > 0 ) { this . data . clear ( ) ; this . timePeriodClass = null ; this . minY = java . lang . Double . NaN ; this . maxY = java . lang . Double . NaN ; fireSeriesChanged ( ) ; } } public void delete ( org . jfree . data . time . RegularTimePeriod period ) { int index = getIndex ( period ) ; if ( index > = 0 ) { org . jfree . data . time . TimeSeriesDataItem item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( index ) ) ) ; updateBoundsForRemovedItem ( item ) ; if ( this . data . isEmpty ( ) ) { this . timePeriodClass = null ; } <ml> / tmp / jGenProg_Defects4J_Chart_3 / source / org / jfree / data / time / TimeSeriesjava public void add ( org . jfree . data . time . TimeSeriesDataItem item ) {                                                                                                                                                                                                                                                      updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; } public void add ( org . jfree . data . time . TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new java . lang . IllegalArgumentException ( " Null ' item ' argument . " ) ; } item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( item . clone ( ) ) ) ; java . lang . Class c = item . getPeriod ( ) . getClass ( ) ; if ( ( this . timePeriodClass ) = = null ) { this . timePeriodClass = c ; } else if ( ! ( this . timePeriodClass . equals ( c ) ) ) { java . lang . StringBuffer b = new java . lang . StringBuffer ( ) ; b . append ( " You are trying to add data where the time period class " ) ; b . append ( " is " ) ; b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; b . append ( " , but the TimeSeries is expecting an instance of " ) ; b . append ( this . timePeriodClass . getName ( ) ) ; b . append ( " . " ) ; throw new org . jfree . data . general . SeriesException ( b . toString ( ) ) ; } boolean added = false ; int count = getItemCount ( ) ; if ( count = = 0 ) { this . data . add ( item ) ; added = true ; } else { org . jfree . data . time . RegularTimePeriod last = getTimePeriod ( ( ( getItemCount ( ) ) - 1 ) ) ; if ( ( item . getPeriod ( ) . compareTo ( last ) ) > 0 ) { this . data . add ( item ) ; added = true ; } else { int index = java . util . Collections . binarySearch ( this . data , item ) ; if ( index < 0 ) { this . data . add ( ( ( - index ) - 1 ) , item ) ; added = true ; } else { java . lang . StringBuffer b = new java . lang . StringBuffer ( ) ; b . append ( " You are attempting to add an observation for " ) ; b . append ( " the time period " ) ; b . append ( item . getPeriod ( ) . toString ( ) ) ; b . append ( " but the series already contains an observation " ) ; b . append ( " for that time period . Duplicates are not " ) ; b . append ( " permitted . Try using the addOrUpdate ( ) method . " ) ; throw new org . jfree . data . general . SeriesException ( b . toString ( ) ) ; } } } if ( added ) { updateBoundsForAddedItem ( item ) ; if ( ( getItemCount ( ) ) > ( this . maximumItemCount ) ) { org . jfree . data . time . TimeSeriesDataItem d = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( 0 ) ) ) ; updateBoundsForRemovedItem ( d ) ; } removeAgedItems ( false ) ; if ( notify ) { fireSeriesChanged ( ) ; } } } public void add ( org . jfree . data . time . RegularTimePeriod period , double value ) { add ( period , value , true ) ; } public void add ( org . jfree . data . time . RegularTimePeriod period , double value , boolean notify ) { org . jfree . data . time . TimeSeriesDataItem item = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; add ( item , notify ) ; } public void add ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { add ( period , value , true ) ; } public void add ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value , boolean notify ) { org . jfree . data . time . TimeSeriesDataItem item = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; add ( item , notify ) ; } public void update ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { org . jfree . data . time . TimeSeriesDataItem temp = new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ; int index = java . util . Collections . binarySearch ( this . data , temp ) ; if ( index < 0 ) { throw new org . jfree . data . general . SeriesException ( ( " There is no existing value for the " + " specified ' period ' . " ) ) ; } update ( index , value ) ; } public void update ( int index , java . lang . Number value ) { org . jfree . data . time . TimeSeriesDataItem item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . get ( index ) ) ) ; boolean iterate = false ; java . lang . Number oldYN = item . getValue ( ) ; if ( oldYN ! = null ) { double oldY = oldYN . doubleValue ( ) ; if ( ! ( java . lang . Double . isNaN ( oldY ) ) ) { iterate = ( oldY < = ( this . minY ) ) | | ( oldY > = ( this . maxY ) ) ; } } item . setValue ( value ) ; if ( iterate ) { findBoundsByIteration ( ) ; } else if ( value ! = null ) { double yy = value . doubleValue ( ) ; this . minY = minIgnoreNaN ( this . minY , yy ) ; this . maxY = maxIgnoreNaN ( this . maxY , yy ) ; } fireSeriesChanged ( ) ; } public org . jfree . data . time . TimeSeries addAndOrUpdate ( org . jfree . data . time . TimeSeries series ) { org . jfree . data . time . TimeSeries overwritten = new org . jfree . data . time . TimeSeries ( ( " Overwritten values from : " + ( getKey ( ) ) ) ) ; for ( int i = 0 ; i < ( series . getItemCount ( ) ) ; i + + ) { org . jfree . data . time . TimeSeriesDataItem item = series . getRawDataItem ( i ) ; org . jfree . data . time . TimeSeriesDataItem oldItem = addOrUpdate ( item . getPeriod ( ) , item . getValue ( ) ) ; if ( oldItem ! = null ) { overwritten . add ( oldItem ) ; } } return overwritten ; } public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . RegularTimePeriod period , double value ) { return addOrUpdate ( period , new java . lang . Double ( value ) ) ; } public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . RegularTimePeriod period , java . lang . Number value ) { return addOrUpdate ( new org . jfree . data . time . TimeSeriesDataItem ( period , value ) ) ; } public org . jfree . data . time . TimeSeriesDataItem addOrUpdate ( org . jfree . data . time . TimeSeriesDataItem item ) { if ( item = = null ) { throw new java . lang . IllegalArgumentException ( " Null ' period ' argument . " ) ; } java . lang . Class periodClass = item . getPeriod ( ) . getClass ( ) ; if ( ( this . timePeriodClass ) = = null ) { this . timePeriodClass = periodClass ; } else if ( ! ( this . timePeriodClass . equals ( periodClass ) ) ) { java . lang . String msg = ( ( ( ( " You are trying to add data where the time " + " period class is " ) + ( periodClass . getName ( ) ) ) + " , but the TimeSeries is expecting an instance of " ) + ( this . timePeriodClass . getName ( ) ) ) + " . " ; throw new org . jfree . data . general . SeriesException ( msg ) ; } org . jfree . data . time . TimeSeriesDataItem overwritten = null ; int index = java . util . Collections . binarySearch ( this . data , item ) ; if ( index > = 0 ) { org . jfree . data . time . TimeSeriesDataItem existing = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . get ( index ) ) ) ; overwritten = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( existing . clone ( ) ) ) ; boolean iterate = false ; java . lang . Number oldYN = existing . getValue ( ) ; double oldY = ( oldYN ! = null ) ? oldYN . doubleValue ( ) : java . lang . Double . NaN ; if ( ! ( java . lang . Double . isNaN ( oldY ) ) ) { iterate = ( oldY < = ( this . minY ) ) | | ( oldY > = ( this . maxY ) ) ; } existing . setValue ( item . getValue ( ) ) ; if ( iterate ) { findBoundsByIteration ( ) ; } else if ( ( item . getValue ( ) ) ! = null ) { double yy = item . getValue ( ) . doubleValue ( ) ; this . minY = minIgnoreNaN ( this . minY , yy ) ; this . maxY = minIgnoreNaN ( this . maxY , yy ) ; } } else { item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( item . clone ( ) ) ) ; this . data . add ( ( ( - index ) - 1 ) , item ) ; updateBoundsForAddedItem ( item ) ; if ( ( getItemCount ( ) ) > ( this . maximumItemCount ) ) { org . jfree . data . time . TimeSeriesDataItem d = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( 0 ) ) ) ; updateBoundsForRemovedItem ( d ) ; } } removeAgedItems ( false ) ; fireSeriesChanged ( ) ; return overwritten ; } public void removeAgedItems ( boolean notify ) { if ( ( getItemCount ( ) ) > 1 ) { long latest = getTimePeriod ( ( ( getItemCount ( ) ) - 1 ) ) . getSerialIndex ( ) ; boolean removed = false ; while ( ( latest - ( getTimePeriod ( 0 ) . getSerialIndex ( ) ) ) > ( this . maximumItemAge ) ) { this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ; } } } } public void removeAgedItems ( long latest , boolean notify ) { if ( this . data . isEmpty ( ) ) { return ; } long index = java . lang . Long . MAX_VALUE ; try { java . lang . reflect . Method m = org . jfree . data . time . RegularTimePeriod . class . getDeclaredMethod ( " createInstance " , new java . lang . Class [ ] { java . lang . Class . class , java . util . Date . class , java . util . TimeZone . class } ) ; org . jfree . data . time . RegularTimePeriod newest = ( ( org . jfree . data . time . RegularTimePeriod ) ( m . invoke ( this . timePeriodClass , new java . lang . Object [ ] { this . timePeriodClass , new java . util . Date ( latest ) , java . util . TimeZone . getDefault ( ) } ) ) ) ; index = newest . getSerialIndex ( ) ; } catch ( java . lang . NoSuchMethodException e ) { e . printStackTrace ( ) ; } catch ( java . lang . IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { e . printStackTrace ( ) ; } boolean removed = false ; while ( ( ( getItemCount ( ) ) > 0 ) & & ( ( index - ( getTimePeriod ( 0 ) . getSerialIndex ( ) ) ) > ( this . maximumItemAge ) ) ) { this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ; } } } public void clear ( ) { if ( ( this . data . size ( ) ) > 0 ) { this . data . clear ( ) ; this . timePeriodClass = null ; this . minY = java . lang . Double . NaN ; this . maxY = java . lang . Double . NaN ; fireSeriesChanged ( ) ; } } public void delete ( org . jfree . data . time . RegularTimePeriod period ) { int index = getIndex ( period ) ; if ( index > = 0 ) { org . jfree . data . time . TimeSeriesDataItem item = ( ( org . jfree . data . time . TimeSeriesDataItem ) ( this . data . remove ( index ) ) ) ; updateBoundsForRemovedItem ( item ) ; if ( this . data . isEmpty ( ) ) { this . timePeriodClass = null ; } 
0<ml>Closure-21_P_Patch_7_6.txt<ml> / tmp / jGenProg_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava return ; } if ( n = = ( parent . getLastChild ( ) ) ) { for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) { continue ; } if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) { <ml> / tmp / jGenProg_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava return ; } if ( n = = ( parent . getLastChild ( ) ) ) {       } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) { 
0<ml>Chart-7_P_Patch_36_28.txt<ml> / tmp / jGenProg_Defects4J_Chart_7 / source / org / jfree / data / time / TimePeriodValuesjava public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } public int getMinEndIndex ( ) { return this . minEndIndex ; } public int getMaxEndIndex ( ) { return this . maxEndIndex ; } } \ No newline at end of file <ml> / tmp / jGenProg_Defects4J_Chart_7 / source / org / jfree / data / time / TimePeriodValuesjava public int getMaxMiddleIndex ( ) {       return this . maxEndIndex ; } public int getMinEndIndex ( ) { return this . minEndIndex ; } public int getMaxEndIndex ( ) { return this . maxEndIndex ; } } \ No newline at end of file 
0<ml>Math-82_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; <ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( false ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ; 
0<ml>Lang-63_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; <ml>a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int newdiff = startValue - endValue ; if ( false ) { end . add ( field , newdiff ) ; } return newdiff ; 
0<ml>Math-71_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / ode / nonstiff / AdaptiveStepsizeIntegrator . java public void setInitialStepSize ( final double initialStepSize ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; } <ml>a / src / main / java / org / apache / commons / math / ode / nonstiff / AdaptiveStepsizeIntegrator . java b / src / main / java / org / apache / commons / math / ode / nonstiff / AdaptiveStepsizeIntegrator . java public void setInitialStepSize ( final double initialStepSize ) { if ( false ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; } } 
0<ml>Chart-13_P_Patch_1_1.txt<ml>a / source / org / jfree / chart / block / BorderArrangement . java h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } <ml>b / source / org / jfree / chart / block / BorderArrangement . java h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } 
0<ml>Chart-25_P_Patch_1_1.txt<ml>a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } <ml>a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java PlotOrientation orientation = plot . getOrientation ( ) ; if ( false ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } 
0<ml>Math-81_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; <ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java final double gam = dN2 ; if ( true ) { return ; 
0<ml>Math-49_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } <ml>a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java b / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java entries . put ( index , value ) ; } else { if ( this . DEFAULT_ZERO_TOLERANCE = = this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } 
0<ml>Time-11_P_Patch_15_15.txt<ml>a / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } <ml>a / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java b / src / main / java / org / joda / time / tz / DateTimeZoneBuilder . java { if ( nameKey . length ( ) ! = 0 ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } } 
0<ml>Math-85_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( " number of iterations = { 0 } , maximum iterations = { 1 } , " + " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } <ml>a / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java if ( fa * fb > = 0 . 0 ) { if ( false ) { throw new ConvergenceException ( " number of iterations = { 0 } , maximum iterations = { 1 } , " + " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } } 
0<ml>Chart-1_P_Patch_1_1.txt<ml>a / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } <ml>a / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java b / source / org / jfree / chart / renderer / category / AbstractCategoryItemRenderer . java CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { if ( dataset ! = null ) { return result ; } } 
0<ml>Lang-51_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / BooleanUtils . java char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } <ml>b / src / java / org / apache / commons / lang / BooleanUtils . java char ch = str . charAt ( 0 ) ; if ( true ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } 
0<ml>Chart-5_P_Patch_1_1.txt<ml>a / source / org / jfree / data / xy / XYSeries . java / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; <ml>b / source / org / jfree / data / xy / XYSeries . java / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; 
0<ml>Math-32_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { <ml>a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { 
0<ml>Math-80_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } <ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java int j = 4 * n - 1 ; if ( false ) { for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } } 
0<ml>Math-105_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java if ( n = = 0 ) { xbar = x ; ybar = y ; <ml>a / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java b / src / java / org / apache / commons / math / stat / regression / SimpleRegression . java if ( n = = 0 ) { if ( ( x < = 1 ) | | ( y < = x ) ) { xbar = x ; } ybar = y ; 
0<ml>Chart-15_P_Patch_1_1.txt<ml>a / source / org / jfree / chart / JFreeChart . java } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; <ml>b / source / org / jfree / chart / JFreeChart . java } if ( false ) { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; } 
0<ml>Math-58_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java } sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { <ml>a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java b / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java } if ( this . costRelativeTolerance ! = this . orthoTolerance ) { sum2 = 0 ; } for ( int j = 0 ; j < solvedCols ; + + j ) { 
0<ml>Math-20_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java } if ( max ( diagD ) > 1e14 * min ( diagD ) ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ; <ml>a / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java b / src / main / java / org / apache / commons / math3 / optimization / direct / CMAESOptimizer . java } if ( this . dimension = = 1 ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ; 
0<ml>Math-41_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / stat / descriptive / moment / Variance . java if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; } <ml>a / src / main / java / org / apache / commons / math / stat / descriptive / moment / Variance . java b / src / main / java / org / apache / commons / math / stat / descriptive / moment / Variance . java if ( values [ 0 ] < = length ) { if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; } } 
0<ml>Math-8_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } <ml>a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java if ( false ) { for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } } 
0<ml>Chart-18_P_Patch_1_1.txt<ml>a / source / org / jfree / data / category / DefaultCategoryDataset . java public void removeColumn ( Comparable columnKey ) { this . data . removeColumn ( columnKey ) ; fireDatasetChanged ( ) ; <ml>a / source / org / jfree / data / category / DefaultCategoryDataset . java b / source / org / jfree / data / category / DefaultCategoryDataset . java public void removeColumn ( Comparable columnKey ) { if ( false ) { this . data . removeColumn ( columnKey ) ; } fireDatasetChanged ( ) ; 
0<ml>Math-82_P_Patch_1326_709.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } <ml>b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) | | ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } 
0<ml>Chart-26_P_Patch_5751_2399.txt<ml>a / source / org / jfree / chart / plot / CategoryPlot . java PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; <ml>b / source / org / jfree / chart / plot / CategoryPlot . java PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; 
0<ml>Math-88_P_Patch_593_301.txt<ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } <ml>b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( j = = i & & ( tableau . getEntry ( basicRow , j ) = = 1 ) ) { coefficients [ i ] = 0 ; } } 
0<ml>Lang-27_P_Patch_1259_919.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; 
0<ml>Lang-63_P_Patch_28_21.txt<ml>a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { <ml>b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = difference - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { 
0<ml>Math-96_P_Patch_439_157.txt<ml>a / src / java / org / apache / commons / math / complex / Complex . java if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception <ml>b / src / java / org / apache / commons / math / complex / Complex . java if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) > = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception 
0<ml>Chart-3_P _Patch_440_242.txt<ml>a / source / org / jfree / data / time / TimeSeries . java * permitted ) . public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; } <ml>b / source / org / jfree / data / time / TimeSeries . java * permitted ) . public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; } 
0<ml>Closure-109_P_Patch_270_73.txt<ml>a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java * For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } <ml>b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java * For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; } 
0<ml>Closure-126_P_Patch_6_3.txt<ml>a / src / com / google / javascript / jscomp / MinimizeExitPoints . java if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } <ml>b / src / com / google / javascript / jscomp / MinimizeExitPoints . java if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; matchingExitNode ( finallyBlock , exitType , labelName ) ; } } 
0<ml>Lang-18_P_Patch_5849_3524.txt<ml>a / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; <ml>b / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; 
0<ml>Math-50_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 + = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; 
0<ml>Chart-13_P_Patch_29_18.txt<ml>a / source / org / jfree / data / Range . java if ( lower > upper ) { String msg = " Range ( double , double ) : require lower ( " + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ; <ml>b / source / org / jfree / data / Range . java if ( lower > upper ) { String msg = " Range ( double , double ) : require lower ( " + lower " ) < = upper ( " + upper + " ) . " ;  } this . lower = lower ; this . upper = upper ; 
0<ml>Lang-39_P_Patch_1350_1039.txt<ml>a / src / java / org / apache / commons / lang3 / StringUtils . java int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches <ml>b / src / java / org / apache / commons / lang3 / StringUtils . java int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i = = searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches 
0<ml>Lang-58_P_Patch_1789_1078.txt<ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { <ml>b / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { 
0<ml>Closure-107_P_Patch_356_164.txt<ml>a / src / com / google / javascript / jscomp / CommandLineRunner . java / / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ; <ml>b / src / com / google / javascript / jscomp / CommandLineRunner . java / / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n .  } return options ; 
0<ml>Chart-25_P_Patch_12_9.txt<ml>a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java notifyListeners ( new RendererChangeEvent ( this ) ) ; } public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) {  if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( " Requires StatisticalCategoryDataset . " ) ; } StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;  PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } <ml>b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java notifyListeners ( new RendererChangeEvent ( this ) ) ; }  
0<ml>Lang-41_P_Patch_2958_1870.txt<ml>a / src / java / org / apache / commons / lang / ClassUtils . java if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } a / src / java / org / apache / commons / lang / ClassUtils . java if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } <ml>b / src / java / org / apache / commons / lang / ClassUtils . java if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } b / src / java / org / apache / commons / lang / ClassUtils . java if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } 
0<ml>Math-81_P_Patch_75_45.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * this . tType ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; 
0<ml>Lang-20_P_Patch_1220_617.txt<ml>a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { <ml>b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { 
0<ml>Lang-60_P_Patch_3262_1865.txt<ml>a / src / java / org / apache / commons / lang / text / StrBuilder . java * @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; } <ml>b / src / java / org / apache / commons / lang / text / StrBuilder . java * @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , capacity ( ) - endIndex ) ; size - = len ; } 
0<ml>Lang-24_P_Patch_2414_1931.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java / / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ; <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java / / can ' t have an E at the last byte return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ; 
0<ml>Closure-12_P_Patch_160_37.txt<ml>a / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { return true ; } } <ml>b / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( apply ( c ) ) { return true ; } } 
0<ml>Lang-45_P_Patch_310_221.txt<ml>a / src / java / org / apache / commons / lang / WordUtils . java upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; } <ml>b / src / java / org / apache / commons / lang / WordUtils . java upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; } 
0<ml>Math-85_P_Patch_3_1.txt<ml>a / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( " number of iterations = { 0 } , maximum iterations = { 1 } , " + " initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , " + " final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } " , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; <ml>b / src / java / org / apache / commons / math / analysis / solvers / UnivariateRealSolverUtils . java ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {  } return new double [ ] { a , b } ; 
0<ml>Math-62_P_Patch_261_142.txt<ml>a / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { <ml>b / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { 
0<ml>Chart-14_P_Patch_2631_615.txt<ml>a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { <ml>b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else { 
0<ml>Math-95_P_Patch_56_20.txt<ml>a / src / java / org / apache / commons / math / distribution / FDistributionImpl . java double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } <ml>b / src / java / org / apache / commons / math / distribution / FDistributionImpl . java double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d + 2 . 0 ) ; return ret ; } 
0<ml>Lang-51_P_Patch_180_129.txt<ml>a / src / java / org / apache / commons / lang / BooleanUtils . java } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <ml>b / src / java / org / apache / commons / lang / BooleanUtils . java } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch < = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; 
0<ml>Chart-5_P_Patch_52_1.txt<ml>a / source / org / jfree / data / xy / XYSeries . java * @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } <ml>b / source / org / jfree / data / xy / XYSeries . java * @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; } 
0<ml>Closure-115_P_Patch_704_253.txt<ml>a / src / com / google / javascript / jscomp / FunctionInjector . java / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . <ml>b / src / com / google / javascript / jscomp / FunctionInjector . java / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . 
0<ml>Math-80_P_Patch_931_596.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; 
0<ml>Lang-7_P_Patch_1504_1083.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( " A blank string is not a valid number " ) ; } if ( str . startsWith ( " - - " ) ) { <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java if ( str = = null ) { return null ; } if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( " - - " ) ) ) { throw new NumberFormatException ( " A blank string is not a valid number " ) ; } if ( str . startsWith ( " - - " ) ) { 
0<ml>Math-63_P_Patch_611_159.txt<ml>a / src / main / java / org / apache / commons / math / util / MathUtils . java return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } } <ml>b / src / main / java / org / apache / commons / math / util / MathUtils . java return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] , i ) ) { return false ; } } 
0<ml>Lang-44_P_Patch_4046_2567.txt<ml>a / src / java / org / apache / commons / lang / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { <ml>b / src / java / org / apache / commons / lang / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { 
0<ml>Math-84_P_Patch_114_72.txt<ml>a / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence <ml>b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { / / accept the contracted simplex / / check convergence 
0<ml>Chart-15_P_Patch_220_119.txt<ml>a / source / org / jfree / chart / plot / PiePlot3D . java notifyListeners ( new PlotChangeEvent ( this ) ) ; } public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) {  RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;  Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ; if ( info ! = null ) { info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; }  drawBackground ( g2 , plotArea ) ;  Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ;  double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ;  if ( DEBUG_DRAW_INTERIOR ) { double hGap = plotArea . getWidth ( ) * getInteriorGap ( ) ; double vGap = plotArea . getHeight ( ) * getInteriorGap ( ) ; double igx1 = plotArea . getX ( ) + hGap ; double igx2 = plotArea . getMaxX ( ) - hGap ; double igy1 = plotArea . getY ( ) + vGap ; double igy2 = plotArea . getMaxY ( ) - vGap ; g2 . setPaint ( Color . lightGray ) ; g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; }  double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;  if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ;  Rectangle2D linkAreaXX = new Rectangle2D . Double ( linkX , linkY , linkW , linkH * ( 1 - this . depthFactor ) ) ; state . setLinkArea ( linkAreaXX ) ;  if ( DEBUG_DRAW_LINK_AREA ) { g2 . setPaint ( Color . blue ) ; g2 . draw ( linkAreaXX ) ; g2 . setPaint ( Color . yellow ) ; g2 . draw ( new Ellipse2D . Double ( linkAreaXX . getX ( ) , linkAreaXX . getY ( ) , linkAreaXX . getWidth ( ) , linkAreaXX . getHeight ( ) ) ) ; }  double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + hh / 2 . 0 , linkY + vv / 2 . 0 , linkW - hh , linkH - vv ) ;  state . setExplodedPieArea ( explodeArea ) ;  double maximumExplodePercent = getMaximumExplodePercent ( ) ; double percent = maximumExplodePercent / ( 1 . 0 + maximumExplodePercent ) ;  double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + h1 / 2 . 0 , explodeArea . getY ( ) + v1 / 2 . 0 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ;  int depth = ( int ) ( pieArea . getHeight ( ) * this . depthFactor ) ; Rectangle2D linkArea = new Rectangle2D . Double ( linkX , linkY , linkW , linkH - depth ) ; state . setLinkArea ( linkArea ) ;  state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; state . setPieCenterY ( pieArea . getCenterY ( ) - depth / 2 . 0 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ;  PieDataset dataset = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  if ( dataset . getKeys ( ) . size ( ) > plotArea . getWidth ( ) ) { String text = " Too many elements " ; Font sfont = new Font ( " dialog " , Font . BOLD , 10 ) ; g2 . setFont ( sfont ) ; FontMetrics fm = g2 . getFontMetrics ( sfont ) ; int stringWidth = fm . stringWidth ( text ) ;  g2 . drawString ( text , ( int ) ( plotArea . getX ( ) + ( plotArea . getWidth ( ) - stringWidth ) / 2 ) , ( int ) ( plotArea . getY ( ) + ( plotArea . getHeight ( ) / 2 ) ) ) ; return ; } if ( isCircular ( ) ) { double min = Math . min ( plotArea . getWidth ( ) , plotArea . getHeight ( ) ) / 2 ; plotArea = new Rectangle2D . Double ( plotArea . getCenterX ( ) - min , plotArea . getCenterY ( ) - min , 2 * min , 2 * min ) ; } List sectionKeys = dataset . getKeys ( ) ;  if ( sectionKeys . size ( ) = = 0 ) { return ; }  double arcX = pieArea . getX ( ) ; double arcY = pieArea . getY ( ) ;  Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  double totalValue = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; double runningTotal = 0 ; if ( depth < 0 ) { return ; / / if depth is negative don ' t draw anything }  ArrayList arcList = new ArrayList ( ) ; Arc2D . Double arc ; Paint paint ; Paint outlinePaint ; Stroke outlineStroke ;  Iterator iterator = sectionKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) {  Comparable currentKey = ( Comparable ) iterator . next ( ) ; Number dataValue = dataset . getValue ( currentKey ) ; if ( dataValue = = null ) { arcList . add ( null ) ; continue ; } double value = dataValue . doubleValue ( ) ; if ( value < = 0 ) { arcList . add ( null ) ; continue ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double angle1 = startAngle + ( direction * ( runningTotal * 360 ) ) / totalValue ; double angle2 = startAngle + ( direction * ( runningTotal + value ) * 360 ) / totalValue ; if ( Math . abs ( angle2 - angle1 ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else { arcList . add ( null ) ; } runningTotal + = value ; }  Shape oldClip = g2 . getClip ( ) ;  Ellipse2D top = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Ellipse2D bottom = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Rectangle2D lower = new Rectangle2D . Double ( top . getX ( ) , top . getCenterY ( ) , pieArea . getWidth ( ) , bottom . getMaxY ( ) - top . getCenterY ( ) ) ;  Rectangle2D upper = new Rectangle2D . Double ( pieArea . getX ( ) , top . getY ( ) , pieArea . getWidth ( ) , bottom . getCenterY ( ) - top . getY ( ) ) ;  Area a = new Area ( top ) ; a . add ( new Area ( lower ) ) ; Area b = new Area ( bottom ) ; b . add ( new Area ( upper ) ) ; Area pie = new Area ( a ) ; pie . intersect ( b ) ;  Area front = new Area ( pie ) ; front . subtract ( new Area ( top ) ) ;  Area back = new Area ( pie ) ; back . subtract ( new Area ( bottom ) ) ;  int [ ] xs ; int [ ] ys ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ;  int categoryCount = arcList . size ( ) ; for ( int categoryIndex = 0 ; categoryIndex < categoryCount ; categoryIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( categoryIndex ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( categoryIndex ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setPaint ( paint ) ; g2 . fill ( arc ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( arc ) ; g2 . setPaint ( paint ) ;  Point2D p1 = arc . getStartPoint ( ) ;  xs = new int [ ] { ( int ) arc . getCenterX ( ) , ( int ) arc . getCenterX ( ) , ( int ) p1 . getX ( ) , ( int ) p1 . getX ( ) } ; ys = new int [ ] { ( int ) arc . getCenterY ( ) , ( int ) arc . getCenterY ( ) - depth , ( int ) p1 . getY ( ) - depth , ( int ) p1 . getY ( ) } ; Polygon polygon = new Polygon ( xs , ys , 4 ) ; g2 . setPaint ( java . awt . Color . lightGray ) ; g2 . fill ( polygon ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ;  }  g2 . setPaint ( Color . gray ) ; g2 . fill ( back ) ; g2 . fill ( front ) ;  int cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , false , true ) ; } cat + + ; }  cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , true , false ) ; } cat + + ; }  g2 . setClip ( oldClip ) ;  Arc2D upperArc ; for ( int sectionIndex = 0 ; sectionIndex < categoryCount ; sectionIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( sectionIndex ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ;  Comparable currentKey = ( Comparable ) sectionKeys . get ( sectionIndex ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; g2 . setPaint ( paint ) ; g2 . fill ( upperArc ) ; g2 . setStroke ( outlineStroke ) ; g2 . setPaint ( outlinePaint ) ; g2 . draw ( upperArc ) ;  if ( info ! = null ) { EntityCollection entities = info . getOwner ( ) . getEntityCollection ( ) ; if ( entities ! = null ) { String tip = null ; PieToolTipGenerator tipster = getToolTipGenerator ( ) ; if ( tipster ! = null ) { tip = tipster . generateToolTip ( dataset , currentKey ) ; } String url = null ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , sectionIndex , currentKey , tip , url ) ; entities . add ( entity ) ; } } List keys = dataset . getKeys ( ) ; Rectangle2D adjustedPlotArea = new Rectangle2D . Double ( originalPlotArea . getX ( ) , originalPlotArea . getY ( ) , originalPlotArea . getWidth ( ) , originalPlotArea . getHeight ( ) - depth ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } }  g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ; drawOutline ( g2 , originalPlotArea ) ;  } <ml>b / source / org / jfree / chart / plot / PiePlot3D . java notifyListeners ( new PlotChangeEvent ( this ) ) ; }  
0<ml>Closure-66_P_Patch_9_6.txt<ml>a / src / com / google / javascript / jscomp / TypeCheck . java * @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = nullCount + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else { <ml>b / src / com / google / javascript / jscomp / TypeCheck . java * @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = this . noTypeCheckSection + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else { 
0<ml>Closure-22_P_Patch_5_5.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; 
0<ml>Math-6_P_Patch_5_2.txt<ml>a / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java * @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; } <ml>b / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java * @ return the number of evaluations of the objective function . public int getIterations ( ) { return this . evaluations . getCount ( ) ; } 
0<ml>Closure-133_P_Patch_433_171.txt<ml>a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java / / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( token ) ; String returnDescription = returnDescriptionInfo . string ; <ml>b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java / / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( current ( ) ) ; String returnDescription = returnDescriptionInfo . string ; 
0<ml>Lang-43_P_Patch_368_183.txt<ml>a / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ; <ml>b / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ; 
0<ml>Math-8_P_Patch_47_16.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } <ml>b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i = = sampleSize ; i + + ) { out [ i ] = sample ( ) ; } 
0<ml>Math-2_P_Patch_468_285.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / HypergeometricDistribution . java protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final double m = getNumberOfSuccesses ( ) ; final double n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; } <ml>b / src / main / java / org / apache / commons / math3 / distribution / HypergeometricDistribution . java protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final int m = getNumberOfSuccesses ( ) ; final int n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; } 
0<ml>Lang-13_P_Patch_18_6.txt<ml>a / src / main / java / org / apache / commons / lang3 / SerializationUtils . java } @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } } <ml>b / src / main / java / org / apache / commons / lang3 / SerializationUtils . java }  } 
0<ml>Closure-21_P_Patch_260_40.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ( ancestorType = = Token . COMMA ) | | ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } 
0<ml>Chart-12_P_Patch_39_22.txt<ml>a / source / org / jfree / data / general / AbstractDataset . java public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } <ml>b / source / org / jfree / data / general / AbstractDataset . java public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list ! = null | | list . contains ( listener ) ; } 
0<ml>Math-15_P_Patch_1163_932.txt<ml>a / src / main / java / org / apache / commons / math3 / util / FastMath . java if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; } <ml>b / src / main / java / org / apache / commons / math3 / util / FastMath . java if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y = = ( long ) y ) ) { return pow ( - x , y ) ; } 
0<ml>Chart-7_P_Patch_2_2.txt<ml>a / source / org / jfree / data / time / TimePeriodValues . java * @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } <ml>b / source / org / jfree / data / time / TimePeriodValues . java * @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ;  } 
0<ml>Math-88_P_Patch_9909_5900.txt<ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } <ml>b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } } 
0<ml>Lang-63_P_Patch_302_174.txt<ml>a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int hours = end . get ( Calendar . HOUR_OF_DAY ) - start . get ( Calendar . HOUR_OF_DAY ) ; int days = end . get ( Calendar . DAY_OF_MONTH ) - start . get ( Calendar . DAY_OF_MONTH ) ; int months = end . get ( Calendar . MONTH ) - start . get ( Calendar . MONTH ) ; int years = end . get ( Calendar . YEAR ) - start . get ( Calendar . YEAR ) ; / / each initial estimate is adjusted in case it is under 0 while ( milliseconds < 0 ) { minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; / / This next block of code adds in values that <ml>b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int hours = end . get ( Calendar . HOUR_OF_DAY ) - start . get ( Calendar . HOUR_OF_DAY ) ; int days = end . get ( Calendar . DAY_OF_MONTH ) - start . get ( Calendar . DAY_OF_MONTH ) ; int months = end . get ( Calendar . MONTH ) - start . get ( Calendar . MONTH ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; int years = end . get ( Calendar . YEAR ) - start . get ( Calendar . YEAR ) ; / / each initial estimate is adjusted in case it is under 0 while ( milliseconds < 0 ) { minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ;  years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; / / This next block of code adds in values that 
0<ml>Closure-109_P_Patch_50_3.txt<ml>a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java * For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } <ml>b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java * For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; } 
0<ml>Closure-126_P_Patch_1_1.txt<ml>a / src / com / google / javascript / jscomp / MinimizeExitPoints . java * can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } <ml>b / src / com / google / javascript / jscomp / MinimizeExitPoints . java * can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . isImmutableValue ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } 
0<ml>Math-50_P_Patch_2_2.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java break ; case REGULA_FALSI : / / Nothing . if ( fx = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } 
0<ml>Lang-58_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { <ml>b / src / java / org / apache / commons / lang / math / NumberUtils . java case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) | | ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { 
0<ml>Math-98_P_Patch_34_1.txt<ml>a / src / java / org / apache / commons / math / linear / BigMatrixImpl . java } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { <ml>b / src / java / org / apache / commons / math / linear / BigMatrixImpl . java } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ copyOut ( ) . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { 
0<ml>Closure-107_P_Patch_1_1.txt<ml>a / src / com / google / javascript / jscomp / CommandLineRunner . java / / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ; <ml>b / src / com / google / javascript / jscomp / CommandLineRunner . java / / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n .  } return options ; 
0<ml>Math-81_P_Patch_291_217.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start < = 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { 
0<ml>Math-28_P_Patch_8_6.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index <ml>b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis  / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index 
0<ml>Math-68_P_Patch_208_131.txt<ml>a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java } / / test for successful iteration . if ( ratio > = 1 . 0e - 4 ) { / / successful iteration , update the norm firstIteration = false ; xNorm = 0 ; / / tests for convergence . / / we use the vectorial convergence checker / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 ) <ml>b / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java } / / test for successful iteration . if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } if ( ratio > = 1 . 0e - 4 ) { / / successful iteration , update the norm firstIteration = false ; xNorm = 0 ; / / tests for convergence . / / we use the vectorial convergence checker / / we use the Levenberg - Marquardt specific convergence parameters  / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 ) 
0<ml>Closure-18_P_Patch_1_1.txt<ml>a / src / com / google / javascript / jscomp / Compiler . java / / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process . <ml>b / src / com / google / javascript / jscomp / Compiler . java / / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) | | options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process . 
0<ml>Chart-14_P_Patch_194_47.txt<ml>a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } <ml>b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } 
0<ml>Math-95_P_Patch_59_19.txt<ml>a / src / java / org / apache / commons / math / distribution / FDistributionImpl . java double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } <ml>b / src / java / org / apache / commons / math / distribution / FDistributionImpl . java double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( Double . MAX_VALUE - 2 . 0 ) ; return ret ; } 
0<ml>Closure-63_P_Patch_1_1.txt<ml>a / src / com / google / javascript / jscomp / LightweightMessageFormatter . java / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { <ml>b / src / com / google / javascript / jscomp / LightweightMessageFormatter . java / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno | | charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { 
0<ml>Closure-115_P_Patch_40_14.txt<ml>a / src / com / google / javascript / jscomp / FunctionInjector . java Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { <ml>b / src / com / google / javascript / jscomp / FunctionInjector . java Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; if ( block . isFromExterns ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { 
0<ml>Math-80_P_Patch_51_24.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 0 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; 
0<ml>Closure-59_P_Patch_53_8.txt<ml>a / src / com / google / javascript / jscomp / Compiler . java CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ; } if ( options . getLanguageIn ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) { options . setWarningLevel ( guards . add ( options . getWarningsGuard ( ) ) ; ComposeWarningsGuard composedGuards = new ComposeWarningsGuard ( guards ) ; / / All passes must run the variable check . This synthesizes / / variables later so that the compiler doesn ' t crash . It also <ml>b / src / com / google / javascript / jscomp / Compiler . java CheckLevel . OFF ) ; }  if ( options . getLanguageIn ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) { options . setWarningLevel ( guards . add ( options . getWarningsGuard ( ) ) ; ComposeWarningsGuard composedGuards = new ComposeWarningsGuard ( guards ) ; if ( options . checkGlobalThisLevel . isOn ( ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ; }  / / All passes must run the variable check . This synthesizes / / variables later so that the compiler doesn ' t crash . It also 
0<ml>Lang-7_P_Patch_23_2.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( " A blank string is not a valid number " ) ; } if ( str . startsWith ( " - - " ) ) { return null ; } if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) | | str . startsWith ( " 0X " ) | | str . startsWith ( " - 0X " ) ) { <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( " A blank string is not a valid number " ) ; } if ( str . startsWith ( " - - " , INTEGER_ONE ) ) { return null ; } if ( str . startsWith ( " 0x " ) | | str . startsWith ( " - 0x " ) | | str . startsWith ( " 0X " ) | | str . startsWith ( " - 0X " ) ) { 
0<ml>Math-84_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence <ml>b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence 
0<ml>Chart-13_P _Patch_1364_1268.txt<ml>a / source / org / jfree / chart / block / BorderArrangement . java h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; <ml>b / source / org / jfree / chart / block / BorderArrangement . java h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 1 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; 
0<ml>Closure-62_P_Patch_1_1.txt<ml>a / src / com / google / javascript / jscomp / LightweightMessageFormatter . java / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { <ml>b / src / com / google / javascript / jscomp / LightweightMessageFormatter . java / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno | | charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { 
0<ml>Math-77_P_Patch_11_5.txt<ml>a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; } a / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; } <ml>b / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java return max ; }  b / src / main / java / org / apache / commons / math / linear / OpenMapRealVector . java return max ; }  
0<ml>Closure-31_P_Patch_1_1.txt<ml>a / src / com / google / javascript / jscomp / Compiler . java boolean staleInputs = false ; / / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they <ml>b / src / com / google / javascript / jscomp / Compiler . java boolean staleInputs = false ; / / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) | | ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they 
0<ml>Lang-22_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / Fraction . java private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to <ml>b / src / main / java / org / apache / commons / lang3 / math / Fraction . java private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 & & Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to 
0<ml>Math-64_P_Patch_599_199.txt<ml>a / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; residuals = oldRes ; oldRes = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & <ml>b / src / main / java / org / apache / commons / math / optimization / general / LevenbergMarquardtOptimizer . java / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ;  / / compute the scaled actual reduction double actRed = - 1 . 0 ; residuals = oldRes ; oldRes = tmpVec ; } current = new VectorialPointValuePair ( point , objective ) ;  if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & 
0<ml>Math-97_P_Patch_72_40.txt<ml>a / src / java / org / apache / commons / math / analysis / BrentSolver . java / / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException <ml>b / src / java / org / apache / commons / math / analysis / BrentSolver . java / / Verify bracketing double sign = yMin * yMax ; if ( sign > = 1E - 6 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException 
0<ml>Lang-19_P_Patch_758_78.txt<ml>a / src / main / java / org / apache / commons / lang3 / text / translate / NumericEntityUnescaper . java public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 1 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; <ml>b / src / main / java / org / apache / commons / lang3 / text / translate / NumericEntityUnescaper . java public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 4 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; 
0<ml>Math-81_P_Patch_11_1.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { 
0<ml>Math-28_P_Patch_2_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { <ml>b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { 
0<ml>Math-73_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java } return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java } if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } 
0<ml>Math-97_P_Patch_13_13.txt<ml>a / src / java / org / apache / commons / math / analysis / BrentSolver . java / / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( " Function values at endpoints do not have different signs . " + <ml>b / src / java / org / apache / commons / math / analysis / BrentSolver . java / / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 413505 ) ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( " Function values at endpoints do not have different signs . " + 
0<ml>Math-93_P_Patch_5_5.txt<ml>a / src / java / org / apache / commons / math / util / MathUtils . java * @ version $ Revision $ $ Date $ public final class MathUtils { public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( " must have n > = 0 for n ! " ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } <ml>b / src / java / org / apache / commons / math / util / MathUtils . java * @ version $ Revision $ $ Date $ public final class MathUtils { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; } public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( " must have n > = 0 for n ! " ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } 
0<ml>Math-40_P_Patch_452_264.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java / / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else { <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BracketingNthOrderBrentSolver . java / / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( signChangeIndex - start > = end - signChangeIndex ) | | ( y [ 0 ] * y [ 1 ] < 0 ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else { 
0<ml>Math-7_P_Patch_405_243.txt<ml>a / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; } <ml>b / src / main / java / org / apache / commons / math3 / ode / AbstractIntegrator . java final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; } 
0<ml>Math-82_P_Patch_646_317.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } <ml>b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , DEFAULT_EPSILON , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } 
0<ml>Chart-26_P_Patch_2377_1050.txt<ml>a / source / org / jfree / chart / plot / CategoryPlot . java / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; } <ml>b / source / org / jfree / chart / plot / CategoryPlot . java / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; } 
0<ml>Math-88_P_Patch_269_135.txt<ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } <ml>b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } } 
0<ml>Lang-27_P_Patch_621_407.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , INTEGER_ZERO ) ; } else { mant = str ; } 
0<ml>Lang-63_P_Patch_1_1.txt<ml>a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ; <ml>b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ; 
0<ml>Closure-109_P_Patch_172_38.txt<ml>a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java * For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } <ml>b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java * For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; } 
0<ml>Closure-126_P_Patch_25_3.txt<ml>a / src / com / google / javascript / jscomp / MinimizeExitPoints . java * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } <ml>b / src / com / google / javascript / jscomp / MinimizeExitPoints . java * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } 
0<ml>Lang-18_P_Patch_2058_1100.txt<ml>a / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; <ml>b / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; 
0<ml>Chart-17_P_Patch_47_25.txt<ml>a / source / org / jfree / data / time / TimeSeries . java if ( start < 0 ) { throw new IllegalArgumentException ( " Requires start > = 0 . " ) ; } if ( end < start ) { throw new IllegalArgumentException ( " Requires start < = end . " ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; <ml>b / source / org / jfree / data / time / TimeSeries . java if ( start < 0 ) { throw new IllegalArgumentException ( " Requires start > = 0 . " ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( " Requires start < = end . " ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; 
0<ml>Math-50_P_Patch_26_20.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , fx ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; 
0<ml>Chart-13_P_Patch_1091_503.txt<ml>a / source / org / jfree / chart / block / BorderArrangement . java h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , <ml>b / source / org / jfree / chart / block / BorderArrangement . java h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , 
0<ml>Lang-16_P_Patch_3010_1624.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java } dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java } dec = null ; } if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { 
0<ml>Lang-58_P_Patch_1889_735.txt<ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { <ml>b / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null | | exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { 
0<ml>Chart-25_P_Patch_76_13.txt<ml>a / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } <ml>b / source / org / jfree / data / statistics / DefaultStatisticalCategoryDataset . java public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } 
0<ml>Lang-41_P_Patch_223_61.txt<ml>a / src / java / org / apache / commons / lang / ClassUtils . java if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } a / src / java / org / apache / commons / lang / ClassUtils . java if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } <ml>b / src / java / org / apache / commons / lang / ClassUtils . java if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } b / src / java / org / apache / commons / lang / ClassUtils . java if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } 
0<ml>Math-81_P_Patch_19_8.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; 
0<ml>Lang-20_P_Patch_282_124.txt<ml>a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { <ml>b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { 
0<ml>Math-43_P_Patch_115_106.txt<ml>a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ; a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { a / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { <ml>b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ( ! ( geoMeanImpl instanceof GeometricMean ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { geoMeanImpl . increment ( value ) ; } n + + ; b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ( ! ( varianceImpl instanceof Variance ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { b / src / main / java / org / apache / commons / math / stat / descriptive / SummaryStatistics . java secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { 
0<ml>Math-49_P_Patch_2_1.txt<ml>a / src / main / java / org / apache / commons / math / MathRuntimeException . java private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; } <ml>b / src / main / java / org / apache / commons / math / MathRuntimeException . java private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; } 
0<ml>Math-104_P_Patch_485_406.txt<ml>a / src / java / org / apache / commons / math / special / Gamma . java ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ; <ml>b / src / java / org / apache / commons / math / special / Gamma . java ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ; 
0<ml>Lang-24_P_Patch_6785_5804.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java / / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ; <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java / / can ' t have an E at the last byte return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ; 
0<ml>Lang-45_P_Patch_342_158.txt<ml>a / src / java / org / apache / commons / lang / WordUtils . java upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; } <ml>b / src / java / org / apache / commons / lang / WordUtils . java upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; } 
0<ml>Math-62_P_Patch_118_71.txt<ml>a / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { <ml>b / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { 
0<ml>Closure-46_P_Patch_223_30.txt<ml>old mode 100755 new mode 100644 a / src / com / google / javascript / rhino / jstype / RecordType . java @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; <ml>old mode 100755 new mode 100644 b / src / com / google / javascript / rhino / jstype / RecordType . java @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isNumberObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; 
0<ml>Chart-14_P_Patch_1940_564.txt<ml>a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java throw new IllegalArgumentException ( " Null ' marker ' argument . " ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } <ml>b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java throw new IllegalArgumentException ( " Null ' marker ' argument . " ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } 
0<ml>Closure-63_P_Patch_22_19.txt<ml>a / build / lib / classes / org / mozilla / javascript / resources / Messages . properties # This is replaced during jar assembly from property string # and should not be translated implementation . version = Rhino 1 . 7 release 3 PRERELEASE 2011 06 28 # # To add JavaScript error messages for a particular locale , create a a / build / lib / classes / org / mozilla / javascript / resources / Messages_fr . properties msg . dup . parms = \ Le nom de param \ u00E8tre " { 0 } " existe d \ u00E9j \ u00E0 . msg . too . big . jump = \ Programme trop complexe ? : d \ u00E9calage de saut trop important msg . too . big . index = \ Programme trop complexe ? : l ' ' indice interne d \ u00E9passe la limite de 64 ? ko msg . ctor . not . found = \ Le constructeur de " { 0 } " est introuvable msg . not . ctor = \ msg . cant . call . indirect = \ La fonction " { 0 } " doit \ u00EAtre appel \ u00E9e directement et non par l ' ' interm \ u00E9diaire d ' ' une fonction portant un autre nom msg . eval . nonstring = \ Si vous appelez la fonction eval ( ) avec une valeur qui n ' ' appartient pas \ u00E0 une cha \ u00EEne primitive , c ' ' est la valeur en question qui est renvoy \ u00E9e . \ u00E9tait - ce votre intention ? ? msg . only . from . new = \ { 0 } ne peut \ u00EAtre appel \ u00E9e qu ' ' \ u00E0 partir d ' ' une " nouvelle " expression . msg . deprec . ctor = \ msg . bad . esc . mask = \ le masque d ' ' \ u00E9chappement de cha \ u00EEne est incorrect msg . cant . instantiate = \ erreur lors de l ' ' instanciation ( { 0 } ) ? : la classe { 1 } est une classe interface ou abstract msg . bad . ctor . sig = \ Un constructeur avec une signature incorrecte a \ u00E9t \ u00E9 d \ u00E9tect \ u00E9 ? : { 0 } qui appelle { 1 } avec la signature { 2 } msg . not . java . obj = \ L ' ' argument attendu pour la fonction getClass ( ) doit \ u00EAtre un objet Java msg . no . java . ctor = \ Le constructeur Java de " { 0 } " avec les arguments " { 1 } " est introuvable msg . method . ambiguous = \ Le choix de la m \ u00E9thode Java { 0 } . { 1 } correspondant aux types d ' ' argument JavaScript ( { 2 } ) est ambigu . Les m \ u00E9thodes propos \ u00E9es sont les suivantes ? : { 3 } msg . constructor . ambiguous = \ Le choix du constructeur Java { 0 } correspondant aux types d ' ' argument JavaScript ( { 1 } ) est ambigu . Les constructeurs propos \ u00E9s sont les suivants ? : { 2 } msg . conversion . not . allowed = \ Impossible de convertir { 0 } en { 1 } msg . not . classloader = \ msg . no . semi . for . cond = \ il manque ' ' ; ' ' apr \ u00E8s la condition for - loop msg . no . paren . for . ctrl = \ il manque ' ' ) ' ' apr \ u00E8s le contr ? le for - loop msg . no . paren . with = \ il manque ' ' ( ' ' avant un objet with - statement msg . no . paren . after . with = \ msg . missing . exponent = \ il manque un exposant msg . caught . nfe = \ erreur de format de nombre ? : { 0 } msg . unterminated . string . lit = \ le litt \ u00E9ral de la cha \ u00EEne n ' ' a pas de limite msg . unterminated . comment = \ msg . undefined = \ La valeur non d \ u00E9finie ne poss \ u00E8de pas de propri \ u00E9t \ u00E9 msg . java . internal . field . type = \ Erreur interne ? : la conversion de type de { 0 } afin d ' ' affecter { 1 } \ u00E0 { 2 } a \ u00E9chou \ u00E9 msg . java . conversion . implicit_method = \ La m \ u00E9thode de conversion " { 0 } " est introuvable dans la classe { 1 } sg . java . method . assign = \ La m \ u00E9thode Java " { 0 } " ne peut pas \ u00EAtre affect \ u00E9e \ u00E0 msg . java . internal . private = \ Erreur interne ? : une tentative d ' ' acc \ u00E9der \ u00E0 un champ " { 0 } " priv \ u00E9 / prot \ u00E9g \ u00E9 a \ u00E9t \ u00E9 d \ u00E9tect \ u00E9e msg . java . no_such_method = \ La m \ u00E9thode ' ' { 0 } ' ' est introuvable msg . script . is . not . constructor = \ msg . pkg . int = \ Les noms de package Java ne peuvent pas \ u00EAtre des nombres msg . ambig . import = \ Importation ambigu \ u00EB ? : " { 0 } " et " { 1 } " msg . not . pkg = \ La fonction importPackage doit \ u00EAtre appel \ u00E9e avec un package et non avec " { 0 } " msg . not . class = \ a / src / com / google / javascript / jscomp / LightweightMessageFormatter . java / / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { <ml>b / build / lib / classes / org / mozilla / javascript / resources / Messages . properties # This is replaced during jar assembly from property string # and should not be translated implementation . version = Rhino 1 . 7 release 3 PRERELEASE 2019 08 09 # # To add JavaScript error messages for a particular locale , create a b / build / lib / classes / org / mozilla / javascript / resources / Messages_fr . properties msg . dup . parms = \ Le nom de param \ u00E8tre " { 0 } " existe d \ u00E9j \ u00E0 . msg . too . big . jump = \ Programme trop complexe ? : d \ u00E9calage de saut trop important msg . too . big . index = \ Programme trop complexe ? : l ' ' indice interne d \ u00E9passe la limite de 64 ? ko msg . ctor . not . found = \ Le constructeur de " { 0 } " est introuvable msg . not . ctor = \ msg . cant . call . indirect = \ La fonction " { 0 } " doit \ u00EAtre appel \ u00E9e directement et non par l ' ' interm \ u00E9diaire d ' ' une fonction portant un autre nom msg . eval . nonstring = \ Si vous appelez la fonction eval ( ) avec une valeur qui n ' ' appartient pas \ u00E0 une cha \ u00EEne primitive , c ' ' est la valeur en question qui est renvoy \ u00E9e . \ u00E9tait - ce votre intention ? ? msg . only . from . new = \ { 0 } ne peut \ u00EAtre appel \ u00E9e qu ' ' \ u00E0 partir d ' ' une " nouvelle " expression . msg . deprec . ctor = \ msg . bad . esc . mask = \ le masque d ' ' \ u00E9chappement de cha \ u00EEne est incorrect msg . cant . instantiate = \ erreur lors de l ' ' instanciation ( { 0 } ) ? : la classe { 1 } est une classe interface ou abstract msg . bad . ctor . sig = \ Un constructeur avec une signature incorrecte a \ u00E9t \ u00E9 d \ u00E9tect \ u00E9 ? : { 0 } qui appelle { 1 } avec la signature { 2 } msg . not . java . obj = \ L ' ' argument attendu pour la fonction getClass ( ) doit \ u00EAtre un objet Java msg . no . java . ctor = \ Le constructeur Java de " { 0 } " avec les arguments " { 1 } " est introuvable msg . method . ambiguous = \ Le choix de la m \ u00E9thode Java { 0 } . { 1 } correspondant aux types d ' ' argument JavaScript ( { 2 } ) est ambigu . Les m \ u00E9thodes propos \ u00E9es sont les suivantes ? : { 3 } msg . constructor . ambiguous = \ Le choix du constructeur Java { 0 } correspondant aux types d ' ' argument JavaScript ( { 1 } ) est ambigu . Les constructeurs propos \ u00E9s sont les suivants ? : { 2 } msg . conversion . not . allowed = \ Impossible de convertir { 0 } en { 1 } msg . not . classloader = \ msg . no . semi . for . cond = \ il manque ' ' ; ' ' apr \ u00E8s la condition for - loop msg . no . paren . for . ctrl = \ il manque ' ' ) ' ' apr \ u00E8s le contr ? le for - loop msg . no . paren . with = \ il manque ' ' ( ' ' avant un objet with - statement msg . no . paren . after . with = \ msg . missing . exponent = \ il manque un exposant msg . caught . nfe = \ erreur de format de nombre ? : { 0 } msg . unterminated . string . lit = \ le litt \ u00E9ral de la cha \ u00EEne n ' ' a pas de limite msg . unterminated . comment = \ msg . undefined = \ La valeur non d \ u00E9finie ne poss \ u00E8de pas de propri \ u00E9t \ u00E9 msg . java . internal . field . type = \ Erreur interne ? : la conversion de type de { 0 } afin d ' ' affecter { 1 } \ u00E0 { 2 } a \ u00E9chou \ u00E9 msg . java . conversion . implicit_method = \ La m \ u00E9thode de conversion " { 0 } " est introuvable dans la classe { 1 } sg . java . method . assign = \ La m \ u00E9thode Java " { 0 } " ne peut pas \ u00EAtre affect \ u00E9e \ u00E0 msg . java . internal . private = \ Erreur interne ? : une tentative d ' ' acc \ u00E9der \ u00E0 un champ " { 0 } " priv \ u00E9 / prot \ u00E9g \ u00E9 a \ u00E9t \ u00E9 d \ u00E9tect \ u00E9e msg . java . no_such_method = \ La m \ u00E9thode ' ' { 0 } ' ' est introuvable msg . script . is . not . constructor = \ msg . pkg . int = \ Les noms de package Java ne peuvent pas \ u00EAtre des nombres msg . ambig . import = \ Importation ambigu \ u00EB ? : " { 0 } " et " { 1 } " msg . not . pkg = \ La fonction importPackage doit \ u00EAtre appel \ u00E9e avec un package et non avec " { 0 } " msg . not . class = \ b / src / com / google / javascript / jscomp / LightweightMessageFormatter . java / / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { 
0<ml>Lang-51_P_Patch_83_75.txt<ml>a / src / java / org / apache / commons / lang / BooleanUtils . java } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; <ml>b / src / java / org / apache / commons / lang / BooleanUtils . java } case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) | | ! ( ch = = ' Y ' ) ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; 
0<ml>Chart-5_P_Patch_100_32.txt<ml>a / source / org / jfree / data / xy / XYSeries . java / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { <ml>b / source / org / jfree / data / xy / XYSeries . java / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { 
0<ml>Closure-115_P_Patch_232_166.txt<ml>a / src / com / google / javascript / jscomp / FunctionInjector . java / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . <ml>b / src / com / google / javascript / jscomp / FunctionInjector . java / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . 
0<ml>Lang-21_P_Patch_154_93.txt<ml>a / src / main / java / org / apache / commons / lang3 / time / DateUtils . java return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & & <ml>b / src / main / java / org / apache / commons / lang3 / time / DateUtils . java return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( MODIFY_TRUNCATE ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & & 
0<ml>Math-80_P_Patch_4341_2826.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java } / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ; <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java } / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) goodStep ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ; 
0<ml>Math-42_P_Patch_3449_1703.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 , <ml>b / src / main / java / org / apache / commons / math / optimization / linear / SimplexTableau . java maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 , 
0<ml>Lang-7_P_Patch_3162_1871.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( " A blank string is not a valid number " ) ; } if ( str . startsWith ( " - - " ) ) { <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java if ( str = = null ) { return null ; } if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( " - - " ) ) ) { throw new NumberFormatException ( " A blank string is not a valid number " ) ; } if ( str . startsWith ( " - - " ) ) { 
0<ml>Math-63_P_Patch_4_4.txt<ml>a / src / main / java / org / apache / commons / math / util / MathUtils . java * @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } <ml>b / src / main / java / org / apache / commons / math / util / MathUtils . java * @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y ; } 
0<ml>Lang-44_P_Patch_3382_1595.txt<ml>a / src / java / org / apache / commons / lang / NumberUtils . java case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { <ml>b / src / java / org / apache / commons / lang / NumberUtils . java case ' l ' : case ' L ' : if ( dec = = null & & exp = = null | | ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { 
0<ml>Math-84_P_Patch_93_43.txt<ml>a / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence <ml>b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence 
0<ml>Chart-15_P_Patch_564_218.txt<ml>a / source / org / jfree / chart / plot / PiePlot3D . java linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels <ml>b / source / org / jfree / chart / plot / PiePlot3D . java linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels 
0<ml>Lang-10_P_Patch_1577_529.txt<ml>a / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( " \ \ s * + " ) ; <ml>b / src / main / java / org / apache / commons / lang3 / time / FastDateParser . java boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( ( Character . isWhitespace ( c ) ) & & ! ( unquote ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( " \ \ s * + " ) ; 
0<ml>Closure-62_P_Patch_22_19.txt<ml>a / src / com / google / javascript / jscomp / LightweightMessageFormatter . java / / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { <ml>b / src / com / google / javascript / jscomp / LightweightMessageFormatter . java / / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { 
0<ml>Time-17_P_Patch_5075_2912.txt<ml>a / src / main / java / org / joda / time / DateTimeZone . java / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } <ml>b / src / main / java / org / joda / time / DateTimeZone . java / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = getOffset ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } 
0<ml>Lang-43_P_Patch_416_120.txt<ml>a / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ; <ml>b / src / java / org / apache / commons / lang / text / ExtendedMessageFormat . java while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ; 
0<ml>Math-8_P_Patch_41_6.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; <ml>b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 1 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; 
0<ml>Math-2_P_Patch_155_56.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <ml>b / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( serialVersionUID ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; 
0<ml>Closure-35_P_Patch_27_13.txt<ml>a / src / com / google / javascript / jscomp / TypeInference . java ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; <ml>b / src / com / google / javascript / jscomp / TypeInference . java ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; 
0<ml>Chart-3_P_Patch_583_267.txt<ml>a / source / org / jfree / data / time / TimeSeries . java this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ; <ml>b / source / org / jfree / data / time / TimeSeries . java this . data . remove ( 0 ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ; 
0<ml>Lang-57_P_Patch_33_11.txt<ml>a / src / java / org / apache / commons / lang / LocaleUtils . java * @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <ml>b / src / java / org / apache / commons / lang / LocaleUtils . java * @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) { return false ; } return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0<ml>Chart-12_P_Patch_8_5.txt<ml>a / source / org / jfree / data / general / AbstractDataset . java * @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } <ml>b / source / org / jfree / data / general / AbstractDataset . java * @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( listener ) ; return list . contains ( listener ) ; } 
0<ml>Closure-129_P_Patch_25_21.txt<ml>a / src / com / google / javascript / rhino / Node . java } } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } } <ml>b / src / com / google / javascript / rhino / Node . java } } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return ( false ) | | ! ( recur ) ; } } 
0<ml>Math-15_P_Patch_524_360.txt<ml>a / src / main / java / org / apache / commons / math3 / util / FastMath . java if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; } <ml>b / src / main / java / org / apache / commons / math3 / util / FastMath . java if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; } 
0<ml>Lang-59_P_Patch_382_208.txt<ml>a / src / java / org / apache / commons / lang / text / StrBuilder . java public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { <ml>b / src / java / org / apache / commons / lang / text / StrBuilder . java public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { 
0<ml>Lang-53_P_Patch_1593_845.txt<ml>a / src / java / org / apache / commons / lang / time / DateUtils . java } / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } <ml>b / src / java / org / apache / commons / lang / time / DateUtils . java } / / reset time if ( ( ! round | | millisecs < 500 ) ) { date . setTime ( time ) ; val . setTime ( date ) ; } 
0<ml>Math-82_P_Patch_600_284.txt<ml>a / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } <ml>b / src / main / java / org / apache / commons / math / optimization / linear / SimplexSolver . java double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , this . epsilon , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } 
0<ml>Chart-26_P_Patch_4159_891.txt<ml>a / source / org / jfree / chart / plot / CategoryPlot . java / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; } <ml>b / source / org / jfree / chart / plot / CategoryPlot . java / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; } 
0<ml>Math-88_P_Patch_257_146.txt<ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } <ml>b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } } 
0<ml>Lang-27_P_Patch_865_448.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; 
0<ml>Lang-63_P_Patch_22_1.txt<ml>a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { <ml>b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = endValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { 
0<ml>Closure-126_P_Patch_4_3.txt<ml>a / src / com / google / javascript / jscomp / MinimizeExitPoints . java if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } <ml>b / src / com / google / javascript / jscomp / MinimizeExitPoints . java if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( allCatchNodes , exitType , labelName ) ; } } 
0<ml>Closure-45_P_Patch_281_95.txt<ml>a / src / com / google / javascript / jscomp / RemoveUnusedVars . java for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) { <ml>b / src / com / google / javascript / jscomp / RemoveUnusedVars . java for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else assignedToUnknownValue = true ; } if ( assignedToUnknownValue & & hasPropertyAssign ) { 
0<ml>Math-50_P_Patch_8_7.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( f0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; 
0<ml>Chart-13_P_Patch_9_7.txt<ml>a / source / org / jfree / data / Range . java public Range ( double lower , double upper ) { if ( lower > upper ) { String msg = " Range ( double , double ) : require lower ( " + lower + " ) < = upper ( " + upper + " ) . " ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ; <ml>b / source / org / jfree / data / Range . java public Range ( double lower , double upper ) { if ( lower > upper ) {  } this . lower = lower ; this . upper = upper ; 
0<ml>Lang-39_P_Patch_525_180.txt<ml>a / src / java / org / apache / commons / lang3 / StringUtils . java / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } <ml>b / src / java / org / apache / commons / lang3 / StringUtils . java / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } 
0<ml>Lang-58_P_Patch_999_513.txt<ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; <ml>b / src / java / org / apache / commons / lang / math / NumberUtils . java case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; 
0<ml>Chart-25_P_Patch_18_12.txt<ml>a / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java notifyListeners ( new RendererChangeEvent ( this ) ) ; } public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) {  if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( " Requires StatisticalCategoryDataset . " ) ; } StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;  PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } <ml>b / source / org / jfree / chart / renderer / category / StatisticalBarRenderer . java notifyListeners ( new RendererChangeEvent ( this ) ) ; }  
0<ml>Math-81_P_Patch_108_32.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * start ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; 
0<ml>Lang-20_P_Patch_455_139.txt<ml>a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { <ml>b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { 
0<ml>Math-49_P_Patch_15_1.txt<ml>a / src / main / java / org / apache / commons / math / MathRuntimeException . java private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; } <ml>b / src / main / java / org / apache / commons / math / MathRuntimeException . java private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; } 
0<ml>Math-104_P_Patch_533_251.txt<ml>a / src / java / org / apache / commons / math / special / Gamma . java ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ; <ml>b / src / java / org / apache / commons / math / special / Gamma . java ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ; 
0<ml>Closure-12_P_Patch_37_11.txt<ml>a / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { return true ; } } <ml>b / src / com / google / javascript / jscomp / FlowSensitiveInlineVariables . java } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( apply ( c ) ) { return true ; } } 
0<ml>Math-62_P_Patch_354_98.txt<ml>a / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { <ml>b / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { 
0<ml>Math-57_P_Patch_447_97.txt<ml>a / src / main / java / org / apache / commons / math / stat / clustering / KMeansPlusPlusClusterer . java assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ; <ml>b / src / main / java / org / apache / commons / math / stat / clustering / KMeansPlusPlusClusterer . java assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ; 
0<ml>Chart-14_P_Patch_560_34.txt<ml>a / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } <ml>b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else { b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } 
0<ml>Math-78_P_Patch_525_329.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java / / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r2 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) { <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java / / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r1 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) { 
0<ml>Math-95_P_Patch_53_25.txt<ml>a / src / java / org / apache / commons / math / distribution / FDistributionImpl . java double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } <ml>b / src / java / org / apache / commons / math / distribution / FDistributionImpl . java double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return d ; } 
0<ml>Lang-51_P_Patch_120_90.txt<ml>a / src / java / org / apache / commons / lang / BooleanUtils . java ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; <ml>b / src / java / org / apache / commons / lang / BooleanUtils . java ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } case 4 : { char ch = str . charAt ( 0 ) ; 
0<ml>Chart-5_P_Patch_1_1.txt<ml>a / source / org / jfree / data / xy / XYSeries . java * @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } <ml>b / source / org / jfree / data / xy / XYSeries . java * @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; } 
0<ml>Closure-48_P_Patch_739_289.txt<ml>a / src / com / google / javascript / jscomp / TypedScopeCreator . java JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do : <ml>b / src / com / google / javascript / jscomp / TypedScopeCreator . java JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = ownerNode . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do : 
0<ml>Math-80_P_Patch_1243_193.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; 
0<ml>Math-84_P_Patch_135_45.txt<ml>a / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence <ml>b / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectional . java / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence 
0<ml>Chart-15_P_Patch_253_51.txt<ml>a / source / org / jfree / chart / plot / PiePlot3D . java notifyListeners ( new PlotChangeEvent ( this ) ) ; } public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) {  RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;  Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ; if ( info ! = null ) { info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; }  drawBackground ( g2 , plotArea ) ;  Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ;  double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ;  if ( DEBUG_DRAW_INTERIOR ) { double hGap = plotArea . getWidth ( ) * getInteriorGap ( ) ; double vGap = plotArea . getHeight ( ) * getInteriorGap ( ) ; double igx1 = plotArea . getX ( ) + hGap ; double igx2 = plotArea . getMaxX ( ) - hGap ; double igy1 = plotArea . getY ( ) + vGap ; double igy2 = plotArea . getMaxY ( ) - vGap ; g2 . setPaint ( Color . lightGray ) ; g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; }  double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;  if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ;  Rectangle2D linkAreaXX = new Rectangle2D . Double ( linkX , linkY , linkW , linkH * ( 1 - this . depthFactor ) ) ; state . setLinkArea ( linkAreaXX ) ;  if ( DEBUG_DRAW_LINK_AREA ) { g2 . setPaint ( Color . blue ) ; g2 . draw ( linkAreaXX ) ; g2 . setPaint ( Color . yellow ) ; g2 . draw ( new Ellipse2D . Double ( linkAreaXX . getX ( ) , linkAreaXX . getY ( ) , linkAreaXX . getWidth ( ) , linkAreaXX . getHeight ( ) ) ) ; }  double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + hh / 2 . 0 , linkY + vv / 2 . 0 , linkW - hh , linkH - vv ) ;  state . setExplodedPieArea ( explodeArea ) ;  double maximumExplodePercent = getMaximumExplodePercent ( ) ; double percent = maximumExplodePercent / ( 1 . 0 + maximumExplodePercent ) ;  double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + h1 / 2 . 0 , explodeArea . getY ( ) + v1 / 2 . 0 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ;  int depth = ( int ) ( pieArea . getHeight ( ) * this . depthFactor ) ; Rectangle2D linkArea = new Rectangle2D . Double ( linkX , linkY , linkW , linkH - depth ) ; state . setLinkArea ( linkArea ) ;  state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; state . setPieCenterY ( pieArea . getCenterY ( ) - depth / 2 . 0 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ;  PieDataset dataset = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  if ( dataset . getKeys ( ) . size ( ) > plotArea . getWidth ( ) ) { String text = " Too many elements " ; Font sfont = new Font ( " dialog " , Font . BOLD , 10 ) ; g2 . setFont ( sfont ) ; FontMetrics fm = g2 . getFontMetrics ( sfont ) ; int stringWidth = fm . stringWidth ( text ) ;  g2 . drawString ( text , ( int ) ( plotArea . getX ( ) + ( plotArea . getWidth ( ) - stringWidth ) / 2 ) , ( int ) ( plotArea . getY ( ) + ( plotArea . getHeight ( ) / 2 ) ) ) ; return ; } if ( isCircular ( ) ) { double min = Math . min ( plotArea . getWidth ( ) , plotArea . getHeight ( ) ) / 2 ; plotArea = new Rectangle2D . Double ( plotArea . getCenterX ( ) - min , plotArea . getCenterY ( ) - min , 2 * min , 2 * min ) ; } List sectionKeys = dataset . getKeys ( ) ;  if ( sectionKeys . size ( ) = = 0 ) { return ; }  double arcX = pieArea . getX ( ) ; double arcY = pieArea . getY ( ) ;  Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  double totalValue = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; double runningTotal = 0 ; if ( depth < 0 ) { return ; / / if depth is negative don ' t draw anything }  ArrayList arcList = new ArrayList ( ) ; Arc2D . Double arc ; Paint paint ; Paint outlinePaint ; Stroke outlineStroke ;  Iterator iterator = sectionKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) {  Comparable currentKey = ( Comparable ) iterator . next ( ) ; Number dataValue = dataset . getValue ( currentKey ) ; if ( dataValue = = null ) { arcList . add ( null ) ; continue ; } double value = dataValue . doubleValue ( ) ; if ( value < = 0 ) { arcList . add ( null ) ; continue ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double angle1 = startAngle + ( direction * ( runningTotal * 360 ) ) / totalValue ; double angle2 = startAngle + ( direction * ( runningTotal + value ) * 360 ) / totalValue ; if ( Math . abs ( angle2 - angle1 ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else { arcList . add ( null ) ; } runningTotal + = value ; }  Shape oldClip = g2 . getClip ( ) ;  Ellipse2D top = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Ellipse2D bottom = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Rectangle2D lower = new Rectangle2D . Double ( top . getX ( ) , top . getCenterY ( ) , pieArea . getWidth ( ) , bottom . getMaxY ( ) - top . getCenterY ( ) ) ;  Rectangle2D upper = new Rectangle2D . Double ( pieArea . getX ( ) , top . getY ( ) , pieArea . getWidth ( ) , bottom . getCenterY ( ) - top . getY ( ) ) ;  Area a = new Area ( top ) ; a . add ( new Area ( lower ) ) ; Area b = new Area ( bottom ) ; b . add ( new Area ( upper ) ) ; Area pie = new Area ( a ) ; pie . intersect ( b ) ;  Area front = new Area ( pie ) ; front . subtract ( new Area ( top ) ) ;  Area back = new Area ( pie ) ; back . subtract ( new Area ( bottom ) ) ;  int [ ] xs ; int [ ] ys ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ;  int categoryCount = arcList . size ( ) ; for ( int categoryIndex = 0 ; categoryIndex < categoryCount ; categoryIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( categoryIndex ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( categoryIndex ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setPaint ( paint ) ; g2 . fill ( arc ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( arc ) ; g2 . setPaint ( paint ) ;  Point2D p1 = arc . getStartPoint ( ) ;  xs = new int [ ] { ( int ) arc . getCenterX ( ) , ( int ) arc . getCenterX ( ) , ( int ) p1 . getX ( ) , ( int ) p1 . getX ( ) } ; ys = new int [ ] { ( int ) arc . getCenterY ( ) , ( int ) arc . getCenterY ( ) - depth , ( int ) p1 . getY ( ) - depth , ( int ) p1 . getY ( ) } ; Polygon polygon = new Polygon ( xs , ys , 4 ) ; g2 . setPaint ( java . awt . Color . lightGray ) ; g2 . fill ( polygon ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ;  }  g2 . setPaint ( Color . gray ) ; g2 . fill ( back ) ; g2 . fill ( front ) ;  int cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , false , true ) ; } cat + + ; }  cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , true , false ) ; } cat + + ; }  g2 . setClip ( oldClip ) ;  Arc2D upperArc ; for ( int sectionIndex = 0 ; sectionIndex < categoryCount ; sectionIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( sectionIndex ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ;  Comparable currentKey = ( Comparable ) sectionKeys . get ( sectionIndex ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; g2 . setPaint ( paint ) ; g2 . fill ( upperArc ) ; g2 . setStroke ( outlineStroke ) ; g2 . setPaint ( outlinePaint ) ; g2 . draw ( upperArc ) ;  if ( info ! = null ) { EntityCollection entities = info . getOwner ( ) . getEntityCollection ( ) ; if ( entities ! = null ) { String tip = null ; PieToolTipGenerator tipster = getToolTipGenerator ( ) ; if ( tipster ! = null ) { tip = tipster . generateToolTip ( dataset , currentKey ) ; } String url = null ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , sectionIndex , currentKey , tip , url ) ; entities . add ( entity ) ; } } List keys = dataset . getKeys ( ) ; Rectangle2D adjustedPlotArea = new Rectangle2D . Double ( originalPlotArea . getX ( ) , originalPlotArea . getY ( ) , originalPlotArea . getWidth ( ) , originalPlotArea . getHeight ( ) - depth ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } }  g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ; drawOutline ( g2 , originalPlotArea ) ;  } <ml>b / source / org / jfree / chart / plot / PiePlot3D . java notifyListeners ( new PlotChangeEvent ( this ) ) ; }  
0<ml>Closure-66_P_Patch_15_3.txt<ml>a / src / com / google / javascript / jscomp / TypeCheck . java * @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = nullCount + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else { <ml>b / src / com / google / javascript / jscomp / TypeCheck . java * @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = this . noTypeCheckSection + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else { 
0<ml>Closure-22_P_Patch_77_31.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( gramps = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) 
0<ml>Math-6_P_Patch_1_1.txt<ml>a / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java * @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; } <ml>b / src / main / java / org / apache / commons / math3 / optim / BaseOptimizer . java * @ return the number of evaluations of the objective function . public int getIterations ( ) { return this . evaluations . getCount ( ) ; } 
0<ml>Lang-22_P_Patch_694_214.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / Fraction . java private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to <ml>b / src / main / java / org / apache / commons / lang3 / math / Fraction . java private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to 
0<ml>Math-2_P_Patch_367_117.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; <ml>b / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistribution . java final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - upper ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ; 
0<ml>Closure-108_P_Patch_408_102.txt<ml>a / src / com / google / javascript / jscomp / ScopedAliases . java compiler . getCodingConvention ( ) , globalName , value , v . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; <ml>b / src / com / google / javascript / jscomp / ScopedAliases . java compiler . getCodingConvention ( ) , globalName , value , grandparent . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; 
0<ml>Lang-13_P_Patch_78_11.txt<ml>a / src / main / java / org / apache / commons / lang3 / SerializationUtils . java } @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } } <ml>b / src / main / java / org / apache / commons / lang3 / SerializationUtils . java }  } 
0<ml>Closure-21_P_Patch_15_4.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; 
0<ml>Lang-59_P_Patch_714_324.txt<ml>a / src / java / org / apache / commons / lang / text / StrBuilder . java public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { <ml>b / src / java / org / apache / commons / lang / text / StrBuilder . java public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { 
0<ml>Chart-7_P_Patch_6_2.txt<ml>a / source / org / jfree / data / time / TimePeriodValues . java * @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } <ml>b / source / org / jfree / data / time / TimePeriodValues . java * @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ; } 
0<ml>Math_3_P_Patch_1.txt<ml>a / src / main / java / org / apache / commons / math3 / util / MathArrays . java / / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) { <ml>b / src / main / java / org / apache / commons / math3 / util / MathArrays . java / / Revert to scalar multiplication . final double [ ] prodHigh = new double [ SPLIT_FACTOR ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) { 
0<ml>Math_62-P_Patch_138.txt<ml>a / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { <ml>b / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { 
0<ml>Math_28-P_Patch_2.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { <ml>b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; DEFAULT_ULPS < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { 
0<ml>Math_32_P_Patch_15.txt<ml>a / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ; <ml>b / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSet . java if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ; 
0<ml>Closure_125_P_Patch_7.txt<ml>a / src / com / google / javascript / jscomp / TypeCheck . java JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else { <ml>b / src / com / google / javascript / jscomp / TypeCheck . java JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( ( fnType ! = null ) & & ( type . isConstructor ( ) ) ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else { 
0<ml>Time_18-P_Patch_76.txt<ml>a / src / main / java / org / joda / time / chrono / GJChronology . java return instant ; } public long getDateTimeMillis ( int year , int monthOfYear , int dayOfMonth , int hourOfDay , int minuteOfHour , int secondOfMinute , int millisOfSecond ) throws IllegalArgumentException { Chronology base ; if ( ( base = getBase ( ) ) ! = null ) { return base . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; }  long instant ; instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant < iCutoverMillis ) { instant = iJulianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant > = iCutoverMillis ) { throw new IllegalArgumentException ( " Specified date does not exist " ) ; } } return instant ; } <ml>b / src / main / java / org / joda / time / chrono / GJChronology . java return instant ; }  
0<ml>Time_2-P_Patch_8.txt<ml>a / src / main / java / org / joda / time / Partial . java DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( " Types array must be in order largest - smallest : " + types [ i - 1 ] . getName ( ) + " < " + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { types [ i - 1 ] . getName ( ) + " and " + loopType . getName ( ) ) ; } } } } lastUnitField = loopUnitField ; } <ml>b / src / main / java / org / joda / time / Partial . java DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( loopUnitField = = lastUnitField ) { if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( " Types array must be in order largest - smallest : " + types [ i - 1 ] . getName ( ) + " < " + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { types [ i - 1 ] . getName ( ) + " and " + loopType . getName ( ) ) ; } } } }  } lastUnitField = loopUnitField ; } 
0<ml>Lang_18_P_Patch_52.txt<ml>a / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; <ml>b / src / main / java / org / apache / commons / lang3 / time / FastDateFormat . java rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; 
0<ml>Chart_13_P_Patch_802.txt<ml>a / source / org / jfree / chart / block / BorderArrangement . java } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; <ml>b / source / org / jfree / chart / block / BorderArrangement . java } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { if ( w = = h ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; }  } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; 
0<ml>Math_88-P_Patch_156.txt<ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } <ml>b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } } 
0<ml>Lang_58_P_Patch_145.txt<ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { <ml>b / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { 
0<ml>Closure_22_P----_Patch_863.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( parent = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) 
0<ml>Closure_93_P_Patch_1.txt<ml>a / src / com / google / javascript / jscomp / ProcessClosurePrimitives . java } else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule ) <ml>b / src / com / google / javascript / jscomp / ProcessClosurePrimitives . java } else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = GOOG . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule ) 
0<ml>Lang_27_P_Patch_385.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } <ml>b / src / main / java / org / apache / commons / lang3 / math / NumberUtils . java mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 ) ; } else { mant = str ; } 
0<ml>Math_96-P_Patch_193.txt<ml>a / src / java / org / apache / commons / math / complex / Complex . java if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception <ml>b / src / java / org / apache / commons / math / complex / Complex . java if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) > = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception 
0<ml>Closure_109_P_Patch_34.txt<ml>a / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java * For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } <ml>b / src / com / google / javascript / jscomp / parsing / JsDocInfoParser . java * For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; } 
0<ml>Lang_13_P_Patch_11.txt<ml>a / src / main / java / org / apache / commons / lang3 / SerializationUtils . java } @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } } <ml>b / src / main / java / org / apache / commons / lang3 / SerializationUtils . java }  } 
0<ml>Closure_25_P_Patch_82.txt<ml>a / src / com / google / javascript / jscomp / TypeInference . java private FlowScope traverseNew ( Node n , FlowScope scope ) { Node constructor = n . getFirstChild ( ) ; scope = traverse ( constructor , scope ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { <ml>b / src / com / google / javascript / jscomp / TypeInference . java private FlowScope traverseNew ( Node n , FlowScope scope ) { Node constructor = n . getFirstChild ( ) ; scope = traverse ( constructor , traverseCall ( n , scope ) ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { 
0<ml>Math_15_P_Patch_191.txt<ml>a / src / main / java / org / apache / commons / math3 / util / FastMath . java if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; } <ml>b / src / main / java / org / apache / commons / math3 / util / FastMath . java if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; } 
0<ml>Time_17-P_Patch_105.txt<ml>a / src / main / java / org / joda / time / DateTimeZone . java / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } <ml>b / src / main / java / org / joda / time / DateTimeZone . java / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( convertLocalToUTC ( instant , earlierOrLater , instant ) + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } 
0<ml>Closure_92_P_Patch_1.txt<ml>a / src / com / google / javascript / jscomp / ProcessClosurePrimitives . java } else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule ) <ml>b / src / com / google / javascript / jscomp / ProcessClosurePrimitives . java } else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = GOOG . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule ) 
0<ml>Closure_21_P---_Patch_376.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java if ( isResultUsed ) { return ; } if ( parent = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; 
0<ml>Math_63-P_Patch_2.txt<ml>a / src / main / java / org / apache / commons / math / util / MathUtils . java * @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } <ml>b / src / main / java / org / apache / commons / math / util / MathUtils . java * @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( EPSILON ) & & Double . isNaN ( y ) ) | | x = = y ; } 
0<ml>Math_8_P_Patch_17.txt<ml>a / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; <ml>b / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistribution . java sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( sampleSize ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; 
0<ml>Math_62-P_Patch_290_90.txt<ml>a / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { <ml>b / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { 
0<ml>Math_28-P_Patch_56_8.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } <ml>b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( i , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } 
0<ml>Math_81-P_Patch_542_199.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start < = 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { 
0<ml>Lang_20-P_Patch_121_20.txt<ml>a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { <ml>b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { 
0<ml>Chart_14-P_Patch_170_4.txt<ml>a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } <ml>b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } 
0<ml>Time_18-P_Patch_124_47.txt<ml>a / src / main / java / org / joda / time / chrono / GJChronology . java return instant ; } public long getDateTimeMillis ( int year , int monthOfYear , int dayOfMonth , int hourOfDay , int minuteOfHour , int secondOfMinute , int millisOfSecond ) throws IllegalArgumentException { Chronology base ; if ( ( base = getBase ( ) ) ! = null ) { return base . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; }  long instant ; instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant < iCutoverMillis ) { instant = iJulianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant > = iCutoverMillis ) { throw new IllegalArgumentException ( " Specified date does not exist " ) ; } } return instant ; } <ml>b / src / main / java / org / joda / time / chrono / GJChronology . java return instant ; }  
0<ml>Lang_63-P_Patch_294_57.txt<ml>a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; <ml>b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( end , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; 
0<ml>Closure_11-P_Patch_1_1.txt<ml>a / src / com / google / javascript / jscomp / TypeCheck . java if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , " ' . ' " , " dict " ) ; } else if ( n . getJSType ( ) ! = null & & parent . isAssign ( ) ) { return ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , " No properties on this expression " , getNativeType ( OBJECT_TYPE ) ) ) { <ml>b / src / com / google / javascript / jscomp / TypeCheck . java if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , " ' . ' " , " dict " ) ; } else if ( n . getJSType ( ) = = null & & parent . isAssign ( ) ) { return ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , " No properties on this expression " , getNativeType ( OBJECT_TYPE ) ) ) { 
0<ml>Math_88-P_Patch_117_64.txt<ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } <ml>b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } } 
0<ml>Lang_39-P_Patch_13_1.txt<ml>a / src / java / org / apache / commons / lang3 / StringUtils . java / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } <ml>b / src / java / org / apache / commons / lang3 / StringUtils . java / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } 
0<ml>Lang_58-P_Patch_3_3.txt<ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { <ml>b / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { 
0<ml>Math_50-P_Patch_2_2.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java break ; case REGULA_FALSI : / / Nothing . if ( fx = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } 
0<ml>Lang_22-P_Patch_8_8.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / Fraction . java private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to <ml>b / src / main / java / org / apache / commons / lang3 / math / Fraction . java private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to 
0<ml>Closure_21-P_Patch_62_16.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java if ( isResultUsed ) { return ; } if ( parent = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; 
0<ml>Lang_13-P_Patch_12_3.txt<ml>a / src / main / java / org / apache / commons / lang3 / SerializationUtils . java } @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } } <ml>b / src / main / java / org / apache / commons / lang3 / SerializationUtils . java }  } 
0<ml>Chart_7-P_Patch_12_3.txt<ml>a / source / org / jfree / data / time / TimePeriodValues . java } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; <ml>b / source / org / jfree / data / time / TimePeriodValues . java } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; 
0<ml>Math_80-P_Patch_15_2.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; 
0<ml>Closure_22-P_Patch_174_63.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( gramps = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) 
0<ml>Lang_21_P_Patch_734.txt<ml>a / src / main / java / org / apache / commons / lang3 / time / DateUtils . java return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & & <ml>b / src / main / java / org / apache / commons / lang3 / time / DateUtils . java return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( MODIFY_TRUNCATE ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & & 
0<ml>Chart_7_P_Patch_1.txt<ml>a / source / org / jfree / data / time / TimePeriodValues . java } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; <ml>b / source / org / jfree / data / time / TimePeriodValues . java } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; 
0<ml>Math_52-P_Patch_38.txt<ml>a / src / main / java / org / apache / commons / math / geometry / euclidean / threed / Rotation . java Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; <ml>b / src / main / java / org / apache / commons / math / geometry / euclidean / threed / Rotation . java Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; 
0<ml>Closure_59_P_Patch_8.txt<ml>a / src / com / google / javascript / jscomp / Compiler . java CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ; <ml>b / src / com / google / javascript / jscomp / Compiler . java CheckLevel . OFF ) ; } if ( ( options . checkGlobalThisLevel . isOn ( ) ) & & ! ( options . enables ( DiagnosticGroups . CHECK_TYPES ) ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ; 
0<ml>Math_73-P_Patch_31.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BrentSolver . java / / full Brent algorithm starting with provided initial guess return solve ( f , solve ( yMax , yMax ) , yMin , max , yMax , initial , yInitial ) ; } 
0<ml>Math_94-P_Patch_18.txt<ml>a / src / java / org / apache / commons / math / util / MathUtils . java * @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to <ml>b / src / java / org / apache / commons / math / util / MathUtils . java * @ since 1 . 1 public static int gcd ( int u , int v ) { if ( sign ( u ) * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to 
0<ml>Closure_4_P_Patch_18.txt<ml>a / src / com / google / javascript / rhino / jstype / NamedType . java / / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; } <ml>b / src / com / google / javascript / rhino / jstype / NamedType . java / / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; } 
0<ml>Math_56-P_Patch_225.txt<ml>a / src / main / java / org / apache / commons / math / util / MultidimensionalCounter . java int idx = 1 ; while ( count < index ) { count + = idx ; } - idx ; <ml>b / src / main / java / org / apache / commons / math / util / MultidimensionalCounter . java int idx = 1 ; while ( count < index ) { count + = ResizableDoubleArray . ADDITIVE_MODE ; + idx ; } 
0<ml>Math_62-P_Patch_290_90.txt<ml>a / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { <ml>b / src / main / java / org / apache / commons / math / optimization / univariate / MultiStartUnivariateRealOptimizer . java try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { 
0<ml>Math_28-P_Patch_56_8.txt<ml>a / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } <ml>b / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolver . java for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( i , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } 
0<ml>Math_81-P_Patch_542_199.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start < = 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { 
0<ml>Lang_20-P_Patch_121_20.txt<ml>a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { a / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { <ml>b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { b / src / main / java / org / apache / commons / lang3 / StringUtils . java return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { 
0<ml>Chart_14-P_Patch_170_4.txt<ml>a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } a / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } <ml>b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / CategoryPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } b / source / org / jfree / chart / plot / XYPlot . java markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } 
0<ml>Time_18-P_Patch_124_47.txt<ml>a / src / main / java / org / joda / time / chrono / GJChronology . java return instant ; } public long getDateTimeMillis ( int year , int monthOfYear , int dayOfMonth , int hourOfDay , int minuteOfHour , int secondOfMinute , int millisOfSecond ) throws IllegalArgumentException { Chronology base ; if ( ( base = getBase ( ) ) ! = null ) { return base . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; }  long instant ; instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant < iCutoverMillis ) { instant = iJulianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant > = iCutoverMillis ) { throw new IllegalArgumentException ( " Specified date does not exist " ) ; } } return instant ; } <ml>b / src / main / java / org / joda / time / chrono / GJChronology . java return instant ; }  
0<ml>Lang_63-P_Patch_294_57.txt<ml>a / src / java / org / apache / commons / lang / time / DurationFormatUtils . java seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; <ml>b / src / java / org / apache / commons / lang / time / DurationFormatUtils . java seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( end , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; 
0<ml>Closure_11-P_Patch_1_1.txt<ml>a / src / com / google / javascript / jscomp / TypeCheck . java if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , " ' . ' " , " dict " ) ; } else if ( n . getJSType ( ) ! = null & & parent . isAssign ( ) ) { return ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , " No properties on this expression " , getNativeType ( OBJECT_TYPE ) ) ) { <ml>b / src / com / google / javascript / jscomp / TypeCheck . java if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , " ' . ' " , " dict " ) ; } else if ( n . getJSType ( ) = = null & & parent . isAssign ( ) ) { return ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , " No properties on this expression " , getNativeType ( OBJECT_TYPE ) ) ) { 
0<ml>Math_88-P_Patch_117_64.txt<ml>a / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } <ml>b / src / java / org / apache / commons / math / optimization / linear / SimplexTableau . java ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } } 
0<ml>Lang_39-P_Patch_13_1.txt<ml>a / src / java / org / apache / commons / lang3 / StringUtils . java / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } <ml>b / src / java / org / apache / commons / lang3 / StringUtils . java / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } 
0<ml>Lang_58-P_Patch_3_3.txt<ml>a / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { <ml>b / src / java / org / apache / commons / lang / math / NumberUtils . java switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { 
0<ml>Math_50-P_Patch_2_2.txt<ml>a / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } <ml>b / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolver . java break ; case REGULA_FALSI : / / Nothing . if ( fx = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } 
0<ml>Lang_22-P_Patch_8_8.txt<ml>a / src / main / java / org / apache / commons / lang3 / math / Fraction . java private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to <ml>b / src / main / java / org / apache / commons / lang3 / math / Fraction . java private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to 
0<ml>Closure_21-P_Patch_62_16.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java if ( isResultUsed ) { return ; } if ( parent = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; 
0<ml>Lang_13-P_Patch_12_3.txt<ml>a / src / main / java / org / apache / commons / lang3 / SerializationUtils . java } @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } } <ml>b / src / main / java / org / apache / commons / lang3 / SerializationUtils . java }  } 
0<ml>Chart_7-P_Patch_12_3.txt<ml>a / source / org / jfree / data / time / TimePeriodValues . java } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; <ml>b / source / org / jfree / data / time / TimePeriodValues . java } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; 
0<ml>Math_80-P_Patch_15_2.txt<ml>a / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; <ml>b / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpl . java private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; 
0<ml>Closure_22-P_Patch_174_63.txt<ml>a / src / com / google / javascript / jscomp / CheckSideEffects . java / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) <ml>b / src / com / google / javascript / jscomp / CheckSideEffects . java / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( gramps = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) 
0<ml>Lang-27_P_Patch_59_43.txt<ml> / tmp / jKali_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > ( - 1 ) ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; <ml> / tmp / jKali_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava } mant = str . substring ( 0 , decPos ) ; } else { if ( false ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; 
0<ml>Math-71_P_Patch_331_302.txt<ml> / tmp / jKali_Defects4J_Math_71 / src / main / java / org / apache / commons / math / ConvergingAlgorithmImpljava protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . defaultRelativeAccuracy = 1 . 0E - 14 ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ; <ml> / tmp / jKali_Defects4J_Math_71 / src / main / java / org / apache / commons / math / ConvergingAlgorithmImpljava protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ;  this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ; 
0<ml>Closure-45_P_Patch_5_5.txt<ml> / tmp / jKali_Defects4J_Closure_45 / src / com / google / javascript / jscomp / RemoveUnusedVarsjava for ( com . google . javascript . jscomp . RemoveUnusedVars . Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else { if ( ! ( com . google . javascript . jscomp . NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) ) { assignedToUnknownValue = true ; } } } <ml> / tmp / jKali_Defects4J_Closure_45 / src / com / google / javascript / jscomp / RemoveUnusedVarsjava for ( com . google . javascript . jscomp . RemoveUnusedVars . Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else { if ( true ) { assignedToUnknownValue = true ; } } } 
0<ml>Chart-13_P_Patch_49_48.txt<ml> / tmp / jKali_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , <ml> / tmp / jKali_Defects4J_Chart_13 / source / org / jfree / chart / block / BorderArrangementjava h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( false ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , 
0<ml>Chart-25_P_Patch_6_6.txt<ml> / tmp / jKali_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRendererjava org . jfree . data . statistics . StatisticalCategoryDataset statData = ( ( org . jfree . data . statistics . StatisticalCategoryDataset ) ( data ) ) ; org . jfree . chart . plot . PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = ( org . jfree . chart . plot . PlotOrientation . HORIZONTAL ) ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = ( org . jfree . chart . plot . PlotOrientation . VERTICAL ) ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } <ml> / tmp / jKali_Defects4J_Chart_25 / source / org / jfree / chart / renderer / category / StatisticalBarRendererjava org . jfree . data . statistics . StatisticalCategoryDataset statData = ( ( org . jfree . data . statistics . StatisticalCategoryDataset ) ( data ) ) ; org . jfree . chart . plot . PlotOrientation orientation = plot . getOrientation ( ) ;         } 
0<ml>Math-28_P_Patch_5_4.txt<ml> / tmp / jKali_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolverjava for ( java . lang . Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; ( i < ( ( tableau . getWidth ( ) ) - 1 ) ) & & ( minRow ! = row ) ; i + + ) { if ( row = = ( tableau . getBasicRow ( i ) ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; <ml> / tmp / jKali_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolverjava for ( java . lang . Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; ( i < ( ( tableau . getWidth ( ) ) - 1 ) ) & & ( minRow ! = row ) ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; 
0<ml>Math-49_P_Patch_22_16.txt<ml> / tmp / jKali_Defects4J_Math_49 / src / main / java / org / apache / commons / math / linear / OpenMapRealVectorjava public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! ( isDefaultValue ( value ) ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } <ml> / tmp / jKali_Defects4J_Math_49 / src / main / java / org / apache / commons / math / linear / OpenMapRealVectorjava public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { this . entries . put ( index , value ) ; } else if ( this . entries . containsKey ( index ) ) { this . entries . remove ( index ) ; } } 
0<ml>Closure-46_P_Patch_5_5.txt<ml> / tmp / jKali_Defects4J_Closure_46 / src / com / google / javascript / rhino / jstype / RecordTypejava @ java . lang . Override public com . google . javascript . rhino . jstype . JSType getLeastSupertype ( com . google . javascript . rhino . jstype . JSType that ) { if ( ! ( that . isRecordType ( ) ) ) { return super . getLeastSupertype ( that ) ; } com . google . javascript . rhino . jstype . RecordTypeBuilder builder = new com . google . javascript . rhino . jstype . RecordTypeBuilder ( registry ) ; <ml> / tmp / jKali_Defects4J_Closure_46 / src / com / google / javascript / rhino / jstype / RecordTypejava @ java . lang . Override public com . google . javascript . rhino . jstype . JSType getLeastSupertype ( com . google . javascript . rhino . jstype . JSType that ) { if ( true ) { return super . getLeastSupertype ( that ) ; } com . google . javascript . rhino . jstype . RecordTypeBuilder builder = new com . google . javascript . rhino . jstype . RecordTypeBuilder ( registry ) ; 
0<ml>Chart-1_P_Patch_36_35.txt<ml> / tmp / jKali_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRendererjava } int index = this . plot . getIndexOf ( this ) ; org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; <ml> / tmp / jKali_Defects4J_Chart_1 / source / org / jfree / chart / renderer / category / AbstractCategoryItemRendererjava } int index = this . plot . getIndexOf ( this ) ; org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; 
0<ml>Closure-63_P_Patch_3_3.txt<ml> / tmp / jKali_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( java . lang . Character . isWhitespace ( c ) ) { <ml> / tmp / jKali_Defects4J_Closure_63 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( java . lang . Character . isWhitespace ( c ) ) { 
0<ml>Chart-5_P_Patch_3_3.txt<ml> / tmp / jKali_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeriesjava if ( this . autoSort ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { <ml> / tmp / jKali_Defects4J_Chart_5 / source / org / jfree / data / xy / XYSeriesjava if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { 
0<ml>Math-32_P_Patch_2_2.txt<ml> / tmp / jKali_Defects4J_Math_32 / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSetjava if ( ( v . length ) = = 0 ) { final org . apache . commons . math3 . geometry . partitioning . BSPTree < org . apache . commons . math3 . geometry . euclidean . twod . Euclidean2D > tree = getTree ( false ) ; if ( ( ( java . lang . Boolean ) ( tree . getAttribute ( ) ) ) ) { setSize ( java . lang . Double . POSITIVE_INFINITY ) ; setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; <ml> / tmp / jKali_Defects4J_Math_32 / src / main / java / org / apache / commons / math3 / geometry / euclidean / twod / PolygonsSetjava if ( ( v . length ) = = 0 ) { final org . apache . commons . math3 . geometry . partitioning . BSPTree < org . apache . commons . math3 . geometry . euclidean . twod . Euclidean2D > tree = getTree ( false ) ; if ( false ) { setSize ( java . lang . Double . POSITIVE_INFINITY ) ; setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; 
0<ml>Math-80_P_Patch_14_14.txt<ml> / tmp / jKali_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava if ( ( 1 . 5 * ( work [ pingPong ] ) ) < ( work [ ( ( 4 * ( n - 1 ) ) + ( pingPong ) ) ] ) ) { int j = ( 4 * n ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ ( i + k ) ] ; work [ ( i + k ) ] = work [ ( j - k ) ] ; work [ ( j - k ) ] = tmp ; } j - = 4 ; } return true ; } return false ; <ml> / tmp / jKali_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava if ( ( 1 . 5 * ( work [ pingPong ] ) ) < ( work [ ( ( 4 * ( n - 1 ) ) + ( pingPong ) ) ] ) ) { int j = ( 4 * n ) - 1 ;         return true ; } return false ; 
0<ml>Math-29_P_Patch_92_84.txt<ml> / tmp / jKali_Defects4J_Math_29 / src / main / java / org / apache / commons / math3 / linear / OpenMapRealVectorjava this . epsilon = epsilon ; for ( int key = 0 ; key < ( values . length ) ; key + + ) { double value = values [ key ] ; if ( ! ( isDefaultValue ( value ) ) ) { entries . put ( key , value ) ; } } } <ml> / tmp / jKali_Defects4J_Math_29 / src / main / java / org / apache / commons / math3 / linear / OpenMapRealVectorjava this . epsilon = epsilon ; for ( int key = 0 ; key < ( values . length ) ; key + + ) { double value = values [ key ] ; if ( true ) { this . entries . put ( key , value ) ; } } } 
0<ml>Lang-7_P_Patch_18_17.txt<ml> / tmp / jKali_Defects4J_Lang_7 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava throw new java . lang . NumberFormatException ( " A blank string is not a valid number " ) ; } if ( str . startsWith ( " - - " ) ) { return null ; } if ( ( ( ( str . startsWith ( " 0x " ) ) | | ( str . startsWith ( " - 0x " ) ) ) | | ( str . startsWith ( " 0X " ) ) ) | | ( str . startsWith ( " - 0X " ) ) ) { int hexDigits = ( str . length ( ) ) - 2 ; <ml> / tmp / jKali_Defects4J_Lang_7 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava throw new java . lang . NumberFormatException ( " A blank string is not a valid number " ) ; } if ( str . startsWith ( " - - " ) ) {  } if ( ( ( ( str . startsWith ( " 0x " ) ) | | ( str . startsWith ( " - 0x " ) ) ) | | ( str . startsWith ( " 0X " ) ) ) | | ( str . startsWith ( " - 0X " ) ) ) { int hexDigits = ( str . length ( ) ) - 2 ; 
0<ml>Closure-62_P_Patch_3_3.txt<ml> / tmp / jKali_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava if ( ( ( excerpt . equals ( com . google . javascript . jscomp . SourceExcerptProvider . SourceExcerpt . LINE ) ) & & ( 0 < = charno ) ) & & ( charno < ( sourceExcerpt . length ( ) ) ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( java . lang . Character . isWhitespace ( c ) ) { <ml> / tmp / jKali_Defects4J_Closure_62 / src / com / google / javascript / jscomp / LightweightMessageFormatterjava if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( java . lang . Character . isWhitespace ( c ) ) { 
0<ml>Closure-101_P_Patch_49_45.txt<ml> / tmp / jKali_Defects4J_Closure_101 / src / com / google / javascript / jscomp / CompilationLeveljava private static void applySafeCompilationOptions ( com . google . javascript . jscomp . CompilerOptions options ) { options . closurePass = true ; options . variableRenaming = com . google . javascript . jscomp . VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = com . google . javascript . jscomp . CheckLevel . OFF ; <ml> / tmp / jKali_Defects4J_Closure_101 / src / com / google / javascript / jscomp / CompilationLeveljava private static void applySafeCompilationOptions ( com . google . javascript . jscomp . CompilerOptions options ) {  options . variableRenaming = com . google . javascript . jscomp . VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = com . google . javascript . jscomp . CheckLevel . OFF ; 
0<ml>Closure-22_P_Patch_14_14.txt<ml> / tmp / jKali_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava int ancestorType = an . getType ( ) ; if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) continue ; if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { <ml> / tmp / jKali_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava int ancestorType = an . getType ( ) ; if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) continue ;    } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { 
0<ml>Lang-22_P_Patch_50_50.txt<ml> / tmp / jKali_Defects4J_Lang_22 / src / main / java / org / apache / commons / lang3 / math / Fractionjava private static int greatestCommonDivisor ( int u , int v ) { if ( ( ( java . lang . Math . abs ( u ) ) < = 1 ) | | ( ( java . lang . Math . abs ( v ) ) < = 1 ) ) { return 1 ; } <ml> / tmp / jKali_Defects4J_Lang_22 / src / main / java / org / apache / commons / lang3 / math / Fractionjava private static int greatestCommonDivisor ( int u , int v ) { if ( false ) { return 1 ; } 
0<ml>Math-8_P_Patch_5_4.txt<ml> / tmp / jKali_Defects4J_Math_8 / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistributionjava final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ; <ml> / tmp / jKali_Defects4J_Math_8 / src / main / java / org / apache / commons / math3 / distribution / DiscreteDistributionjava final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ;    return out ; 
0<ml>Math-2_P_Patch_23_18.txt<ml> / tmp / jKali_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistributionjava } k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( tmp < upper ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } } <ml> / tmp / jKali_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistributionjava } k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( false ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } } 
0<ml>Closure-21_P_Patch_2_2.txt<ml> / tmp / jKali_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava return ; } if ( n = = ( parent . getLastChild ( ) ) ) { for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) continue ; if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) { <ml> / tmp / jKali_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava return ; } if ( n = = ( parent . getLastChild ( ) ) ) {       } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) { 
0<ml>Chart-26_P_Patch_158_78.txt<ml> / tmp / jMutRepair_Defects4J_Chart_26 / source / org / jfree / chart / plot / CategoryPlotjava boolean b1 = ( area . getWidth ( ) ) < = ( org . jfree . chart . plot . Plot . MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) ) < = ( org . jfree . chart . plot . Plot . MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; } <ml> / tmp / jMutRepair_Defects4J_Chart_26 / source / org / jfree / chart / plot / CategoryPlotjava boolean b1 = ( area . getWidth ( ) ) < = ( org . jfree . chart . plot . Plot . MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) ) < = ( org . jfree . chart . plot . Plot . MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; } 
0<ml>Math-88_P_Patch_60_56.txt<ml> / tmp / jMutRepair_Defects4J_Math_88 / src / java / org / apache / commons / math / optimization / linear / SimplexSolverjava double rhs = tableau . getEntry ( i , ( ( tableau . getWidth ( ) ) - 1 ) ) ; if ( ( org . apache . commons . math . util . MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) ) > = 0 ) { double ratio = rhs / ( tableau . getEntry ( i , col ) ) ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } <ml> / tmp / jMutRepair_Defects4J_Math_88 / src / java / org / apache / commons / math / optimization / linear / SimplexSolverjava double rhs = tableau . getEntry ( i , ( ( tableau . getWidth ( ) ) - 1 ) ) ; if ( ( org . apache . commons . math . util . MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) ) > = 0 ) { double ratio = rhs / ( tableau . getEntry ( i , col ) ) ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; } 
0<ml>Lang-27_P_Patch_67_55.txt<ml> / tmp / jMutRepair_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > ( - 1 ) ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; <ml> / tmp / jMutRepair_Defects4J_Lang_27 / src / main / java / org / apache / commons / lang3 / math / NumberUtilsjava } mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < ( - 1 ) ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; 
0<ml>Closure-126_P_Patch_2_2.txt<ml> / tmp / jMutRepair_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPointsjava if ( com . google . javascript . jscomp . NodeUtil . hasFinally ( n ) ) { com . google . javascript . rhino . Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } <ml> / tmp / jMutRepair_Defects4J_Closure_126 / src / com / google / javascript / jscomp / MinimizeExitPointsjava if ( ! ( com . google . javascript . jscomp . NodeUtil . hasFinally ( n ) ) ) { com . google . javascript . rhino . Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } 
0<ml>Math-50_P_Patch_3_3.txt<ml> / tmp / jMutRepair_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava break ; case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } <ml> / tmp / jMutRepair_Defects4J_Math_50 / src / main / java / org / apache / commons / math / analysis / solvers / BaseSecantSolverjava break ; case REGULA_FALSI : if ( x > x1 ) { x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } 
0<ml>Chart-25_P_Patch_8_4.txt<ml> / tmp / jMutRepair_Defects4J_Chart_25 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDatasetjava java . lang . Number result = null ; org . jfree . data . statistics . MeanAndStandardDeviation masd = ( ( org . jfree . data . statistics . MeanAndStandardDeviation ) ( this . data . getObject ( row , column ) ) ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; <ml> / tmp / jMutRepair_Defects4J_Chart_25 / source / org / jfree / data / statistics / DefaultStatisticalCategoryDatasetjava java . lang . Number result = null ; org . jfree . data . statistics . MeanAndStandardDeviation masd = ( ( org . jfree . data . statistics . MeanAndStandardDeviation ) ( this . data . getObject ( row , column ) ) ) ; if ( masd = = null ) { result = masd . getMean ( ) ; } return result ; 
0<ml>Math-81_P_Patch_3_3.txt<ml> / tmp / jMutRepair_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava double b1 = work [ ( np - 2 ) ] ; double b2 = work [ ( np - 6 ) ] ; final double gam = dN2 ; if ( ( ( work [ ( np - 8 ) ] ) > b2 ) | | ( ( work [ ( np - 4 ) ] ) > b1 ) ) { return ; } double a2 = ( ( work [ ( np - 8 ) ] ) / b2 ) * ( 1 + ( ( work [ ( np - 4 ) ] ) / b1 ) ) ; <ml> / tmp / jMutRepair_Defects4J_Math_81 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava double b1 = work [ ( np - 2 ) ] ; double b2 = work [ ( np - 6 ) ] ; final double gam = dN2 ; if ( ( ( this . work [ ( np - 8 ) ] ) ! = b2 ) | | ( ( this . work [ ( np - 4 ) ] ) > b1 ) ) { return ; } double a2 = ( ( work [ ( np - 8 ) ] ) / b2 ) * ( 1 + ( ( work [ ( np - 4 ) ] ) / b1 ) ) ; 
0<ml>Math-28_P_Patch_1_1.txt<ml> / tmp / jMutRepair_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolverjava for ( java . lang . Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; ( i < ( ( tableau . getWidth ( ) ) - 1 ) ) & & ( minRow ! = row ) ; i + + ) { if ( row = = ( tableau . getBasicRow ( i ) ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; <ml> / tmp / jMutRepair_Defects4J_Math_28 / src / main / java / org / apache / commons / math3 / optimization / linear / SimplexSolverjava for ( java . lang . Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; ( i < ( ( tableau . getWidth ( ) ) - 1 ) ) & & ( minRow ! = row ) ; i + + ) { if ( row ! = ( tableau . getBasicRow ( i ) ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; 
0<ml>Math-57_P_Patch_22_22.txt<ml> / tmp / jMutRepair_Defects4J_Math_57 / src / main / java / org / apache / commons / math / stat / clustering / EuclideanIntegerPointjava return false ; } for ( int i = 0 ; i < ( point . length ) ; i + + ) { if ( ( point [ i ] ) ! = ( otherPoint [ i ] ) ) { return false ; } } <ml> / tmp / jMutRepair_Defects4J_Math_57 / src / main / java / org / apache / commons / math / stat / clustering / EuclideanIntegerPointjava return false ; } for ( int i = 0 ; i < ( point . length ) ; i + + ) { if ( ( this . point [ i ] ) > ( otherPoint [ i ] ) ) { return false ; } } 
0<ml>Math-80_P_Patch_305_301.txt<ml> / tmp / jMutRepair_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava private boolean flipIfWarranted ( final int n , final int step ) { if ( ( 1 . 5 * ( work [ pingPong ] ) ) < ( work [ ( ( 4 * ( n - 1 ) ) + ( pingPong ) ) ] ) ) { int j = ( 4 * n ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { <ml> / tmp / jMutRepair_Defects4J_Math_80 / src / main / java / org / apache / commons / math / linear / EigenDecompositionImpljava private boolean flipIfWarranted ( final int n , final int step ) { if ( ( 1 . 5 * ( this . work [ this . pingPong ] ) ) = = ( this . work [ ( ( 4 * ( n - 1 ) ) + ( this . pingPong ) ) ] ) ) { int j = ( 4 * n ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { 
0<ml>Math-84_P_Patch_7_7.txt<ml> / tmp / jMutRepair_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectionaljava final org . apache . commons . math . optimization . RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( ( comparator . compare ( contracted , best ) ) < 0 ) { <ml> / tmp / jMutRepair_Defects4J_Math_84 / src / main / java / org / apache / commons / math / optimization / direct / MultiDirectionaljava final org . apache . commons . math . optimization . RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( ( comparator . compare ( contracted , best ) ) = = 0 ) { 
0<ml>Closure-22_P_Patch_17_9.txt<ml> / tmp / jMutRepair_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava if ( n = = ( parent . getLastChild ( ) ) ) { for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) continue ; if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else <ml> / tmp / jMutRepair_Defects4J_Closure_22 / src / com / google / javascript / jscomp / CheckSideEffectsjava if ( n = = ( parent . getLastChild ( ) ) ) { for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = ( com . google . javascript . rhino . Token . COMMA ) ) continue ; if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else 
0<ml>Math-52_P_Patch_34_34.txt<ml> / tmp / jMutRepair_Defects4J_Math_52 / src / main / java / org / apache / commons / math / geometry / euclidean / threed / Rotationjava org . apache . commons . math . geometry . euclidean . threed . Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; org . apache . commons . math . geometry . euclidean . threed . Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { org . apache . commons . math . geometry . euclidean . threed . Vector3D v3 = org . apache . commons . math . geometry . euclidean . threed . Vector3D . crossProduct ( v1 , v2 ) ; <ml> / tmp / jMutRepair_Defects4J_Math_52 / src / main / java / org / apache / commons / math / geometry / euclidean / threed / Rotationjava org . apache . commons . math . geometry . euclidean . threed . Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; org . apache . commons . math . geometry . euclidean . threed . Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c < = 0 ) { org . apache . commons . math . geometry . euclidean . threed . Vector3D v3 = org . apache . commons . math . geometry . euclidean . threed . Vector3D . crossProduct ( v1 , v2 ) ; 
0<ml>Lang-22_P_Patch_59_55.txt<ml> / tmp / jMutRepair_Defects4J_Lang_22 / src / main / java / org / apache / commons / lang3 / math / Fractionjava private static int greatestCommonDivisor ( int u , int v ) { if ( ( ( java . lang . Math . abs ( u ) ) < = 1 ) | | ( ( java . lang . Math . abs ( v ) ) < = 1 ) ) { return 1 ; } <ml> / tmp / jMutRepair_Defects4J_Lang_22 / src / main / java / org / apache / commons / lang3 / math / Fractionjava private static int greatestCommonDivisor ( int u , int v ) { if ( ( ( java . lang . Math . abs ( u ) ) < = 1 ) & & ( ( java . lang . Math . abs ( v ) ) < = 1 ) ) { return 1 ; } 
0<ml>Math-2_P_Patch_16_16.txt<ml> / tmp / jMutRepair_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistributionjava } k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( tmp < upper ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } } <ml> / tmp / jMutRepair_Defects4J_Math_2 / src / main / java / org / apache / commons / math3 / distribution / AbstractIntegerDistributionjava } k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( tmp > = upper ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } } 
0<ml>Closure-21_P_Patch_2_2.txt<ml> / tmp / jMutRepair_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava if ( n = = ( parent . getLastChild ( ) ) ) { for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = ( com . google . javascript . rhino . Token . COMMA ) ) continue ; if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else break ; } <ml> / tmp / jMutRepair_Defects4J_Closure_21 / src / com / google / javascript / jscomp / CheckSideEffectsjava if ( n = = ( parent . getLastChild ( ) ) ) { for ( com . google . javascript . rhino . Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = ( com . google . javascript . rhino . Token . COMMA ) ) continue ; if ( ( ancestorType ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ancestorType ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) return ; else break ; } 
0<ml>Chart-7_P_Patch_31_27.txt<ml> / tmp / jMutRepair_Defects4J_Chart_7 / source / org / jfree / data / time / TimePeriodValuesjava this . maxStartIndex = index ; } if ( ( this . minMiddleIndex ) > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; <ml> / tmp / jMutRepair_Defects4J_Chart_7 / source / org / jfree / data / time / TimePeriodValuesjava this . maxStartIndex = index ; } if ( ( this . minMiddleIndex ) = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; 

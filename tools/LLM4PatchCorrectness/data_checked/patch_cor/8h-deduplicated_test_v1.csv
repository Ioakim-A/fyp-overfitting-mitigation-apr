1,* @return the number of evaluations of the objective function.       */      public int getIterations() { +// start of generated patch +return evaluations.getCount(); +// end of generated patch +/* start of original code          return iterations.getCount(); + end of original code*/      }        /**
1,"-		flipIfWarranted(n, 2); +"
1,"-				tryMinimizeExits(finallyBlock, exitType, labelName); -			} +				if (true) +					return; 				tryMinimizeExits(finallyBlock, exitType, labelName);}"
1,"public class SimplexSolver extends AbstractLinearOptimizer {              if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) { -                    minRatio = ratio; +                    minRatio = rhs;                      minRatioPos = i;                   }              }"
1,"break;                  case REGULA_FALSI:                      // Nothing. +// start of generated patch +if(x==Double.POSITIVE_INFINITY){ +x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol)); +f0=computeObjectiveValue(x0); +} +// end of generated patch +/* start of original code                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      } + end of original code*/                      break;                  default:                      // Should never happen."
1,-		if (dataset != null) { -			return result; -		} + + +
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {          // store linear problem characteristics          this.function          = f;          this.linearConstraints = constraints; -        this.goal              = goalType; +        if (this.goal != null) { +	this.goal              = goalType; +} +          this.nonNegative       = restrictToNonNegative;            iterations  = 0; diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"-            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); + + + + + +"
1,-			if (strLen >= width) { +			if (strLen >= width) { 				buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY];
1,-            String str = (obj == null ? getNullText() : obj.toString()); +			java.lang.String str = (obj == null) ? getNullText() : obj.toString(); 			buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY];
1,"-			end.add(field, newdiff); +"
1,public class LightweightMessageFormatter extends AbstractMessageFormatter {        // charno == sourceExpert.length() means something is missing        // at the end of the line        if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno < b.length()) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {
1,-							b2 = work[nn - 5] / work[nn - 7]; +
1,double accum2 = 0.0; -                for (int i = begin; i < begin + length; i++) { -                    dev = values[i] - mean; -                    accum += weights[i] * (dev * dev); -                    accum2 += weights[i] * dev; +                if (mean <= length) { +                    for (int i = begin; i < begin + length; i++) { +                        dev = values[i] - mean; +                        accum += weights[i] * (dev * dev); +                        accum2 += weights[i] * dev; +                    }                  }
1,-					work[i + k] = work[j - k]; +
1,"-                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +						if (x == x1) + @@ -190 +190 @@ -                    } +"
1,"RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars); -        for (int i = 0; i < nVars; i++) { -            for (int j = 0; j < i; j++) { -              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); -              outMatrix.setEntry(i, j, corr); -              outMatrix.setEntry(j, i, corr); +        if ((nVars) != (2)) { +            for (int i = 0; i < nVars; i++) { +                for (int j = 0; j < i; j++) { +                    double corr = correlation(matrix.getColumn(i), matrix.getColumn(j)); +                    outMatrix.setEntry(i, j, corr); +                    outMatrix.setEntry(j, i, corr); +                } +                outMatrix.setEntry(i, i, 1d);              } -            outMatrix.setEntry(i, i, 1d);          }"
1,-		if (width > 0) { -			ensureCapacity(size + width); +		if (width > 0) { 			ensureCapacity(size + 4); +
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        if (src != null) { +	System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +} +      }        /**"
1,"public abstract class BaseSecantSolver                // If the current interval is within the given accuracies, we              // are satisfied with the current approximation. -            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), -                                                     atol)) { +            if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), +                                                     atol)) && (f1 >= 0)) {                  switch (allowed) {                  case ANY_SIDE:                      return x1;"
1,"public abstract class BaseSecantSolver                // If the current interval is within the given accuracies, we              // are satisfied with the current approximation. -            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), -                                                     atol)) { +            if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), +                                                     atol)) && !(f1 <= 0)) {                  switch (allowed) {                  case ANY_SIDE:                      return x1;"
1,"-		this.plot.draw(g2, plotArea, anchor, null, plotInfo); +"
1,"-                minValue = tableau.getEntry(0, i); -                minPos = i; -            } -        } -        return minPos; -    } @@ -76,16 +69,0 @@ -    private Integer getPivotRow(final int col, final SimplexTableau tableau) { -        double minRatio = Double.MAX_VALUE; -        Integer minRatioPos = null; -        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { -            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); -            final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { -                final double ratio = rhs / entry; -                if (ratio < minRatio) { -                    minRatio = ratio; -                    minRatioPos = i;  -                } -            } -        } -        return minRatioPos; -    } @@ -98,0 +77,22 @@ + + + + + + + + + + + + + + + + + + + + + +				f = f; 				minPos = i;}} 		return minPos;} 	private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) { 		double minRatio = java.lang.Double.MAX_VALUE; 		java.lang.Integer minRatioPos = null; 		for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { 			final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); 			final double entry = tableau.getEntry(i, col); 			if (org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon) >= 0) { 				final double ratio = rhs / entry; 				if (ratio < minRatio) { 					minRatio = ratio; 					minRatioPos = i;}}} 		return minRatioPos;}"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (this.baseURLGenerator != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,-						b2 = work[nn - 13] / work[nn - 15]; +
1,"break;                  case REGULA_FALSI:                      // Nothing. +// start of generated patch +if(x==ftol){ +x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol)); +f0=computeObjectiveValue(x0); +} +// end of generated patch +/* start of original code                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      } + end of original code*/                      break;                  default:                      // Should never happen."
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa > fb && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } +                  int seriesCount = dataset.getRowCount();          if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {              for (int i = 0; i < seriesCount; i++) {
1,"+			if (true) +				return; + + @@ -141,4 +144,0 @@ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      }"
1,"public class StatisticalBarRenderer extends BarRenderer          notifyListeners(new RendererChangeEvent(this));      }       -    /** -     * Draws the bar with its standard deviation line range for a single  -     * (series, category) data item. -     * -     * @param g2  the graphics device. -     * @param state  the renderer state. -     * @param dataArea  the data area. -     * @param plot  the plot. -     * @param domainAxis  the domain axis. -     * @param rangeAxis  the range axis. -     * @param data  the data. -     * @param row  the row index (zero-based). -     * @param column  the column index (zero-based). -     * @param pass  the pass index. -     */ -    public void drawItem(Graphics2D g2, -                         CategoryItemRendererState state, -                         Rectangle2D dataArea, -                         CategoryPlot plot, -                         CategoryAxis domainAxis, -                         ValueAxis rangeAxis, -                         CategoryDataset data, -                         int row, -                         int column, -                         int pass) { - -        // defensive check -        if (!(data instanceof StatisticalCategoryDataset)) { -            throw new IllegalArgumentException( -                ""Requires StatisticalCategoryDataset.""); -        } -        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; - -        PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis,  -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,  -                    statData, row, column); -        } -    } +                            /**       * Draws an item for a plot with a horizontal orientation."
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa / fb >= 0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,case '/' : -                            out.write('\\'); +                            if (escapeSingleQuote) { +                                out.write('\\'); +                            }                          out.write('/');
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array @@ -536,7 +492,10 @@ class SimplexTableau implements Serializable {       * @see #getNumDecisionVariables()       */      protected final int getOriginalNumDecisionVariables() { -        return f.getCoefficients().getDimension(); +        if (f == null) { +    return 0; +} +return f.getCoefficients().getDimension();      }        /**"
1,// at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (true) {          for (int i = 0; i < charno; i++) {
1,"public class SimplexSolver extends AbstractLinearOptimizer {              final double entry = tableau.getEntry(i, col);              if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio <= this.epsilon || (ratio < minRatio)) {                      minRatio = ratio;                      minRatioPos = i;                   }"
1,public class ZoneInfoCompiler {       * @return true to log verbosely       */      public static boolean verbose() { -        return cVerbose.get(); +        return cVerbose != null || cVerbose.get();      }        //-----------------------------------------------------------------------
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(expPos > -1)) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public abstract class BaseSecantSolver                // If the current interval is within the given accuracies, we              // are satisfied with the current approximation. -            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), -                                                     atol)) { +            if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), +                                                     atol)) && !((f1 <= 0))) {                  switch (allowed) {                  case ANY_SIDE:                      return x1;"
1,-							a2 = 0.0; +
1,-			for (int i = 0; i < j; i += 4) { -				for (int k = 0; k < 4; k += step) { -					final double tmp = work[i + k]; -					work[i + k] = work[j - k]; -					work[j - k] = tmp; -				} +			for (int i = 0; i < j; i += 4) + + + + + @@ -1143 +1143 @@ -			} +
1,-		char[] c = pattern.toCharArray(); +		char[] c = pattern.toCharArray(); 		pos.setIndex(pos.getIndex() + 1);
1,"class SimplexTableau implements Serializable {          // positive cost non-artificial variables          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +            if (Precision.compareTo(this.maxUlps, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }"
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(atol);                      }                      break;                  default:"
1,public class LightweightMessageFormatter extends AbstractMessageFormatter {        // padding equal to the excerpt and arrow at the end        // charno == sourceExpert.length() means something is missing        // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {
1,"// Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                    if (-1 == x1) { +                        if (x == x1) { +                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                            f0 = computeObjectiveValue(x0); +                        }                      }"
1,-            String str = (obj == null ? getNullText() : obj.toString()); +			java.lang.String str = (obj == null) ? getNullText() : obj.toString(); 			buffer = new char[str.length() + org.apache.commons.lang.text.StrBuilder.CAPACITY];
1,"// positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); +        if ((org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables) != (2)) { +            for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { +                final double entry = tableau.getEntry(0, i); +                if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +                    columnsToDrop.add(i); +                }              }"
1,"-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) { -                minValue = tableau.getEntry(0, i); +			if (org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) + @@ -65 +65 @@ -            } +"
1,public class SimplexSolver extends AbstractLinearOptimizer {                      for (; i < tableau.getWidth() - 1 && minRow != row; i++) {                          if (row == tableau.getBasicRow(i)) {                              if (i < minIndex) { -                                minIndex = i; +                                                                  minRow = row;                              }                          }
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa == b && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1)) +                        && (expPos < str.length() - 1)                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,"-        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { @@ -1135,11 +1134,12 @@ -            int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } -            return true; -        } + + + + + + + + + + + +"
1,-			int strLen = str.length(); +			int strLen = str.length(); 			buffer = new char[str.length() + org.apache.commons.lang.text.StrBuilder.CAPACITY];
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); -        } +                            return new double[]{a, b};      }"
1,-            String str = (obj == null ? getNullText() : obj.toString()); +			java.lang.String str = (obj == null) ? getNullText() : obj.toString(); 			ensureCapacity(size + 4);
1,-			result = masd.getMean(); +
1,public class EigenDecompositionImpl implements EigenDecomposition {              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                                          work[j - k] = tmp;                  }                  j -= 4;
1,public class EigenDecompositionImpl implements EigenDecomposition {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array              int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i>=j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];                      work[i + k] = work[j - k];
1,"-    } -    return builder.build(); -  } -  JSType getGreatestSubtypeHelper(JSType that) { -    if (that.isRecordType()) { -      RecordType thatRecord = that.toMaybeRecordType(); -      RecordTypeBuilder builder = new RecordTypeBuilder(registry); @@ -164,6 +156,0 @@ -      for (String property : properties.keySet()) { -        if (thatRecord.hasProperty(property) && -            !thatRecord.getPropertyType(property).isEquivalentTo( -                getPropertyType(property))) { -          return registry.getNativeObjectType(JSTypeNative.NO_TYPE); -        } @@ -171,3 +157,0 @@ -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } @@ -175,6 +158,0 @@ -      for (String property : thatRecord.properties.keySet()) { -        if (!hasProperty(property)) { -          builder.addProperty(property, thatRecord.getPropertyType(property), -              thatRecord.getPropertyNode(property)); -        } -      } @@ -182,2 +159,0 @@ -      return builder.build(); -    } @@ -185,6 +160,0 @@ -    JSType greatestSubtype = registry.getNativeType( -        JSTypeNative.NO_OBJECT_TYPE); -    JSType thatRestrictedToObj = -        registry.getNativeType(JSTypeNative.OBJECT_TYPE) -        .getGreatestSubtype(that); -    if (!thatRestrictedToObj.isEmptyType()) { @@ -197,19 +166,0 @@ -      for (Map.Entry<String, JSType> entry : properties.entrySet()) { -        String propName = entry.getKey(); -        JSType propType = entry.getValue(); -        UnionTypeBuilder builder = new UnionTypeBuilder(registry); -        for (ObjectType alt : -                 registry.getEachReferenceTypeWithProperty(propName)) { -          JSType altPropType = alt.getPropertyType(propName); -          if (altPropType != null && !alt.isEquivalentTo(this) && -              alt.isSubtype(that) && -              (propType.isUnknownType() || altPropType.isUnknownType() || -                  altPropType.isEquivalentTo(propType))) { -            builder.addAlternate(alt); -          } -        } -        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build()); -      } -    } -    return greatestSubtype; -  } @@ -217,4 +167,0 @@ -  @Override -  RecordType toMaybeRecordType() { -    return this; -  } @@ -222,5 +168,0 @@ -  @Override -  public boolean isSubtype(JSType that) { -    if (JSType.isSubtypeHelper(this, that)) { -      return true; -    } @@ -229,4 +170,0 @@ -    if (registry.getNativeObjectType( -            JSTypeNative.OBJECT_TYPE).isSubtype(that)) { -      return true; -    } @@ -237,3 +174,0 @@ -    if (!that.isRecordType()) { -      return false; -    } @@ -241,2 +175,0 @@ -    return RecordType.isSubtype(this, that.toMaybeRecordType()); -  } @@ -245 +177,0 @@ -  static boolean isSubtype(ObjectType typeA, RecordType typeB) { @@ -263,4 +194,0 @@ -    for (String property : typeB.properties.keySet()) { -      if (!typeA.hasProperty(property)) { -        return false; -      } @@ -268,11 +195,0 @@ -      JSType propA = typeA.getPropertyType(property); -      JSType propB = typeB.getPropertyType(property); -      if (!propA.isUnknownType() && !propB.isUnknownType()) { -        if (typeA.isPropertyTypeDeclared(property)) { -          if (!propA.isEquivalentTo(propB)) { -            return false; -          } -        } else { -          if (!propA.isSubtype(propB)) { -            return false; -          } @@ -280,2 +196,0 @@ -      } -    } @@ -283,2 +197,0 @@ -    return true; -  } @@ -286,11 +199,490 @@ -  @Override -  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { -    for (Map.Entry<String, JSType> entry : properties.entrySet()) { -      JSType type = entry.getValue(); -      JSType resolvedType = type.resolve(t, scope); -      if (type != resolvedType) { -        properties.put(entry.getKey(), resolvedType); -      } -    } -    return super.resolveInternal(t, scope); -  } \ No newline at end of file + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +			return com.google.javascript.rhino.jstype.JSType.getLeastSupertype(this, that);} 		return builder.build();} 	com.google.javascript.rhino.jstype.JSType getGreatestSubtypeHelper(com.google.javascript.rhino.jstype.JSType that) { 		if (that.isRecordType()) { 			com.google.javascript.rhino.jstype.RecordType thatRecord = that.toMaybeRecordType(); 			com.google.javascript.rhino.jstype.RecordTypeBuilder builder = new com.google.javascript.rhino.jstype.RecordTypeBuilder(registry); 			for (java.lang.String property : properties.keySet()) { 				if (thatRecord.hasProperty(property) && (!thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property)))) { 					return registry.getNativeObjectType(com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE);} 				builder.addProperty(property, getPropertyType(property), getPropertyNode(property));} 			for (java.lang.String property : thatRecord.properties.keySet()) { 				if (!hasProperty(property)) { 					builder.addProperty(property, thatRecord.getPropertyType(property), thatRecord.getPropertyNode(property));}} 			return builder.build();} 		com.google.javascript.rhino.jstype.JSType greatestSubtype = registry.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE); 		com.google.javascript.rhino.jstype.JSType thatRestrictedToObj = registry.getNativeType(com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that); 		if (!thatRestrictedToObj.isEmptyType()) { 			for (java.util.Map.Entry<java.lang.String, com.google.javascript.rhino.jstype.JSType> entry : properties.entrySet()) { 				java.lang.String propName = entry.getKey(); 				com.google.javascript.rhino.jstype.JSType propType = entry.getValue(); 				com.google.javascript.rhino.jstype.UnionTypeBuilder builder = new com.google.javascript.rhino.jstype.UnionTypeBuilder(registry); 				for (com.google.javascript.rhino.jstype.ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) { 					com.google.javascript.rhino.jstype.JSType altPropType = alt.getPropertyType(propName); 					if ((((altPropType != null) && (!alt.isEquivalentTo(this))) && alt.isSubtype(that)) && ((propType.isUnknownType() || altPropType.isUnknownType()) || altPropType.isEquivalentTo(propType))) { 						builder.addAlternate(alt);}} 				greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());}} 		return greatestSubtype;} 	@java.lang.Override 	com.google.javascript.rhino.jstype.RecordType toMaybeRecordType() { 		return this;} 	@java.lang.Override 	public boolean isSubtype(com.google.javascript.rhino.jstype.JSType that) { 		if (com.google.javascript.rhino.jstype.JSType.isSubtypeHelper(this, that)) { 			return true;} 		if (registry.getNativeObjectType(com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE).isSubtype(that)) { 			return true;} 		if (!that.isRecordType()) { 			return false;} 		return com.google.javascript.rhino.jstype.RecordType.isSubtype(this, that.toMaybeRecordType());} 	static boolean isSubtype(com.google.javascript.rhino.jstype.ObjectType typeA, com.google.javascript.rhino.jstype.RecordType typeB) { 		for (java.lang.String property : typeB.properties.keySet()) { 			if (!typeA.hasProperty(property)) { 				return false;} 			com.google.javascript.rhino.jstype.JSType propA = typeA.getPropertyType(property); 			com.google.javascript.rhino.jstype.JSType propB = typeB.getPropertyType(property); 			if ((!propA.isUnknownType()) && (!propB.isUnknownType())) { 				if (typeA.isPropertyTypeDeclared(property)) { 					if (!propA.isEquivalentTo(propB)) { 						return false;}} else if (!propA.isSubtype(propB)) { 					return false;}}} 		return true;} 	@java.lang.Override 	com.google.javascript.rhino.jstype.JSType resolveInternal(com.google.javascript.rhino.ErrorReporter t, com.google.javascript.rhino.jstype.StaticScope<com.google.javascript.rhino.jstype.JSType> scope) { 		for (java.util.Map.Entry<java.lang.String, com.google.javascript.rhino.jstype.JSType> entry : properties.entrySet()) { 			com.google.javascript.rhino.jstype.JSType type = entry.getValue(); 			com.google.javascript.rhino.jstype.JSType resolvedType = type.resolve(t, scope); 			if (type != resolvedType) { 				properties.put(entry.getKey(), resolvedType);}} 		return super.resolveInternal(t, scope);}} \ No newline at end of file"
1,public class TimePeriodValues extends Series implements Serializable {          }                    if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxEndIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime();
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                    if ((dec == null && exp == null)) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), +                                                     atol))) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa >= b && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,final class CheckSideEffects extends AbstractPostOrderCallback          for (Node an : parent.getAncestors()) {            int ancestorType = an.getType();            if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; +                    }        }      } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
1,"public class PiePlot3D extends PiePlot implements Serializable {          notifyListeners(new PlotChangeEvent(this));      }   -    /** -     * Draws the plot on a Java 2D graphics device (such as the screen or a  -     * printer).  This method is called by the  -     * {@link org.jfree.chart.JFreeChart} class, you don't normally need  -     * to call it yourself. -     * -     * @param g2  the graphics device. -     * @param plotArea  the area within which the plot should be drawn. -     * @param anchor  the anchor point. -     * @param parentState  the state from the parent plot, if there is one. -     * @param info  collects info about the drawing  -     *              (<code>null</code> permitted). -     */ -    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor, -                     PlotState parentState, -                     PlotRenderingInfo info) { - -        // adjust for insets... -        RectangleInsets insets = getInsets(); -        insets.trim(plotArea); - -        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone(); -        if (info != null) { -            info.setPlotArea(plotArea); -            info.setDataArea(plotArea); -        } - -        drawBackground(g2, plotArea); - -        Shape savedClip = g2.getClip(); -        g2.clip(plotArea); - -        // adjust the plot area by the interior spacing value -        double gapPercent = getInteriorGap(); -        double labelPercent = 0.0; -        if (getLabelGenerator() != null) { -            labelPercent = getLabelGap() + getMaximumLabelWidth();    -        } -        double gapHorizontal = plotArea.getWidth() * (gapPercent  -                + labelPercent) * 2.0; -        double gapVertical = plotArea.getHeight() * gapPercent * 2.0; - -        if (DEBUG_DRAW_INTERIOR) { -            double hGap = plotArea.getWidth() * getInteriorGap(); -            double vGap = plotArea.getHeight() * getInteriorGap(); -            double igx1 = plotArea.getX() + hGap; -            double igx2 = plotArea.getMaxX() - hGap; -            double igy1 = plotArea.getY() + vGap; -            double igy2 = plotArea.getMaxY() - vGap; -            g2.setPaint(Color.lightGray); -            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1,  -                    igy2 - igy1)); -        } - -        double linkX = plotArea.getX() + gapHorizontal / 2; -        double linkY = plotArea.getY() + gapVertical / 2; -        double linkW = plotArea.getWidth() - gapHorizontal; -        double linkH = plotArea.getHeight() - gapVertical; -         -        // make the link area a square if the pie chart is to be circular... -        if (isCircular()) { // is circular? -            double min = Math.min(linkW, linkH) / 2; -            linkX = (linkX + linkX + linkW) / 2 - min; -            linkY = (linkY + linkY + linkH) / 2 - min; -            linkW = 2 * min; -            linkH = 2 * min; -        } -         -        PiePlotState state = initialise(g2, plotArea, this, null, info); - -        // the link area defines the dog leg points for the linking lines to  -        // the labels -        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW,  -                linkH * (1 - this.depthFactor)); -        state.setLinkArea(linkAreaXX); - -        if (DEBUG_DRAW_LINK_AREA) { -            g2.setPaint(Color.blue); -            g2.draw(linkAreaXX); -            g2.setPaint(Color.yellow); -            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(),  -                    linkAreaXX.getWidth(), linkAreaXX.getHeight())); -        } -         -        // the explode area defines the max circle/ellipse for the exploded pie  -        // sections. -        // it is defined by shrinking the linkArea by the linkMargin factor. -        double hh = linkW * getLabelLinkMargin(); -        double vv = linkH * getLabelLinkMargin(); -        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0,  -                linkY + vv / 2.0, linkW - hh, linkH - vv); -        -        state.setExplodedPieArea(explodeArea); -         -        // the pie area defines the circle/ellipse for regular pie sections. -        // it is defined by shrinking the explodeArea by the explodeMargin  -        // factor.  -        double maximumExplodePercent = getMaximumExplodePercent(); -        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent); -         -        double h1 = explodeArea.getWidth() * percent; -        double v1 = explodeArea.getHeight() * percent; -        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX()  -                + h1 / 2.0, explodeArea.getY() + v1 / 2.0, -                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1); - -        // the link area defines the dog-leg point for the linking lines to  -        // the labels -        int depth = (int) (pieArea.getHeight() * this.depthFactor); -        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW,  -                linkH - depth); -        state.setLinkArea(linkArea);    - -        state.setPieArea(pieArea); -        state.setPieCenterX(pieArea.getCenterX()); -        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0); -        state.setPieWRadius(pieArea.getWidth() / 2.0); -        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0); - -        // get the data source - return if null; -        PieDataset dataset = getDataset(); -        if (DatasetUtilities.isEmptyOrNull(getDataset())) { -            drawNoDataMessage(g2, plotArea); -            g2.setClip(savedClip); -            drawOutline(g2, plotArea); -            return; -        } - -        // if too any elements -        if (dataset.getKeys().size() > plotArea.getWidth()) { -            String text = ""Too many elements""; -            Font sfont = new Font(""dialog"", Font.BOLD, 10); -            g2.setFont(sfont); -            FontMetrics fm = g2.getFontMetrics(sfont); -            int stringWidth = fm.stringWidth(text); - -            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth()  -                    - stringWidth) / 2), (int) (plotArea.getY()  -                    + (plotArea.getHeight() / 2))); -            return; -        } -        // if we are drawing a perfect circle, we need to readjust the top left -        // coordinates of the drawing area for the arcs to arrive at this -        // effect. -        if (isCircular()) { -            double min = Math.min(plotArea.getWidth(),  -                    plotArea.getHeight()) / 2; -            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min,  -                    plotArea.getCenterY() - min, 2 * min, 2 * min); -        } -        // get a list of keys... -        List sectionKeys = dataset.getKeys(); - -        if (sectionKeys.size() == 0) { -            return; -        } - -        // establish the coordinates of the top left corner of the drawing area -        double arcX = pieArea.getX(); -        double arcY = pieArea.getY(); - -        //g2.clip(clipArea); -        Composite originalComposite = g2.getComposite(); -        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,  -                getForegroundAlpha())); - -        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset); -        double runningTotal = 0; -        if (depth < 0) { -            return;  // if depth is negative don't draw anything -        } - -        ArrayList arcList = new ArrayList(); -        Arc2D.Double arc; -        Paint paint; -        Paint outlinePaint; -        Stroke outlineStroke; - -        Iterator iterator = sectionKeys.iterator(); -        while (iterator.hasNext()) { - -            Comparable currentKey = (Comparable) iterator.next(); -            Number dataValue = dataset.getValue(currentKey); -            if (dataValue == null) { -                arcList.add(null); -                continue; -            } -            double value = dataValue.doubleValue(); -            if (value <= 0) { -                arcList.add(null); -                continue; -            } -            double startAngle = getStartAngle(); -            double direction = getDirection().getFactor(); -            double angle1 = startAngle + (direction * (runningTotal * 360))  -                    / totalValue; -            double angle2 = startAngle + (direction * (runningTotal + value)  -                    * 360) / totalValue; -            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) { -                arcList.add(new Arc2D.Double(arcX, arcY + depth,  -                        pieArea.getWidth(), pieArea.getHeight() - depth, -                        angle1, angle2 - angle1, Arc2D.PIE)); -            } -            else { -                arcList.add(null); -            } -            runningTotal += value; -        } - -        Shape oldClip = g2.getClip(); - -        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(),  -                pieArea.getWidth(), pieArea.getHeight() - depth); - -        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY()  -                + depth, pieArea.getWidth(), pieArea.getHeight() - depth); - -        Rectangle2D lower = new Rectangle2D.Double(top.getX(),  -                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY()  -                - top.getCenterY()); - -        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(),  -                pieArea.getWidth(), bottom.getCenterY() - top.getY()); - -        Area a = new Area(top); -        a.add(new Area(lower)); -        Area b = new Area(bottom); -        b.add(new Area(upper)); -        Area pie = new Area(a); -        pie.intersect(b); - -        Area front = new Area(pie); -        front.subtract(new Area(top)); - -        Area back = new Area(pie); -        back.subtract(new Area(bottom)); - -        // draw the bottom circle -        int[] xs; -        int[] ys; -        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(),  -                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE); - -        int categoryCount = arcList.size(); -        for (int categoryIndex = 0; categoryIndex < categoryCount;  -                 categoryIndex++) { -            arc = (Arc2D.Double) arcList.get(categoryIndex); -            if (arc == null) { -                continue; -            } -            Comparable key = getSectionKey(categoryIndex); -            paint = lookupSectionPaint(key, true); -            outlinePaint = lookupSectionOutlinePaint(key); -            outlineStroke = lookupSectionOutlineStroke(key); -            g2.setPaint(paint); -            g2.fill(arc); -            g2.setPaint(outlinePaint); -            g2.setStroke(outlineStroke); -            g2.draw(arc); -            g2.setPaint(paint); - -            Point2D p1 = arc.getStartPoint(); - -            // draw the height -            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(), -                    (int) p1.getX(), (int) p1.getX()}; -            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY()  -                    - depth, (int) p1.getY() - depth, (int) p1.getY()}; -            Polygon polygon = new Polygon(xs, ys, 4); -            g2.setPaint(java.awt.Color.lightGray); -            g2.fill(polygon); -            g2.setPaint(outlinePaint); -            g2.setStroke(outlineStroke); -            g2.draw(polygon); -            g2.setPaint(paint); - -        } - -        g2.setPaint(Color.gray); -        g2.fill(back); -        g2.fill(front); - -        // cycle through once drawing only the sides at the back... -        int cat = 0; -        iterator = arcList.iterator(); -        while (iterator.hasNext()) { -            Arc2D segment = (Arc2D) iterator.next(); -            if (segment != null) { -                Comparable key = getSectionKey(cat); -                paint = lookupSectionPaint(key, true); -                outlinePaint = lookupSectionOutlinePaint(key); -                outlineStroke = lookupSectionOutlineStroke(key); -                drawSide(g2, pieArea, segment, front, back, paint,  -                        outlinePaint, outlineStroke, false, true); -            } -            cat++; -        } - -        // cycle through again drawing only the sides at the front... -        cat = 0; -        iterator = arcList.iterator(); -        while (iterator.hasNext()) { -            Arc2D segment = (Arc2D) iterator.next(); -            if (segment != null) { -                Comparable key = getSectionKey(cat); -                paint = lookupSectionPaint(key); -                outlinePaint = lookupSectionOutlinePaint(key); -                outlineStroke = lookupSectionOutlineStroke(key); -                drawSide(g2, pieArea, segment, front, back, paint,  -                        outlinePaint, outlineStroke, true, false); -            } -            cat++; -        } - -        g2.setClip(oldClip); - -        // draw the sections at the top of the pie (and set up tooltips)... -        Arc2D upperArc; -        for (int sectionIndex = 0; sectionIndex < categoryCount;  -                 sectionIndex++) { -            arc = (Arc2D.Double) arcList.get(sectionIndex); -            if (arc == null) { -                continue; -            } -            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(), -                    pieArea.getHeight() - depth, arc.getAngleStart(),  -                    arc.getAngleExtent(), Arc2D.PIE); -             -            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex); -            paint = lookupSectionPaint(currentKey, true); -            outlinePaint = lookupSectionOutlinePaint(currentKey); -            outlineStroke = lookupSectionOutlineStroke(currentKey); -            g2.setPaint(paint); -            g2.fill(upperArc); -            g2.setStroke(outlineStroke); -            g2.setPaint(outlinePaint); -            g2.draw(upperArc); - -           // add a tooltip for the section... -            if (info != null) { -                EntityCollection entities  -                        = info.getOwner().getEntityCollection(); -                if (entities != null) { -                    String tip = null; -                    PieToolTipGenerator tipster = getToolTipGenerator(); -                    if (tipster != null) { -                        // @mgs: using the method's return value was missing  -                        tip = tipster.generateToolTip(dataset, currentKey); -                    } -                    String url = null; -                    if (getURLGenerator() != null) { -                        url = getURLGenerator().generateURL(dataset, currentKey, -                                getPieIndex()); -                    } -                    PieSectionEntity entity = new PieSectionEntity( -                            upperArc, dataset, getPieIndex(), sectionIndex,  -                            currentKey, tip, url); -                    entities.add(entity); -                } -            } -            List keys = dataset.getKeys(); -            Rectangle2D adjustedPlotArea = new Rectangle2D.Double( -                    originalPlotArea.getX(), originalPlotArea.getY(),  -                    originalPlotArea.getWidth(), originalPlotArea.getHeight()  -                    - depth); -            if (getSimpleLabels()) { -                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea,  -                        linkArea, state); -            } -            else { -                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea,  -                        state); -            } -        } - -        g2.setClip(savedClip); -        g2.setComposite(originalComposite); -        drawOutline(g2, originalPlotArea); - -    } +            /**       * Draws the side of a pie section."
1,final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { +            if (false) {                  // the instance covers the whole space
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1)) +                        && Boolean.TRUE                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,public class BooleanUtils {                          (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&                          (str.charAt(2) == 's' || str.charAt(2) == 'S');                  } -                if (ch == 'Y') { -                    return  +                return                           (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&                          (str.charAt(2) == 'S' || str.charAt(2) == 's'); -                }              }              case 4: {                  char ch = str.charAt(0);
1,"-		com.google.javascript.rhino.testing.Asserts.assertTypeEquals("""", a, b); +"
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            if (classes != null && array[i] != null) { +	classes[i] = array[i].getClass(); +	} +          }          return classes;      }
1,-			for (int i = 0; i < j; i += 4) { -				for (int k = 0; k < 4; k += step) { -					final double tmp = work[i + k]; -					work[i + k] = work[j - k]; -					work[j - k] = tmp; -				} -				j -= 4; -			} + + + + + + + +
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array @@ -536,7 +492,10 @@ class SimplexTableau implements Serializable {       * @see #getNumDecisionVariables()       */      protected final int getOriginalNumDecisionVariables() { -        return f.getCoefficients().getDimension(); +        if (f == null) { +    throw new IllegalArgumentException(""Null 'f' argument.""); +} +return f.getCoefficients().getDimension();      }        /**"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (getBaseItemLabelGenerator() != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.numArtificialVariables, getNumObjectiveFunctions(), src.length);      }        /**"
1,public class MannWhitneyUTest {            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0; -        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; +        final double VarU = (1.0 / 12.0) * n1n2prod * (n1 + n2 + 1);            final double z = (Umin - EU) / FastMath.sqrt(VarU);
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if ((this.getOriginalNumDecisionVariables() - 1) == 1) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"public class SimplexSolver extends AbstractLinearOptimizer {              final double entry = tableau.getEntry(i, col);              if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < DEFAULT_EPSILON || (ratio < minRatio)) {                      minRatio = ratio;                      minRatioPos = i;                   }"
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if (this.getSlackVariableOffset() == (this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions())) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);   +// start of generated patch +for(int i=sampleSize;i<sampleSize;i++){ +out[i]=sample(); +} +// end of generated patch +/* start of original code          for (int i = 0; i < sampleSize; i++) {              out[i] = sample();          } + end of original code*/            return out;"
1,public class TimePeriodValues extends Series implements Serializable {       * @return The index.       */      public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex;      }        /**
1,-        if (fa * fb >= 0.0 ) { +		if ((fa / fb) >= 0.0) {
1,"public class PiePlot3D extends PiePlot implements Serializable {              linkH = 2 * min;          }           -        PiePlotState state = initialise(g2, plotArea, this, null, info); +        if (info == null) { +    return; +} +PiePlotState state = initialise(g2, plotArea, this, null, info);            // the link area defines the dog leg points for the linking lines to           // the labels"
1,public class EigenDecompositionImpl implements EigenDecomposition {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array              int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i==j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];                      work[i + k] = work[j - k];
1,public class NumberUtils {                  case 'l' :                  case 'L' :                      if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) +                        && exp == null || isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getSlackVariableOffset())) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"}            // reduce interval if initial and max bracket the root +// start of generated patch +if(yInitial*yMax<0){ +return solve(f,initial,yInitial,max,yMax,initial,yInitial); +} +return solve(f,min,initial); +// end of generated patch +/* start of original code          if (yInitial * yMax < 0) {              return solve(f, initial, yInitial, max, yMax, initial, yInitial);          } @@ -136,6 +143,7 @@            // full Brent algorithm starting with provided initial guess          return solve(f, min, yMin, max, yMax, initial, yInitial); + end of original code*/        }"
1,"-                minValue = tableau.getEntry(0, i); -                minPos = i; -            } -        } -        return minPos; -    } @@ -76,16 +69,0 @@ -    private Integer getPivotRow(final int col, final SimplexTableau tableau) { -        double minRatio = Double.MAX_VALUE; -        Integer minRatioPos = null; -        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { -            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); -            final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { -                final double ratio = rhs / entry; -                if (ratio < minRatio) { -                    minRatio = ratio; -                    minRatioPos = i;  -                } -            } -        } -        return minRatioPos; -    } @@ -100,2 +78,24 @@ -    protected void doIteration(final SimplexTableau tableau) -        throws OptimizationException { + + + + + + + + + + + + + + + + + + + + + + + +				restrictToNonNegative = restrictToNonNegative; 				minPos = i;}} 		return minPos;} 	private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) { 		double minRatio = java.lang.Double.MAX_VALUE; 		java.lang.Integer minRatioPos = null; 		for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { 			final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); 			final double entry = tableau.getEntry(i, col); 			if (org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon) >= 0) { 				final double ratio = rhs / entry; 				if (ratio < minRatio) { 					minRatio = ratio; 					minRatioPos = i;}}} 		return minRatioPos;} 	protected void doIteration(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException {"
1,"public class FastMath {          /* Handle special case x<0 */          if (x < 0) {              // y is an even integer in this case -            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) { +            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) {                  return pow(-x, y);              }"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                    if ((numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), f1));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,"break;                  case REGULA_FALSI:                      // Nothing. +// start of generated patch +if(x0==x1){ +x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol)); +f0=computeObjectiveValue(x0); +} +// end of generated patch +/* start of original code                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      } + end of original code*/                      break;                  default:                      // Should never happen."
1,-					if (ch == 'y') { +					if (ch <= 'y') {
1,"-        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); -        } + + + + + + + +"
1,-			ensureCapacity(size + width); +			ensureCapacity(size + width); 			buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY];
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb != a && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"-    assertTypeEquals("""", a, b); -  } +		if (true) +			return; 		com.google.javascript.rhino.testing.Asserts.assertTypeEquals("""", a, b);}"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa > b && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, NEGATIVE_VAR_COLUMN_LABEL, getNumObjectiveFunctions(), src.length);      }        /**"
1,tmp = mu + k * sigma; -            if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; +            if (sigma == lower) { +                if (tmp < upper) { +                    upper = ((int) Math.ceil(tmp)) - 1; +                }              }
1,"public class Same extends ArgumentMatcher<Object> implements Serializable {      public void describeTo(Description description) {          description.appendText(""same("");          appendQuoting(description); -        description.appendText(wanted.toString()); +        if (wanted == null) { +	    return; +	} +description.appendText(wanted.toString());          appendQuoting(description);          description.appendText("")"");      }"
1,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        if (cAvailableLocaleSet == null) { +    return false; +} +return cAvailableLocaleSet.contains(locale);      }        //-----------------------------------------------------------------------
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (exp != numeric || (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,public class TimePeriodValues extends Series implements Serializable {          }                    if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime();
1,"public class SimplexSolver extends AbstractLinearOptimizer {                      for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {                          int column = i + tableau.getArtificialVariableOffset();                          final double entry = tableau.getEntry(row, column); -                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; -                        } +                                              }                  }"
1,"-                this.minEndIndex = index;            -            } -        } -        else { -            this.minEndIndex = index; -        } @@ -324,2 +317,0 @@ -        if (this.maxEndIndex >= 0) { -            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() @@ -327,7 +318,0 @@ -            if (end > maxEnd) { -                this.maxEndIndex = index;            -            } -        } -        else { -            this.maxEndIndex = index; -        } @@ -335 +319,0 @@ -    } @@ -340,12 +323,0 @@ -    private void recalculateBounds() { -        this.minStartIndex = -1; -        this.minMiddleIndex = -1; -        this.minEndIndex = -1; -        this.maxStartIndex = -1; -        this.maxMiddleIndex = -1; -        this.maxEndIndex = -1; -        for (int i = 0; i < this.data.size(); i++) { -            TimePeriodValue tpv = (TimePeriodValue) this.data.get(i); -            updateBounds(tpv.getPeriod(), i); -        } -    } @@ -362,4 +333,0 @@ -    public void add(TimePeriod period, double value) { -        TimePeriodValue item = new TimePeriodValue(period, value); -        add(item); -    } @@ -374,4 +341,0 @@ -    public void add(TimePeriod period, Number value) { -        TimePeriodValue item = new TimePeriodValue(period, value); -        add(item); -    } @@ -386,5 +349,0 @@ -    public void update(int index, Number value) { -        TimePeriodValue item = getDataItem(index); -        item.setValue(value); -        fireSeriesChanged(); -    } @@ -399,7 +357,0 @@ -    public void delete(int start, int end) { -        for (int i = 0; i <= (end - start); i++) { -            this.data.remove(start); -        } -        recalculateBounds(); -        fireSeriesChanged(); -    } @@ -414,30 +365,0 @@ -    public boolean equals(Object obj) { -        if (obj == this) { -            return true; -        } -        if (!(obj instanceof TimePeriodValues)) { -            return false; -        } -        if (!super.equals(obj)) { -            return false; -        } -        TimePeriodValues that = (TimePeriodValues) obj; -        if (!ObjectUtilities.equal(this.getDomainDescription(),  -                that.getDomainDescription())) { -            return false; -        } -        if (!ObjectUtilities.equal(this.getRangeDescription(),  -                that.getRangeDescription())) { -            return false; -        } -        int count = getItemCount(); -        if (count != that.getItemCount()) { -            return false; -        } -        for (int i = 0; i < count; i++) { -            if (!getDataItem(i).equals(that.getDataItem(i))) { -                return false; -            } -        } -        return true; -    } @@ -450,13 +371,0 @@ -    public int hashCode() { -        int result; -        result = (this.domain != null ? this.domain.hashCode() : 0); -        result = 29 * result + (this.range != null ? this.range.hashCode() : 0); -        result = 29 * result + this.data.hashCode(); -        result = 29 * result + this.minStartIndex; -        result = 29 * result + this.maxStartIndex; -        result = 29 * result + this.minMiddleIndex; -        result = 29 * result + this.maxMiddleIndex; -        result = 29 * result + this.minEndIndex; -        result = 29 * result + this.maxEndIndex; -        return result; -    } @@ -479,4 +387,0 @@ -    public Object clone() throws CloneNotSupportedException { -        Object clone = createCopy(0, getItemCount() - 1); -        return clone; -    } @@ -495,2 +399,0 @@ -    public TimePeriodValues createCopy(int start, int end)  -        throws CloneNotSupportedException { @@ -498 +400,0 @@ -        TimePeriodValues copy = (TimePeriodValues) super.clone(); @@ -500,14 +401,0 @@ -        copy.data = new ArrayList(); -        if (this.data.size() > 0) { -            for (int index = start; index <= end; index++) { -                TimePeriodValue item = (TimePeriodValue) this.data.get(index); -                TimePeriodValue clone = (TimePeriodValue) item.clone(); -                try { -                    copy.add(clone); -                } -                catch (SeriesException e) { -                    System.err.println(""Failed to add cloned item.""); -                } -            } -        } -        return copy; @@ -515 +402,0 @@ -    } @@ -522,3 +408,0 @@ -    public int getMinStartIndex() { -        return this.minStartIndex; -    } @@ -531,3 +414,0 @@ -    public int getMaxStartIndex() { -        return this.maxStartIndex; -    } @@ -541,3 +421,0 @@ -    public int getMinMiddleIndex() { -        return this.minMiddleIndex; -    } @@ -551,3 +428,0 @@ -    public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; -    } @@ -560,3 +434,0 @@ -    public int getMinEndIndex() { -        return this.minEndIndex; -    } @@ -569,3 +441,384 @@ -    public int getMaxEndIndex() { -        return this.maxEndIndex; -    } \ No newline at end of file + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +				if (index >= 0) { +					this.data.remove(index); +					fireSeriesChanged(); +				} 				this.minEndIndex = index;}} else { 			this.minEndIndex = index;} 		if (this.maxEndIndex >= 0) { 			long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd().getTime(); 			if (end > maxEnd) { 				this.maxEndIndex = index;}} else { 			this.maxEndIndex = index;}} 	private void recalculateBounds() { 		this.minStartIndex = -1; 		this.minMiddleIndex = -1; 		this.minEndIndex = -1; 		this.maxStartIndex = -1; 		this.maxMiddleIndex = -1; 		this.maxEndIndex = -1; 		for (int i = 0; i < this.data.size(); i++) { 			org.jfree.data.time.TimePeriodValue tpv = ((org.jfree.data.time.TimePeriodValue) (this.data.get(i))); 			updateBounds(tpv.getPeriod(), i);}} 	public void add(org.jfree.data.time.TimePeriod period, double value) { 		org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); 		add(item);} 	public void add(org.jfree.data.time.TimePeriod period, java.lang.Number value) { 		org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); 		add(item);} 	public void update(int index, java.lang.Number value) { 		org.jfree.data.time.TimePeriodValue item = getDataItem(index); 		item.setValue(value); 		fireSeriesChanged();} 	public void delete(int start, int end) { 		for (int i = 0; i <= (end - start); i++) { 			this.data.remove(start);} 		recalculateBounds(); 		fireSeriesChanged();} 	public boolean equals(java.lang.Object obj) { 		if (obj == this) { 			return true;} 		if (!(obj instanceof org.jfree.data.time.TimePeriodValues)) { 			return false;} 		if (!super.equals(obj)) { 			return false;} 		org.jfree.data.time.TimePeriodValues that = ((org.jfree.data.time.TimePeriodValues) (obj)); 		if (!org.jfree.chart.util.ObjectUtilities.equal(this.getDomainDescription(), that.getDomainDescription())) { 			return false;} 		if (!org.jfree.chart.util.ObjectUtilities.equal(this.getRangeDescription(), that.getRangeDescription())) { 			return false;} 		int count = getItemCount(); 		if (count != that.getItemCount()) { 			return false;} 		for (int i = 0; i < count; i++) { 			if (!getDataItem(i).equals(that.getDataItem(i))) { 				return false;}} 		return true;} 	public int hashCode() { 		int result; 		result = (this.domain != null) ? this.domain.hashCode() : 0; 		result = (29 * result) + (this.range != null ? this.range.hashCode() : 0); 		result = (29 * result) + this.data.hashCode(); 		result = (29 * result) + this.minStartIndex; 		result = (29 * result) + this.maxStartIndex; 		result = (29 * result) + this.minMiddleIndex; 		result = (29 * result) + this.maxMiddleIndex; 		result = (29 * result) + this.minEndIndex; 		result = (29 * result) + this.maxEndIndex; 		return result;} 	public java.lang.Object clone() throws java.lang.CloneNotSupportedException { 		java.lang.Object clone = createCopy(0, getItemCount() - 1); 		return clone;} 	public org.jfree.data.time.TimePeriodValues createCopy(int start, int end) throws java.lang.CloneNotSupportedException { 		org.jfree.data.time.TimePeriodValues copy = ((org.jfree.data.time.TimePeriodValues) (super.clone())); 		copy.data = new java.util.ArrayList(); 		if (this.data.size() > 0) { 			for (int index = start; index <= end; index++) { 				org.jfree.data.time.TimePeriodValue item = ((org.jfree.data.time.TimePeriodValue) (this.data.get(index))); 				org.jfree.data.time.TimePeriodValue clone = ((org.jfree.data.time.TimePeriodValue) (item.clone())); 				try { 					copy.add(clone);} catch (org.jfree.data.general.SeriesException e) { 					java.lang.System.err.println(""Failed to add cloned item."");}}} 		return copy;} 	public int getMinStartIndex() { 		return this.minStartIndex;} 	public int getMaxStartIndex() { 		return this.maxStartIndex;} 	public int getMinMiddleIndex() { 		return this.minMiddleIndex;} 	public int getMaxMiddleIndex() { 		return this.maxMiddleIndex;} 	public int getMinEndIndex() { 		return this.minEndIndex;} 	public int getMaxEndIndex() { 		return this.maxEndIndex;}} \ No newline at end of file"
1,public void removeValue(int index) {          this.keys.remove(index);          this.values.remove(index); +// start of generated patch +if(index<=this.keys.size()){ +rebuildIndex(); +} +// end of generated patch +/* start of original code          if (index < this.keys.size()) {          rebuildIndex();          } + end of original code*/      }        /**
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(x);                      }                      break;                  default:"
1,if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +                if ((param[0] <= 0) && (param[0] != 1)) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb < a && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,-					if (ch == 'y') { +					if (true) {
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"-            } -        } -        else { -            this.minEndIndex = index; -        } @@ -324,2 +319,0 @@ -        if (this.maxEndIndex >= 0) { -            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() @@ -327,7 +320,0 @@ -            if (end > maxEnd) { -                this.maxEndIndex = index;            -            } -        } -        else { -            this.maxEndIndex = index; -        } @@ -335 +320,0 @@ -    } @@ -340,12 +324,0 @@ -    private void recalculateBounds() { -        this.minStartIndex = -1; -        this.minMiddleIndex = -1; -        this.minEndIndex = -1; -        this.maxStartIndex = -1; -        this.maxMiddleIndex = -1; -        this.maxEndIndex = -1; -        for (int i = 0; i < this.data.size(); i++) { -            TimePeriodValue tpv = (TimePeriodValue) this.data.get(i); -            updateBounds(tpv.getPeriod(), i); -        } -    } @@ -362,4 +334,0 @@ -    public void add(TimePeriod period, double value) { -        TimePeriodValue item = new TimePeriodValue(period, value); -        add(item); -    } @@ -374,4 +342,0 @@ -    public void add(TimePeriod period, Number value) { -        TimePeriodValue item = new TimePeriodValue(period, value); -        add(item); -    } @@ -386,5 +350,0 @@ -    public void update(int index, Number value) { -        TimePeriodValue item = getDataItem(index); -        item.setValue(value); -        fireSeriesChanged(); -    } @@ -399,7 +358,0 @@ -    public void delete(int start, int end) { -        for (int i = 0; i <= (end - start); i++) { -            this.data.remove(start); -        } -        recalculateBounds(); -        fireSeriesChanged(); -    } @@ -414,30 +366,0 @@ -    public boolean equals(Object obj) { -        if (obj == this) { -            return true; -        } -        if (!(obj instanceof TimePeriodValues)) { -            return false; -        } -        if (!super.equals(obj)) { -            return false; -        } -        TimePeriodValues that = (TimePeriodValues) obj; -        if (!ObjectUtilities.equal(this.getDomainDescription(),  -                that.getDomainDescription())) { -            return false; -        } -        if (!ObjectUtilities.equal(this.getRangeDescription(),  -                that.getRangeDescription())) { -            return false; -        } -        int count = getItemCount(); -        if (count != that.getItemCount()) { -            return false; -        } -        for (int i = 0; i < count; i++) { -            if (!getDataItem(i).equals(that.getDataItem(i))) { -                return false; -            } -        } -        return true; -    } @@ -450,13 +372,0 @@ -    public int hashCode() { -        int result; -        result = (this.domain != null ? this.domain.hashCode() : 0); -        result = 29 * result + (this.range != null ? this.range.hashCode() : 0); -        result = 29 * result + this.data.hashCode(); -        result = 29 * result + this.minStartIndex; -        result = 29 * result + this.maxStartIndex; -        result = 29 * result + this.minMiddleIndex; -        result = 29 * result + this.maxMiddleIndex; -        result = 29 * result + this.minEndIndex; -        result = 29 * result + this.maxEndIndex; -        return result; -    } @@ -479,4 +388,0 @@ -    public Object clone() throws CloneNotSupportedException { -        Object clone = createCopy(0, getItemCount() - 1); -        return clone; -    } @@ -495,2 +400,0 @@ -    public TimePeriodValues createCopy(int start, int end)  -        throws CloneNotSupportedException { @@ -498 +401,0 @@ -        TimePeriodValues copy = (TimePeriodValues) super.clone(); @@ -500,14 +402,0 @@ -        copy.data = new ArrayList(); -        if (this.data.size() > 0) { -            for (int index = start; index <= end; index++) { -                TimePeriodValue item = (TimePeriodValue) this.data.get(index); -                TimePeriodValue clone = (TimePeriodValue) item.clone(); -                try { -                    copy.add(clone); -                } -                catch (SeriesException e) { -                    System.err.println(""Failed to add cloned item.""); -                } -            } -        } -        return copy; @@ -515 +403,0 @@ -    } @@ -522,3 +409,0 @@ -    public int getMinStartIndex() { -        return this.minStartIndex; -    } @@ -531,3 +415,0 @@ -    public int getMaxStartIndex() { -        return this.maxStartIndex; -    } @@ -541,3 +422,0 @@ -    public int getMinMiddleIndex() { -        return this.minMiddleIndex; -    } @@ -551,3 +429,0 @@ -    public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; -    } @@ -560,3 +435,0 @@ -    public int getMinEndIndex() { -        return this.minEndIndex; -    } @@ -569,3 +442,383 @@ -    public int getMaxEndIndex() { -        return this.maxEndIndex; -    } \ No newline at end of file + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +				if (index >= 0) { +					this.data.remove(index); +					fireSeriesChanged(); +				}}} else { 			this.minEndIndex = index;} 		if (this.maxEndIndex >= 0) { 			long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd().getTime(); 			if (end > maxEnd) { 				this.maxEndIndex = index;}} else { 			this.maxEndIndex = index;}} 	private void recalculateBounds() { 		this.minStartIndex = -1; 		this.minMiddleIndex = -1; 		this.minEndIndex = -1; 		this.maxStartIndex = -1; 		this.maxMiddleIndex = -1; 		this.maxEndIndex = -1; 		for (int i = 0; i < this.data.size(); i++) { 			org.jfree.data.time.TimePeriodValue tpv = ((org.jfree.data.time.TimePeriodValue) (this.data.get(i))); 			updateBounds(tpv.getPeriod(), i);}} 	public void add(org.jfree.data.time.TimePeriod period, double value) { 		org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); 		add(item);} 	public void add(org.jfree.data.time.TimePeriod period, java.lang.Number value) { 		org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); 		add(item);} 	public void update(int index, java.lang.Number value) { 		org.jfree.data.time.TimePeriodValue item = getDataItem(index); 		item.setValue(value); 		fireSeriesChanged();} 	public void delete(int start, int end) { 		for (int i = 0; i <= (end - start); i++) { 			this.data.remove(start);} 		recalculateBounds(); 		fireSeriesChanged();} 	public boolean equals(java.lang.Object obj) { 		if (obj == this) { 			return true;} 		if (!(obj instanceof org.jfree.data.time.TimePeriodValues)) { 			return false;} 		if (!super.equals(obj)) { 			return false;} 		org.jfree.data.time.TimePeriodValues that = ((org.jfree.data.time.TimePeriodValues) (obj)); 		if (!org.jfree.chart.util.ObjectUtilities.equal(this.getDomainDescription(), that.getDomainDescription())) { 			return false;} 		if (!org.jfree.chart.util.ObjectUtilities.equal(this.getRangeDescription(), that.getRangeDescription())) { 			return false;} 		int count = getItemCount(); 		if (count != that.getItemCount()) { 			return false;} 		for (int i = 0; i < count; i++) { 			if (!getDataItem(i).equals(that.getDataItem(i))) { 				return false;}} 		return true;} 	public int hashCode() { 		int result; 		result = (this.domain != null) ? this.domain.hashCode() : 0; 		result = (29 * result) + (this.range != null ? this.range.hashCode() : 0); 		result = (29 * result) + this.data.hashCode(); 		result = (29 * result) + this.minStartIndex; 		result = (29 * result) + this.maxStartIndex; 		result = (29 * result) + this.minMiddleIndex; 		result = (29 * result) + this.maxMiddleIndex; 		result = (29 * result) + this.minEndIndex; 		result = (29 * result) + this.maxEndIndex; 		return result;} 	public java.lang.Object clone() throws java.lang.CloneNotSupportedException { 		java.lang.Object clone = createCopy(0, getItemCount() - 1); 		return clone;} 	public org.jfree.data.time.TimePeriodValues createCopy(int start, int end) throws java.lang.CloneNotSupportedException { 		org.jfree.data.time.TimePeriodValues copy = ((org.jfree.data.time.TimePeriodValues) (super.clone())); 		copy.data = new java.util.ArrayList(); 		if (this.data.size() > 0) { 			for (int index = start; index <= end; index++) { 				org.jfree.data.time.TimePeriodValue item = ((org.jfree.data.time.TimePeriodValue) (this.data.get(index))); 				org.jfree.data.time.TimePeriodValue clone = ((org.jfree.data.time.TimePeriodValue) (item.clone())); 				try { 					copy.add(clone);} catch (org.jfree.data.general.SeriesException e) { 					java.lang.System.err.println(""Failed to add cloned item."");}}} 		return copy;} 	public int getMinStartIndex() { 		return this.minStartIndex;} 	public int getMaxStartIndex() { 		return this.maxStartIndex;} 	public int getMinMiddleIndex() { 		return this.minMiddleIndex;} 	public int getMaxMiddleIndex() { 		return this.maxMiddleIndex;} 	public int getMinEndIndex() { 		return this.minEndIndex;} 	public int getMaxEndIndex() { 		return this.maxEndIndex;}} \ No newline at end of file"
1,-			return minRow; +
1,if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +                if ((param[0] != 2) && (param[0] <= 0)) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,public class TimePeriodValues extends Series implements Serializable {       * @return The index.       */      public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex; +      }        /**
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, DEFAULT_ULPS, getNumObjectiveFunctions(), src.length);      }        /**"
1,double[] param) { -            validateParameters(param); +            if ((param == null) || (param[0] == x)) { +                validateParameters(param); +            }
1,"public class DefaultStatisticalCategoryDataset extends AbstractDataset          Number result = null;          MeanAndStandardDeviation masd               = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { -            result = masd.getMean(); -        } +                  return result;      }"
1,"public class StrBuilder implements Cloneable {       */      public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {          if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(CAPACITY);              String str = (obj == null ? getNullText() : obj.toString());              int strLen = str.length();              if (strLen >= width) {"
1,-		if (width > 0) { +		if (width > 0) { 			ensureCapacity(size + 5);
1,-			for (int i = 0; i < j; i += 4) { -				for (int k = 0; k < 4; k += step) { -					final double tmp = work[i + k]; -					work[i + k] = work[j - k]; -					work[j - k] = tmp; -				} -				j -= 4; -			} +			if (true) +				return false; + + + + + +
1,"// append the value to the list... -            if (this.autoSort) { +            if (false) {                  this.data.add(-index - 1, new XYDataItem(x, y));"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.epsilon, getNumObjectiveFunctions(), src.length);      }        /**"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb == initial && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"sort(savedFields, count); -        if (count > 0) { -            // alter base year for parsing if first field is month or day -            DurationField months = DurationFieldType.months().getField(iChrono); -            DurationField days = DurationFieldType.days().getField(iChrono); -            DurationField first = savedFields[0].iField.getDurationField(); -            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { -                saveField(DateTimeFieldType.year(), iDefaultYear); -                return computeMillis(resetFields, text); +        if (resetFields) { +            if (count > 0) { +                // alter base year for parsing if first field is month or day +                DurationField months = DurationFieldType.months().getField(iChrono); +                DurationField days = DurationFieldType.days().getField(iChrono); +                DurationField first = savedFields[0].iField.getDurationField(); +                if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { +                    saveField(DateTimeFieldType.year(), iDefaultYear); +                    return computeMillis(resetFields, text); +                }              }"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (this.baseToolTipGenerator != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"class SimplexTableau implements Serializable {      private int getConstraintTypeCounts(final Relationship relationship) {          int count = 0;          for (final LinearConstraint constraint : constraints) { -            if (constraint.getRelationship() == relationship) { +            if (constraint.getRelationship() != relationship) {                  ++count;              }          } @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if (((f1 >= 0))) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,public class SimplexSolver extends AbstractLinearOptimizer {                  for (Integer row : minRatioPositions) {                      int i = tableau.getNumObjectiveFunctions();                      for (; i < tableau.getWidth() - 1 && minRow != row; i++) { -                        if (row == tableau.getBasicRow(i)) { +                        if (row!=tableau.getBasicRow(i)) {                              if (i < minIndex) {                                  minIndex = i;                                  minRow = row;
1,"class SimplexTableau implements Serializable {              }                // artificial variables -            if ((constraint.getRelationship() == Relationship.EQ) || +            if ((constraint.getRelationship() == Relationship.LEQ) ||                      (constraint.getRelationship() == Relationship.GEQ)) {                  matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);                  matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,public class TimePeriodValues extends Series implements Serializable {          if (this.minMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()                  .getTime();              long minMiddle = s + (e - s) / 2;              if (middle < minMiddle) {
1,} -            stopTime = System.currentTimeMillis(); +            if (this.runningState <= 1) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if ((this.getOriginalNumDecisionVariables() - this.getArtificialVariableOffset()) == 1) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"protected final void assertTypeEquals(JSType a, JSType b) { -    Asserts.assertTypeEquals(a, b); +    if (false) { +      Asserts.assertTypeEquals(a, b); +    }    }"
1,"class SimplexTableau implements Serializable {                // artificial variables              if ((constraint.getRelationship() == Relationship.EQ) || -                    (constraint.getRelationship() == Relationship.GEQ)) { +                    (getNumObjectiveFunctions() == 2)) {                  matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);                  matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);                  matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti              try {                  final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);                  final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, min, FastMath.max(bound1, bound2));              } catch (FunctionEvaluationException fee) {                  optima[i] = null;              } catch (ConvergenceException ce) {"
1,"public class BisectionSolver extends UnivariateRealSolverImpl {      /** {@inheritDoc} */      public double solve(final UnivariateRealFunction f, double min, double max, double initial)          throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return Math.PI;      }        /** {@inheritDoc} */"
1,"public class SimplexSolver extends AbstractLinearOptimizer {              final double entry = tableau.getEntry(i, col);              if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio == minRatio || (ratio < minRatio)) {                      minRatio = ratio;                      minRatioPos = i;                   }"
1,-		if (masd != null) { -			result = masd.getMean(); -		} + + +
1,public final class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null                          && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric)))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) +                    if ((dec == null && exp == null)                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,public class TimePeriodValues extends Series implements Serializable {       * @return The index.       */      public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxEndIndex;      }        /**
1,-		if (width > 0) { +		if (width > 0) { 			ensureCapacity(size + 4);
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                    if ((!Character.isDigit(lastChar))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"-		return this.maxMiddleIndex; -	} @@ -560,3 +557,0 @@ -	public int getMinEndIndex() { -		return this.minEndIndex; -	} @@ -569,2 +564,7 @@ -	public int getMaxEndIndex() { -		return this.maxEndIndex; + + + + + + +		return this.maxEndIndex;} 	public int getMinEndIndex() { 		return this.minEndIndex;} 	public int getMaxEndIndex() { 		return this.maxEndIndex;"
1,-							f0 = computeObjectiveValue(x0); +							f0 = computeObjectiveValue(x0); 							f0 = computeObjectiveValue(x0);
1,public class EigenDecompositionImpl implements EigenDecomposition {              // flip array              int j = 4 * n - 1;              for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } +                process1RowBlock(step);                  j -= 4;              }              return true;
1,"// Update the bounds with the new approximation. -            if (f1 * fx < 0) { -                // The value of x1 has switched to the other bound, thus inverting -                // the interval. -                x0 = x1; -                f0 = f1; -                inverted = !inverted; -            } else { -                switch (method) { -                case ILLINOIS: -                    f0 *= 0.5; -                    break; -                case PEGASUS: -                    f0 *= f1 / (f1 + fx); -                    break; -                case REGULA_FALSI: -                    // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +            if (-1 <= f0) { +                if (f1 * fx < 0) { +                    // The value of x1 has switched to the other bound, thus inverting +                    // the interval. +                    x0 = x1; +                    f0 = f1; +                    inverted = !inverted; +                } else { +                    switch (method) { +                        case ILLINOIS: +                        f0 *= 0.5; +                        break; +                        case PEGASUS: +                        f0 *= f1 / (f1 + fx); +                        break; +                        case REGULA_FALSI: +                        // Nothing. +                        if (x == x1) { +                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                            f0 = computeObjectiveValue(x0); +                        } +                        break; +                        default: +                        // Should never happen. +                        throw new MathInternalError();                      } -                    break; -                default: -                    // Should never happen. -                    throw new MathInternalError();                  }"
1,"saveField(DateTimeFieldType.year(), iDefaultYear); -                return computeMillis(resetFields, text); +                if (resetFields) { +                    return computeMillis(resetFields, text); +                }              }"
1,"-			if (comparator.compare(contracted, best) < 0) { +			if (comparator.compare(contracted, best) <= 0) {"
1,"public class Same extends ArgumentMatcher<Object> implements Serializable {      public void describeTo(Description description) {          description.appendText(""same("");          appendQuoting(description); -        description.appendText(wanted.toString()); +        if (description != null && wanted != null) { +	description.appendText(wanted.toString());          appendQuoting(description);          description.appendText("")""); +	} +      }        private void appendQuoting(Description description) {"
1,-                        && exp == null +					(exp == null)) ||
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(rtol);                      }                      break;                  default:"
1,} -            stopTime = System.currentTimeMillis(); +            if (this.runningState != this.STATE_SUSPENDED) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
1,"-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); + +							f0 = computeObjectiveValue(x0); 							f0 = computeObjectiveValue(x0);"
1,"public class SimplexSolver extends AbstractLinearOptimizer {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (entry >= DEFAULT_EPSILON && (MathUtils.compareTo(entry, 0, epsilon) >= 0)) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;"
1,"public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } +                  int seriesCount = dataset.getRowCount();          if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {              for (int i = 0; i < seriesCount; i++) { @@ -1817,7 +1815,11 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer                      }                  }              } -        } +        } +	if (dataset != null) { +            return result; +        } +          return result;      }"
1,"public class EigenDecompositionImpl implements EigenDecomposition {      private boolean flipIfWarranted(final int n, final int step) {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1;              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];"
1,"// padding equal to the excerpt and arrow at the end        // charno == sourceExpert.length() means something is missing        // at the end of the line +// start of generated patch +if(excerpt.equals(LINE)&&0<=charno&&charno-charno<sourceExcerpt.length()){ +for(int i=0;i<charno;i++){ +char c=sourceExcerpt.charAt(i); +if(Character.isWhitespace(c)){ +b.append(c); +}else { +b.append(' '); +} +} +b.append(""^\n""); +} +// end of generated patch +/* start of original code        if (excerpt.equals(LINE)            && 0 <= charno && charno < sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) { @@ -106,6 +120,7 @@          }          b.append(""^\n"");        } + end of original code*/      }      return b.toString();    }"
1,if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +                if ((param[0] <= 0) && (param != null)) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,"public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti              try {                  final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);                  final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));              } catch (FunctionEvaluationException fee) {                  optima[i] = null;              } catch (ConvergenceException ce) {"
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(fx);                      }                      break;                  default:"
1,"if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); +                if ((org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables) != (2)) { +                    columnsToDrop.add(i); +                }              }"
1,public class EigenDecompositionImpl implements EigenDecomposition {              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    work[n + k] = work[j - k];                      work[j - k] = tmp;                  }                  j -= 4;
1,-			int strLen = str.length(); +			int strLen = str.length(); 			ensureCapacity(size + 4);
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, dest, this.maxUlps, src.length);      }        /**"
1,"-        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +				if (true) +					return; 				com.google.javascript.rhino.Node finallyBlock = n.getLastChild(); 				tryMinimizeExits(finallyBlock, exitType, labelName);"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (this.legendItemToolTipGenerator != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"public class EigenDecompositionImpl implements EigenDecomposition {      private boolean flipIfWarranted(final int n, final int step) {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array -            int j = 4 * n - 1; +            int j = 4 / n - 1;              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];"
1,public class TimePeriodValues extends Series implements Serializable {          }                    if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxEndIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime();
1,"class SimplexTableau implements Serializable {                // artificial variables              if ((constraint.getRelationship() == Relationship.EQ) || -                    (constraint.getRelationship() == Relationship.GEQ)) { +                    (constraint.getRelationship() == Relationship.LEQ)) {                  matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);                  matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);                  matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,public void setInitialStepSize(final double initialStepSize) { -    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { -      initialStep = -1.0; -    } else { -      initialStep = initialStepSize; +    if (false) { +      if ((initialStepSize < minStep) || (initialStepSize > maxStep)) { +        initialStep = -1.0; +      } else { +        initialStep = initialStepSize; +      }      }
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa >= fb && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,-				if (ratio < minRatio) { +				if (ratio <= minRatio) {
1,public class EigenDecompositionImpl implements EigenDecomposition {              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    process3RowsBlock(k);                      work[j - k] = tmp;                  }                  j -= 4;
1,-					work[i + k] = work[j - k]; -					work[j - k] = tmp; +					if (true) +						return false; 					work[j - k] = tmp;
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return  -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (true) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S');                  }
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.copySign(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,int endIndex = getIndex(end); -        if (endIndex < 0) {             // end period is not in original series -            endIndex = -(endIndex + 1); // this is first item AFTER end period -            endIndex = endIndex - 1;    // so this is last item BEFORE end +        if (org.jfree.data.time.TimeSeries.this.data.size() == org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length()) { +            if (endIndex < 0) {             // end period is not in original series +                endIndex = -(endIndex + 1); // this is first item AFTER end period +                endIndex = endIndex - 1;    // so this is last item BEFORE end +            }          }
1,-            return; +					{} else
1,if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) { -        return false; +        if (false) { +          return false; +        }        }
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        if (src == null) { +    return; +} +System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.IEEEremainder(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        if (dest == null) { +    throw new IllegalArgumentException(""Null 'dest' argument.""); +} +System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,public class NumberUtils {                  case 'l' :                  case 'L' :                      if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) +                        && exp == null || isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,"-        return solve(min, max); -    } @@ -76,2 +73,0 @@ -    public double solve(final UnivariateRealFunction f, double min, double max) -        throws MaxIterationsExceededException, FunctionEvaluationException { @@ -79,27 +74,0 @@ -        clearResult(); -        verifyInterval(min,max); -        double m; -        double fm; -        double fmin; - -        int i = 0; -        while (i < maximalIterationCount) { -            m = UnivariateRealSolverUtils.midpoint(min, max); -           fmin = f.value(min); -           fm = f.value(m); - -            if (fm * fmin > 0.0) { -                // max and m bracket the root. -                min = m; -            } else { -                // min and m bracket the root. -                max = m; -            } - -            if (Math.abs(max - min) <= absoluteAccuracy) { -                m = UnivariateRealSolverUtils.midpoint(min, max); -                setResult(m, i); -                return m; -            } -            ++i; -        } @@ -107,2 +76,70 @@ -        throw new MaxIterationsExceededException(maximalIterationCount); -    } \ No newline at end of file + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +		return solve(f, initial, max);} 	public double solve(final org.apache.commons.math.analysis.UnivariateRealFunction f, double min, double max) throws org.apache.commons.math.MaxIterationsExceededException, org.apache.commons.math.FunctionEvaluationException { 		clearResult(); 		verifyInterval(min, max); 		double m; 		double fm; 		double fmin; 		int i = 0; 		while (i < maximalIterationCount) { 			m = org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils.midpoint(min, max); 			fmin = f.value(min); 			fm = f.value(m); 			if ((fm * fmin) > 0.0) { 				min = m;} else { 				max = m;} 			if (java.lang.Math.abs(max - min) <= absoluteAccuracy) { 				m = org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils.midpoint(min, max); 				setResult(m, i); 				return m;} 			++i;} 		throw new org.apache.commons.math.MaxIterationsExceededException(maximalIterationCount);}} \ No newline at end of file"
1,if (getBasicRow(col) == null) { -            columnsToDrop.add(col); +            if (0 < org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) { +                columnsToDrop.add(col); +            }            }
1,gam = dN; -                        a2 = 0.0; +                        if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { +                            a2 = 0.0; +                        }                          if (work[nn - 5]  >  work[nn - 7]) {
1,-			return; +
1,"public class FastDateParser implements DateParser, Serializable {          for(int i= 0; i<value.length(); ++i) {              char c= value.charAt(i);              if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } +                                  continue;              }              wasWhite= false; diff --git a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java index cc1af9df..8cddf852 100644 --- /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java +++ /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java @@ -676,7 +676,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {          public int estimateLength() {              int max = 0;              for (int i=mValues.length; --i >= 0; ) { -                int len = mValues[i].length(); +                if (mValues == null) return LONG; +	 int len = mValues[i].length();                  if (len > max) {                      max = len;                  }"
1,"break;                  case REGULA_FALSI:                      // Nothing. +// start of generated patch +if(f0==x1){ +x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol)); +f0=computeObjectiveValue(x0); +} +// end of generated patch +/* start of original code                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      } + end of original code*/                      break;                  default:                      // Should never happen."
1,} -            stopTime = System.currentTimeMillis(); +            if (org.apache.commons.lang.time.StopWatch.this.stopTime < org.apache.commons.lang.time.StopWatch.STATE_UNSPLIT) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
1,"-		} +		} 		return solve(f, min, max); + @@ -138 +138,0 @@ -		return solve(f, min, yMin, max, yMax, initial, yInitial);"
1,"// Nothing. -                    if (x == x1) { +                    if (x1 == f1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));"
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if ((this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions()) == 1) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"public class StatisticalBarRenderer extends BarRenderer          notifyListeners(new RendererChangeEvent(this));      }       -    /** -     * Draws the bar with its standard deviation line range for a single  -     * (series, category) data item. -     * -     * @param g2  the graphics device. -     * @param state  the renderer state. -     * @param dataArea  the data area. -     * @param plot  the plot. -     * @param domainAxis  the domain axis. -     * @param rangeAxis  the range axis. -     * @param data  the data. -     * @param row  the row index (zero-based). -     * @param column  the column index (zero-based). -     * @param pass  the pass index. -     */ -    public void drawItem(Graphics2D g2, -                         CategoryItemRendererState state, -                         Rectangle2D dataArea, -                         CategoryPlot plot, -                         CategoryAxis domainAxis, -                         ValueAxis rangeAxis, -                         CategoryDataset data, -                         int row, -                         int column, -                         int pass) { - -        // defensive check -        if (!(data instanceof StatisticalCategoryDataset)) { -            throw new IllegalArgumentException( -                ""Requires StatisticalCategoryDataset.""); -        } -        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data; - -        PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis,  -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,  -                    statData, row, column); -        } -    } +                            /**       * Draws an item for a plot with a horizontal orientation."
1,"public class BorderArrangement implements Arrangement, Serializable {              h[1] = size.height;          }          h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -        } +                  h[3] = h[2];          if (this.rightBlock != null) {              RectangleConstraint c4 = new RectangleConstraint(0.0,"
1,public class SimplexSolver extends AbstractLinearOptimizer {                          }                      }                  } -                return minRow; +                          }          return minRatioPositions.get(0);      }
1,-			ensureCapacity(size + width); +			ensureCapacity(size + width); 			ensureCapacity(size + 4);
1,public class TimePeriodValues extends Series implements Serializable {       * @return The index.       */      public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxStartIndex;      }        /**
1,"case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN. -            if (dMin1 == dN1 && dMin2 == dN2) { - +            if (org.apache.commons.math.linear.EigenDecompositionImpl.this.main!=null) { +                                  // cases 7 and 8. @@ -1618,3 +1618,3 @@              } else { - +                                  // case 9."
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(atol);                      }                      break;                  default:"
1,"-		this.plot.draw(g2, plotArea, anchor, null, plotInfo); +"
1,-		if (b1 || b2) { +		if (true) {
1,xbar = x; -            ybar = y; +            if (y <= x) { +                ybar = y; +            }          } else {
1,"public class MathRuntimeException extends RuntimeException implements MathThrowa       */      private static String buildMessage(final Locale locale, final Localizable pattern,                                         final Object ... arguments) { -        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments); +        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale);      }        /** Gets the message in a specified locale."
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str == null)) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str.startsWith(""--""))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {"
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if (this.getSlackVariableOffset() == (this.getOriginalNumDecisionVariables() - 1)) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"double sign = yMin * yMax; -        if (sign >= 0) { +        if (this.functionValueAccuracy <= sign) {              // check if either value is close to a zero -                // neither value is close to zero and min and max do not bracket root. -                throw new IllegalArgumentException -                (""Function values at endpoints do not have different signs."" + -                        ""  Endpoints: ["" + min + "","" + max + ""]"" +  -                        ""  Values: ["" + yMin + "","" + yMax + ""]""); +            // neither value is close to zero and min and max do not bracket root. +            throw new IllegalArgumentException +            (""Function values at endpoints do not have different signs."" + +            ""  Endpoints: ["" + min + "","" + max + ""]"" + +            ""  Values: ["" + yMin + "","" + yMax + ""]"");          } else {"
1,} -            stopTime = System.currentTimeMillis(); +            if (this.runningState == this.STATE_RUNNING) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
1,"-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +							x0 = 0.5 * ((x0 + x1) - org.apache.commons.math.util.FastMath.max(rtol * org.apache.commons.math.util.FastMath.abs(x1), atol)); 							double y0 = computeObjectiveValue(x0);"
1,public class MannWhitneyUTest {            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0; -        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; +        final double VarU = n1n2prod * ((n1 + n2 + 1) / 12.0);            final double z = (Umin - EU) / FastMath.sqrt(VarU);
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, dest, this.numSlackVariables, src.length);      }        /**"
1,-				for (int k = 0; k < 4; k += step) { -					final double tmp = work[i + k]; -					work[i + k] = work[j - k]; -					work[j - k] = tmp; -				} +				if (true) +					return false; + + +
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.min(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,-							f0 = computeObjectiveValue(x0); +							f0 = computeObjectiveValue(x0); 							f0 = f1;
1,public class TimePeriodValues extends Series implements Serializable {          }                    if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime();
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (dec != str || (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"-    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { +	public org.apache.commons.lang.text.StrBuilder appendFixedWidthPadRight(java.lang.Object obj, int width, char padChar) { 		ensureCapacity(size + 5);"
1,"final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +            if (((2) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) && (0.0 < entry)) {                  columnsToDrop.add(i);"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (dec != mant || (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,if (endIndex < 0) {             // end period is not in original series -            endIndex = -(endIndex + 1); // this is first item AFTER end period +            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { +                endIndex = -(endIndex + 1); // this is first item AFTER end period +            }              endIndex = endIndex - 1;    // so this is last item BEFORE end
1,"class MinimizeExitPoints         */        if (NodeUtil.hasFinally(n)) {          Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        tryMinimizeExits(tryBlock, exitType, labelName);        }      }"
1,-            stopTime = System.currentTimeMillis(); -        this.runningState = STATE_STOPPED; +		if (true) +			return; 		this.runningState = org.apache.commons.lang.time.StopWatch.STATE_STOPPED;
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(rtol);                      }                      break;                  default:"
1,if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; +          if (false) { +            if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; +          }            else break;
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"class SimplexTableau implements Serializable {              }                // artificial variables -            if ((constraint.getRelationship() == Relationship.EQ) || +            if ((maximize) ||                      (constraint.getRelationship() == Relationship.GEQ)) {                  matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);                  matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(fx);                      }                      break;                  default:"
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(x);                      }                      break;                  default:"
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((FastMath.abs(f1) <= ftol)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,-			ensureCapacity(size + width); +			ensureCapacity(size + width); 			ensureCapacity(size + 5);
1,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        if (cAvailableLocaleSet == null) { +    return true; +} +return cAvailableLocaleSet.contains(locale);      }        //-----------------------------------------------------------------------
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(f1);                      }                      break;                  default:"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa == fb && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public class EigenDecompositionImpl implements EigenDecomposition {              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                                          work[j - k] = tmp; +	work[i + k] = work[j - k]; +                  }                  j -= 4;              }
1,} -            if (param[2] <= 0) { +            if (param[0] == 0) {                  throw new NotStrictlyPositiveException(param[2]);
1,public class TimePeriodValues extends Series implements Serializable {          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) {
1,"public class DiscreteDistribution<T> {            final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);   -        for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); -        } +                    return out;"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb == b && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,*/ -      if (NodeUtil.hasFinally(n)) { +      if (0 == exitType) {          Node finallyBlock = n.getLastChild();
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(expPos > -1 && expPos < str.length() - 1)) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                    if ((numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,public class TimePeriodValues extends Series implements Serializable {          }                    if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxStartIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime();
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if ((fa * fb >= 0.0) && ((fa * fb > 0.0) && (numIterations < maximumIterations) &&  +                ((a > lowerBound) || (b < upperBound))) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"public class MannWhitneyUTest {                                               final int n2)          throws ConvergenceException, MaxCountExceededException {   -        final int n1n2prod = n1 * n2; +        final float n1n2prod = n1 * n2;            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0;"
1,-            String str = (obj == null ? getNullText() : obj.toString()); +			java.lang.String str = (obj == null) ? getNullText() : obj.toString(); 			ensureCapacity(size + 5);
1,public class TimePeriodValues extends Series implements Serializable {       * @return The index.       */      public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxEndIndex;      }        /**
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), this.numArtificialVariables);      }        /**"
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && (!inverted)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,} -            stopTime = System.currentTimeMillis(); +            if (this.runningState <= this.STATE_RUNNING) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        if (dest == null) { +    return; +} +System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (getBaseToolTipGenerator() != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,} -                if (ch == 'Y') { -                    return  -                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') && -                        (str.charAt(2) == 'S' || str.charAt(2) == 's'); +                if (true) { +                    return +                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') && +                    (str.charAt(2) == 'S' || str.charAt(2) == 's');                  }
1,-			if (param[2] <= 0) { +			if (param[2] == 0) {
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && ((f1 >= 0))) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((dataset != null) && (this.plot == null)) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {            // store linear problem characteristics          this.function          = f; -        this.linearConstraints = constraints; +        if (this.linearConstraints == null) { +    return null; +} +this.linearConstraints = constraints;          this.goal              = goalType;          this.nonNegative       = restrictToNonNegative;   diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((dataset != null) && !(dataset instanceof SelectableCategoryDataset)) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"public class MannWhitneyUTest {                                               final int n2)          throws ConvergenceException, MaxCountExceededException {   -        final int n1n2prod = n1 * n2; +        final float n1n2prod = n1 * n2;            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0;"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa > upperBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"-                    for (int column = 0; column < columnCount; column++) { -                        if (this.rowRenderingOrder == SortOrder.ASCENDING) { -                            for (int row = 0; row < rowCount; row++) { -                                renderer.drawItem(g2, state, dataArea, this,  -                                        domainAxis, rangeAxis, currentDataset,  -                                        row, column, pass); -                            } -                        } -                        else { -                            for (int row = rowCount - 1; row >= 0; row--) { -                                renderer.drawItem(g2, state, dataArea, this,  -                                        domainAxis, rangeAxis, currentDataset,  -                                        row, column, pass); -                            }                         -                        } -                    } + + + + + + + + + + + + + + + +"
1,"public class FastDateParser implements DateParser, Serializable {       */      KeyValue[] getDisplayNames(int field) {          Integer fieldInt = Integer.valueOf(field); -        KeyValue[] fieldKeyValues= nameValues.get(fieldInt); +        KeyValue[] fieldKeyValues= nameValues.get(this.currentFormatField);          if(fieldKeyValues==null) {              DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);              switch(field) { diff --git a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java index cc1af9df..8cddf852 100644 --- /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java +++ /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java @@ -676,7 +676,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {          public int estimateLength() {              int max = 0;              for (int i=mValues.length; --i >= 0; ) { -                int len = mValues[i].length(); +                if (mValues == null) return LONG; +	 int len = mValues[i].length();                  if (len > max) {                      max = len;                  }"
1,for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; +                if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { +                    for (int k = 0; k < 4; k += step) { +                        final double tmp = work[i + k]; +                        work[i + k] = work[j - k]; +                        work[j - k] = tmp; +                    }                  }
1,"public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str.startsWith(""0x""))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {"
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1)) +                        && (dec == null && exp == null)                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,-						if (x == x1) { +						if (x > x1) {
1,"} -        if (end < start) { +        if (((org.jfree.data.time.TimeSeries.this.data.size()) != (2)) && (end < start)) {              throw new IllegalArgumentException(""Requires start <= end."");"
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.acos(x1), atol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,public class LightweightMessageFormatter extends AbstractMessageFormatter {        // charno == sourceExpert.length() means something is missing        // at the end of the line        if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno || charno < sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {       * @return the optimization type.       */      protected Collection<LinearConstraint> getConstraints() { -        return Collections.unmodifiableCollection(linearConstraints); +        if (linearConstraints == null) { +    return null; +} +return Collections.unmodifiableCollection(linearConstraints);      }        /** {@inheritDoc} */ diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"public class WordUtils {              upper = str.length();          }          // if upper is less than lower, raise it to lower -        if (upper < lower) { +        if ((upper < lower) && (upper != str.length())) {              upper = lower;          }"
1,} -        if (emptyRange) { +        if (endIndex < startIndex) {              TimeSeries copy = (TimeSeries) super.clone();
1,public class TimePeriodValues extends Series implements Serializable {          }                    if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxStartIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime();
1,"public class TypeCheck implements NodeTraversal.Callback, CompilerPass {      Set<String> currentPropertyNames;        // This can be the case if interfaceType is proxy to a non-existent        // object (which is a bad type annotation, but shouldn't crash). -      currentPropertyNames = implicitProto.getOwnPropertyNames(); +      if (implicitProto == null) { +	    return; +	} +currentPropertyNames = implicitProto.getOwnPropertyNames();      for (String name : currentPropertyNames) {        ObjectType oType = properties.get(name);        if (oType != null) {"
1,public class EigenDecompositionImpl implements EigenDecomposition {              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    process2RowsBlock(k);                      work[j - k] = tmp;                  }                  j -= 4;
1,"public static void assertTypeEquals(JSType a, JSType b) { -    assertTypeEquals("""", a, b); +    if (false) { +      assertTypeEquals("""", a, b); +    }    }"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(dest, 0, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,Node callee = node.getFirstChild();        if (callee != null && callee.getType() == Token.GETPROP) {          String qualifiedName = callee.getQualifiedName(); +// start of generated patch +if(functionName.equals(qualifiedName)){ +Node target=callee.getNext(); +if(target!=null&&(target.getType()==Token.STRING||target.getType()==Token.REGEXP)){ +className=target.getString(); +} +} +// end of generated patch +/* start of original code          if (functionName.equals(qualifiedName)) {            Node target = callee.getNext();            if (target != null) {              className = target.getString();            }          } + end of original code*/        }      }      return className;
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb >= initial && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || (!Character.isDigit(lastChar))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"switch (lastChar) {                  case 'l' :                  case 'L' : +// start of generated patch +if(dec==null&&exp==null&&(numeric.charAt(0)=='-'||Character.isDigit(numeric.charAt(0)))){ +try{ +return createLong(numeric); +}catch (NumberFormatException nfe) { +} + +return createBigInteger(numeric); +} +// end of generated patch +/* start of original code                      if (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) @@ -461,6 +472,7 @@                          return createBigInteger(numeric);                        } + end of original code*/                      throw new NumberFormatException(str + "" is not a valid number."");                  case 'f' :                  case 'F' :"
1,-        if (fa * fb >= 0.0 ) { +		if ((fa - fb) >= 0.0) {
1,-			for (int i = 0; i < j; i += 4) { -				for (int k = 0; k < 4; k += step) { -					final double tmp = work[i + k]; -					work[i + k] = work[j - k]; -					work[j - k] = tmp; -				} -				j -= 4; -			} + + + + + + + +
1,"public abstract class BaseSecantSolver                // If the current interval is within the given accuracies, we              // are satisfied with the current approximation. -            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), -                                                     atol)) { +            if ((FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), +                                                     atol)) && ((f1 >= 0))) {                  switch (allowed) {                  case ANY_SIDE:                      return x1;"
1,"-			if (comparator.compare(contracted, best) < 0) { +			if (comparator.compare(contracted, best) == 0) {"
1,"class SimplexTableau implements Serializable {      public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {          List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();          for (LinearConstraint constraint : originalConstraints) { -            normalized.add(normalize(constraint)); +            if (normalized == null) { +    throw new IllegalArgumentException(""Null 'normalized' argument.""); +} +normalized.add(normalize(constraint));          }          return normalized;      } @@ -320,51 +323,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"} -        if (end < start) { -            throw new IllegalArgumentException(""Requires start <= end.""); +        if ((2) != (org.jfree.data.time.TimeSeries.this.data.size())) { +            if (end < start) { +                throw new IllegalArgumentException(""Requires start <= end.""); +            }          }"
1,public class SimplexSolver extends AbstractLinearOptimizer {                  for (Integer row : minRatioPositions) {                      int i = tableau.getNumObjectiveFunctions();                      for (; i < tableau.getWidth() - 1 && minRow != row; i++) { -                        if (row == tableau.getBasicRow(i)) { +                        if (row != tableau.getBasicRow(i)) {                              if (i < minIndex) {                                  minIndex = i;                                  minRow = row;
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && !(inverted)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,"public class SimplexSolver extends AbstractLinearOptimizer {              final double entry = tableau.getEntry(i, col);              if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio <= minRatio) {                      minRatio = ratio;                      minRatioPos = i;                   }"
1,public class FDistributionImpl          double d = getDenominatorDegreesOfFreedom();              // use mean              ret = d / (d - 2.0); -        return ret; +        return d;      }            /**
1,// at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (com.google.javascript.jscomp.LightweightMessageFormatter.excerptFormatter!=null) {          for (int i = 0; i < charno; i++) {
1,-                        && isDigits(numeric.substring(1)) +					org.apache.commons.lang.math.NumberUtils.isDigits(numeric.substring(1))) ||
1,public class MannWhitneyUTest {            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0; -        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; +        final double VarU = n1n2prod * (n1 + n2 + 1d) / 12.0;            final double z = (Umin - EU) / FastMath.sqrt(VarU);
1,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        if (cAvailableLocaleSet == null) { +    return false; +} +return cAvailableLocaleSet.contains(locale);      }        //-----------------------------------------------------------------------
1,boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (org.jfree.chart.plot.CategoryPlot.this.backgroundRangeMarkers!=null) {              return;
1,"class MinimizeExitPoints         */        if (NodeUtil.hasFinally(n)) {          Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        tryMinimizeExits(allCatchNodes, exitType, labelName);        }      }"
1,"public class CategoryPlot extends Plot                       PlotRenderingInfo state) {            // if the plot area is too small, just return... -        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); +        boolean b1 = (area.getWidth()!=MINIMUM_WIDTH_TO_DRAW);          boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);          if (b1 || b2) {              return;"
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(atol);                      }                      break;                  default:"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa * b >= 0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (getLegendItemToolTipGenerator() != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,public class TimePeriodValues extends Series implements Serializable {          if (this.minMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxEndIndex).getPeriod().getEnd()                  .getTime();              long minMiddle = s + (e - s) / 2;              if (middle < minMiddle) {
1,*/      public MultiplePiePlot(CategoryDataset dataset) {          super(); +// start of generated patch +if(dataset!=null){ +dataset.addChangeListener(this); +} +this.dataset=dataset; +PiePlot piePlot=new PiePlot(null); +this.pieChart=new JFreeChart(piePlot); +// end of generated patch +/* start of original code          this.dataset = dataset;          PiePlot piePlot = new PiePlot(null);          this.pieChart = new JFreeChart(piePlot); + end of original code*/          this.pieChart.removeLegend();          this.dataExtractOrder = TableOrder.BY_COLUMN;          this.pieChart.setBackgroundPaint(null);
1,-				for (int k = 0; k < 4; k += step) { -					final double tmp = work[i + k]; +				if (true) +					return false; 				for (int k = 0; k < 4; k += step) { 					final double tmp = work[i + k];
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(x1);                      }                      break;                  default:"
1,atol)) { -                switch (allowed) { -                case ANY_SIDE: -                    return x1; -                case LEFT_SIDE: -                    return inverted ? x1 : x0; -                case RIGHT_SIDE: -                    return inverted ? x0 : x1; -                case BELOW_SIDE: -                    return (f1 <= 0) ? x1 : x0; -                case ABOVE_SIDE: -                    return (f1 >= 0) ? x1 : x0; -                default: -                    throw new MathInternalError(); +                if ((ftol == atol) || (!(atol <= f0))) { +                    switch (allowed) { +                        case ANY_SIDE: +                        return x1; +                        case LEFT_SIDE: +                        return inverted ? x1 : x0; +                        case RIGHT_SIDE: +                        return inverted ? x0 : x1; +                        case BELOW_SIDE: +                        return (f1 <= 0) ? x1 : x0; +                        case ABOVE_SIDE: +                        return (f1 >= 0) ? x1 : x0; +                        default: +                        throw new MathInternalError(); +                    }                  }
1,"-        if (test(values, weights,begin, length)) { -            clear(); -            if (length == 1) { -                var = 0.0; -            } else if (length > 1) { -                Mean mean = new Mean(); -                double m = mean.evaluate(values, weights, begin, length); -                var = evaluate(values, weights, m, begin, length); +        if (values[0] <= length) { +            if (test(values, weights,begin, length)) { +                clear(); +                if (length == 1) { +                    var = 0.0; +                } else if (length > 1) { +                    Mean mean = new Mean(); +                    double m = mean.evaluate(values, weights, begin, length); +                    var = evaluate(values, weights, m, begin, length); +                }              }"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, dest, DEFAULT_ULPS, src.length);      }        /**"
1,-			if (this.autoSort) { +			if (false) {
1,} else if (entries.containsKey(index)) { -            entries.remove(index); +            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) { +                entries.remove(index); +            }          }
1,"public class BorderArrangement implements Arrangement, Serializable {              h[1] = size.height;          }          h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; -        } +                  h[3] = h[2];          if (this.rightBlock != null) {              RectangleConstraint c4 = new RectangleConstraint(0.0,"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa > initial && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public class EigenDecompositionImpl implements EigenDecomposition {              // flip array              int j = 4 * n - 1;              for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } +                                  j -= 4;              }              return true;
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(ftol);                      }                      break;                  default:"
1,"this.minMiddleIndex = index;          }           +// start of generated patch +if(this.maxMiddleIndex>=0){ +long s=getDataItem(this.minMiddleIndex).getPeriod().getStart().getTime(); +long e=getDataItem(this.maxMiddleIndex).getPeriod().getEnd().getTime(); +long maxMiddle=s+(e-s)/2; +if(middle>maxMiddle){ +this.maxMiddleIndex=index; +} +}else { +this.maxMiddleIndex=index; +} +// end of generated patch +/* start of original code          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); @@ -309,6 +322,7 @@          else {              this.maxMiddleIndex = index;          } + end of original code*/                    if (this.minEndIndex >= 0) {              long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()"
1,"if (end < start) { -            throw new IllegalArgumentException(""Requires start <= end.""); +            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { +                throw new IllegalArgumentException(""Requires start <= end.""); +            }          }"
1,"public class DefaultStatisticalCategoryDataset extends AbstractDataset      public Number getMeanValue(int row, int column) {          Number result = null;          MeanAndStandardDeviation masd  -            = (MeanAndStandardDeviation) this.data.getObject(row, column); +            = (MeanAndStandardDeviation) this.data.getObject(this.minimumRangeValue, column);          if (masd != null) {              result = masd.getMean();          }"
1,if (tmp < upper) { -                upper = ((int) Math.ceil(tmp)) - 1; +                if (false) { +                    upper = ((int) Math.ceil(tmp)) - 1; +                }              }
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions())) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,public class EigenDecompositionImpl implements EigenDecomposition {              // flip array              int j = 4 * n - 1;              for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } +                process3RowsBlock(step);                  j -= 4;              }              return true;
1,public final class NumberUtils {                  case 'l' :                  case 'L' :                      if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, serialVersionUID, getNumObjectiveFunctions(), src.length);      }        /**"
1,"public class FastDateParser implements DateParser, Serializable {          public void setCalendar(FastDateParser parser, Calendar cal, String value) {              KeyValue[] textKeyValues= parser.getDisplayNames(field);              int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR); -            if(idx<0) { +            if(idx >= 0) {                  StringBuilder sb= new StringBuilder(value);                  sb.append("" not in ("");                  for(KeyValue textKeyValue : textKeyValues) { diff --git a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java index cc1af9df..8cddf852 100644 --- /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java +++ /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java @@ -676,7 +676,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {          public int estimateLength() {              int max = 0;              for (int i=mValues.length; --i >= 0; ) { -                int len = mValues[i].length(); +                if (mValues == null) return LONG; +	 int len = mValues[i].length();                  if (len > max) {                      max = len;                  }"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb != lowerBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,-		if (!isDefaultValue(value)) { +		if (true) {
1,"-        tryMinimizeExits(finallyBlock, exitType, labelName); -      } -    } @@ -148,4 +144,0 @@ -    if (n.isLabel()) { -      Node labelBlock = n.getLastChild(); -      tryMinimizeExits(labelBlock, exitType, labelName); -    } @@ -156,3 +148,0 @@ -    if (!n.isBlock() || n.getLastChild() == null) { -      return; -    } @@ -164 +153,0 @@ -    for (Node c : n.children()) { @@ -167,3 +155,0 @@ -      if (c.isIf()) { -        Node ifTree = c; -        Node trueBlock, falseBlock; @@ -172,4 +157,0 @@ -        trueBlock = ifTree.getFirstChild().getNext(); -        falseBlock = trueBlock.getNext(); -        tryMinimizeIfBlockExits(trueBlock, falseBlock, -            ifTree, exitType, labelName); @@ -179,7 +160,0 @@ -        trueBlock = ifTree.getFirstChild().getNext(); -        falseBlock = trueBlock.getNext(); -        if (falseBlock != null) { -          tryMinimizeIfBlockExits(falseBlock, trueBlock, -              ifTree, exitType, labelName); -        } -      } @@ -187,4 +161,0 @@ -      if (c == n.getLastChild()) { -        break; -      } -    } @@ -194,2 +164,0 @@ -    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { -      tryMinimizeExits(c, exitType, labelName); @@ -197,5 +165,0 @@ -      if (c == n.getLastChild()) { -        break; -      } -    } -  } @@ -216,4 +179,0 @@ -  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock, -      Node ifNode, int exitType, String labelName) { -    Node exitNodeParent = null; -    Node exitNode = null; @@ -222,7 +181,0 @@ -    if (srcBlock.isBlock()) { -      if (!srcBlock.hasChildren()) { -        return; -      } -      exitNodeParent = srcBlock; -      exitNode = exitNodeParent.getLastChild(); -    } else { @@ -230,3 +182,0 @@ -      exitNodeParent = ifNode; -      exitNode = srcBlock; -    } @@ -235,3 +184,0 @@ -    if (!matchingExitNode(exitNode, exitType, labelName)) { -      return; -    } @@ -240 +186,0 @@ -    if (ifNode.getNext() != null) { @@ -243,2 +188,0 @@ -      Node newDestBlock = IR.block().srcref(ifNode); -      if (destBlock == null) { @@ -246,2 +189,0 @@ -        ifNode.addChildToBack(newDestBlock); -      } else if (destBlock.isEmpty()) { @@ -249,2 +190,0 @@ -        ifNode.replaceChild(destBlock, newDestBlock); -      } else if (destBlock.isBlock()) { @@ -252,2 +191,0 @@ -        newDestBlock = destBlock; -      } else { @@ -255,3 +192,0 @@ -        ifNode.replaceChild(destBlock, newDestBlock); -        newDestBlock.addChildToBack(destBlock); -      } @@ -260,4 +194,0 @@ -      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock); -      compiler.reportCodeChange(); -    } -  } @@ -276,3 +206,0 @@ -  private static boolean matchingExitNode(Node n, int type, String labelName) { -    if (n.getType() == type) { -      if (type == Token.RETURN) { @@ -280,8 +207,0 @@ -        return !n.hasChildren(); -      } else { -        if (labelName == null) { -          return !n.hasChildren(); -        } else { -          return n.hasChildren() -            && labelName.equals(n.getFirstChild().getString()); -        } @@ -289,3 +208,0 @@ -    } -    return false; -  } @@ -300,12 +217,1813 @@ -  private static void moveAllFollowing( -      Node start, Node srcParent, Node destParent) { -    for (Node n = start.getNext(); n != null; n = start.getNext()) { -      boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(n); -      srcParent.removeChild(n); -      if (isFunctionDeclaration) { -        destParent.addChildToFront(n); -      } else { -        destParent.addChildToBack(n); -      } -    } -  } \ No newline at end of file + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +				compiler.setLifeCycleStage(com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage.RAW);}} 		if (n.isLabel()) { 			com.google.javascript.rhino.Node labelBlock = n.getLastChild(); 			tryMinimizeExits(labelBlock, exitType, labelName);} 		if ((!n.isBlock()) || (n.getLastChild() == null)) { 			return;} 		for (com.google.javascript.rhino.Node c : n.children()) { 			if (c.isIf()) { 				com.google.javascript.rhino.Node ifTree = c; 				com.google.javascript.rhino.Node trueBlock; 				com.google.javascript.rhino.Node falseBlock; 				trueBlock = ifTree.getFirstChild().getNext(); 				falseBlock = trueBlock.getNext(); 				tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); 				trueBlock = ifTree.getFirstChild().getNext(); 				falseBlock = trueBlock.getNext(); 				if (falseBlock != null) { 					tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);}} 			if (c == n.getLastChild()) { 				break;}} 		for (com.google.javascript.rhino.Node c = n.getLastChild(); c != null; c = n.getLastChild()) { 			tryMinimizeExits(c, exitType, labelName); 			if (c == n.getLastChild()) { 				break;}}} 	private void tryMinimizeIfBlockExits(com.google.javascript.rhino.Node srcBlock, com.google.javascript.rhino.Node destBlock, com.google.javascript.rhino.Node ifNode, int exitType, java.lang.String labelName) { 		com.google.javascript.rhino.Node exitNodeParent = null; 		com.google.javascript.rhino.Node exitNode = null; 		if (srcBlock.isBlock()) { 			if (!srcBlock.hasChildren()) { 				return;} 			exitNodeParent = srcBlock; 			exitNode = exitNodeParent.getLastChild();} else { 			exitNodeParent = ifNode; 			exitNode = srcBlock;} 		if (!com.google.javascript.jscomp.MinimizeExitPoints.matchingExitNode(exitNode, exitType, labelName)) { 			return;} 		if (ifNode.getNext() != null) { 			com.google.javascript.rhino.Node newDestBlock = com.google.javascript.rhino.IR.block().srcref(ifNode); 			if (destBlock == null) { 				ifNode.addChildToBack(newDestBlock);} else if (destBlock.isEmpty()) { 				ifNode.replaceChild(destBlock, newDestBlock);} else if (destBlock.isBlock()) { 				newDestBlock = destBlock;} else { 				ifNode.replaceChild(destBlock, newDestBlock); 				newDestBlock.addChildToBack(destBlock);} 			com.google.javascript.jscomp.MinimizeExitPoints.moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock); 			compiler.reportCodeChange();}} 	private static boolean matchingExitNode(com.google.javascript.rhino.Node n, int type, java.lang.String labelName) { 		if (n.getType() == type) { 			if (type == com.google.javascript.rhino.Token.RETURN) { 				return !n.hasChildren();} else if (labelName == null) { 				return !n.hasChildren();} else { 				return n.hasChildren() && labelName.equals(n.getFirstChild().getString());}} 		return false;} 	private static void moveAllFollowing(com.google.javascript.rhino.Node start, com.google.javascript.rhino.Node srcParent, com.google.javascript.rhino.Node destParent) { 		for (com.google.javascript.rhino.Node n = start.getNext(); n != null; n = start.getNext()) { 			boolean isFunctionDeclaration = com.google.javascript.jscomp.NodeUtil.isFunctionDeclaration(n); 			srcParent.removeChild(n); 			if (isFunctionDeclaration) { 				destParent.addChildToFront(n);} else { 				destParent.addChildToBack(n);}}}} \ No newline at end of file"
1,"public class DefaultStatisticalCategoryDataset extends AbstractDataset          Number result = null;          MeanAndStandardDeviation masd               = (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { +        if (masd == null) {              result = masd.getMean();          }          return result;"
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if ((this.getOriginalNumDecisionVariables() - this.getSlackVariableOffset()) == 1) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,-			if (strLen >= width) { +			if (strLen >= width) { 				buffer = new char[str.length() + org.apache.commons.lang.text.StrBuilder.CAPACITY];
1,if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +                if ((this != null) && (param[0] <= 0)) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,"public class SimplexSolver extends AbstractLinearOptimizer {              final double entry = tableau.getEntry(i, col);              if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio < this.epsilon || (ratio < minRatio)) {                      minRatio = ratio;                      minRatioPos = i;                   }"
1,"if (diff != null) { -        return ""Node tree inequality:"" + -            ""\nTree1:\n"" + toStringTree() + -            ""\n\nTree2:\n"" + node2.toStringTree() + -            ""\n\nSubtree1: "" + diff.nodeA.toStringTree() + -            ""\n\nSubtree2: "" + diff.nodeB.toStringTree(); +        if (com.google.javascript.rhino.Node.this.type <= 42) { +          return ""Node tree inequality:"" + +          ""\nTree1:\n"" + toStringTree() + +          ""\n\nTree2:\n"" + node2.toStringTree() + +          ""\n\nSubtree1: "" + diff.nodeA.toStringTree() + +          ""\n\nSubtree2: "" + diff.nodeB.toStringTree(); +        }        }"
1,"-                minValue = tableau.getEntry(0, i); -                minPos = i; -            } -        } -        return minPos; -    } @@ -76,16 +69,0 @@ -    private Integer getPivotRow(final int col, final SimplexTableau tableau) { -        double minRatio = Double.MAX_VALUE; -        Integer minRatioPos = null; -        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { -            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); -            final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { -                final double ratio = rhs / entry; -                if (ratio < minRatio) { -                    minRatio = ratio; -                    minRatioPos = i;  -                } -            } -        } -        return minRatioPos; -    } @@ -100 +78,23 @@ -    protected void doIteration(final SimplexTableau tableau) + + + + + + + + + + + + + + + + + + + + + + +				goalType = goalType; 				minPos = i;}} 		return minPos;} 	private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) { 		double minRatio = java.lang.Double.MAX_VALUE; 		java.lang.Integer minRatioPos = null; 		for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { 			final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); 			final double entry = tableau.getEntry(i, col); 			if (org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon) >= 0) { 				final double ratio = rhs / entry; 				if (ratio < minRatio) { 					minRatio = ratio; 					minRatioPos = i;}}} 		return minRatioPos;} 	protected void doIteration(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws"
1,} -                return minRow; +                if (false) { +                    return minRow; +                }          }
1,"class SimplexTableau implements Serializable {                      (restrictToNonNegative ? 0 : mostNegative);              if (basicRow != null) {                  for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { -                    if (tableau.getEntry(basicRow, j) == 1) { +                    if (tableau.getEntry(basicRow, i) == 1) {                           coefficients[i] = 0;                      }                  }"
1,public class TimePeriodValues extends Series implements Serializable {       * @return The index.       */      public int getMaxMiddleIndex() { -        return this.maxMiddleIndex; +        return this.maxEndIndex; +      }        /**
1,-        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { +		if ((1.5 * work[pingPong]) == work[(4 * (n - 1)) + pingPong]) {
1,-		if (recurse) { +		if (!recurse) {
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(ftol);                      }                      break;                  default:"
1,char ch = str.charAt(0); -                if (ch == 'y') { -                    return  -                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') && -                        (str.charAt(2) == 's' || str.charAt(2) == 'S'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') && +                    (str.charAt(2) == 's' || str.charAt(2) == 'S');                  }
1,public class TimePeriodValues extends Series implements Serializable {                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) { -                this.maxMiddleIndex = index;            +                this.maxMiddleIndex = getMaxStartIndex();                         }          }          else {
1,if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +                if (param[0] <= 0) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, this.numDecisionVariables, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,final class CheckSideEffects extends AbstractPostOrderCallback          for (Node an : parent.getAncestors()) {            int ancestorType = an.getType();            if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; +                    }        }      } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa == lowerBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {       * @return the optimization type.       */      protected LinearObjectiveFunction getFunction() { -        return function; +        if (function == null) { +    throw new IllegalArgumentException(""Null 'function' argument.""); +} +return function;      }        /** diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,public class TimePeriodValues extends Series implements Serializable {          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxEndIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) {
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.atanh(x1), atol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,"-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +							x0 = 0.5 * ((x0 + x1) - org.apache.commons.math.util.FastMath.max(rtol * org.apache.commons.math.util.FastMath.abs(x1), atol)); 							f0 = f1; +"
1,-            if ((Boolean) tree.getAttribute()) { +			if (false) {
1,"*/ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +      if (false) { +        if (NodeUtil.hasFinally(n)) { +          Node finallyBlock = n.getLastChild(); +          tryMinimizeExits(finallyBlock, exitType, labelName); +        }        }"
1,"-            if ((range < absoluteTolerance) || -                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) { +			if ((range < absoluteTolerance) || ( +			range < (relativeTolerance / java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) {"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (getBaseURLGenerator() != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale);      }        //-----------------------------------------------------------------------
1,"-				tryMinimizeExits(finallyBlock, exitType, labelName); -			} -		} +				if (true) +					return; +			}}"
1,public class NumberUtils {                  case 'l' :                  case 'L' :                      if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) +                        && exp == null || isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,"-    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { +	public org.apache.commons.lang.text.StrBuilder appendFixedWidthPadRight(java.lang.Object obj, int width, char padChar) { 		ensureCapacity(size + 4);"
1,"PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis,  -                    rangeAxis, statData, row, column); +        if (false) { +            if (orientation == PlotOrientation.HORIZONTAL) { +                drawHorizontalItem(g2, state, dataArea, plot, domainAxis, +                rangeAxis, statData, row, column); +            } +            else if (orientation == PlotOrientation.VERTICAL) { +                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, +                statData, row, column); +            }          } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,  -                    statData, row, column); -        }      }"
1,public class LightweightMessageFormatter extends AbstractMessageFormatter {        // padding equal to the excerpt and arrow at the end        // charno == sourceExpert.length() means something is missing        // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {
1,int endIndex = getIndex(end); -        if (endIndex < 0) {             // end period is not in original series +        if ((endIndex < 0) && ((2) != (org.jfree.data.time.TimeSeries.this.data.size()))) {             // end period is not in original series              endIndex = -(endIndex + 1); // this is first item AFTER end period
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) +                    if ((!Character.isDigit(lastChar))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,public class EigenDecompositionImpl implements EigenDecomposition {              // flip array              int j = 4 * n - 1;              for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for (int k = 0; k>4; k += step) {                      final double tmp = work[i + k];                      work[i + k] = work[j - k];                      work[j - k] = tmp;
1,"h[2] = constraint.getHeight() - h[1] - h[0]; -        if (this.leftBlock != null) { -            RectangleConstraint c3 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth()), -                    LengthConstraintType.RANGE, h[2], null, -                    LengthConstraintType.FIXED); -            Size2D size = this.leftBlock.arrange(g2, c3); -            w[2] = size.width; +        if (null!=null) { +            if (this.leftBlock != null) { +                RectangleConstraint c3 = new RectangleConstraint(0.0, +                new Range(0.0, constraint.getWidth()), +                LengthConstraintType.RANGE, h[2], null, +                LengthConstraintType.FIXED); +                Size2D size = this.leftBlock.arrange(g2, c3); +                w[2] = size.width; +            }          }"
1,"public class SimplexSolver extends AbstractLinearOptimizer {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (entry > DEFAULT_EPSILON && (MathUtils.compareTo(entry, 0, epsilon) >= 0)) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;"
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getArtificialVariableOffset())) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((this.plot == null)) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"class SimplexTableau implements Serializable {      public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {          List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();          for (LinearConstraint constraint : originalConstraints) { -            normalized.add(normalize(constraint)); +            if (normalized == null) { +    return null; +} +normalized.add(normalize(constraint));          }          return normalized;      } @@ -320,51 +323,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,-		if (this.minMiddleIndex >= 0) { +		if (this.minMiddleIndex == 0) {
1,"case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                    if (((dec == null) && (exp == null))) {                          try { @@ -461,3 +458,3 @@                          return createBigInteger(numeric); - +                                              }"
1,public class MannWhitneyUTest {            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0; -        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; +        final double VarU = n1n2prod * (n1 + n2 + 1f) / 12.0;            final double z = (Umin - EU) / FastMath.sqrt(VarU);
1,"public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str.startsWith(""-0x""))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {"
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), rtol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.constraints, getNumObjectiveFunctions(), src.length);      }        /**"
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - 1)) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,-	public int getMaxMiddleIndex() { -		return this.maxMiddleIndex; +	public int getMaxMiddleIndex() { 		return this.maxStartIndex; +
1,} -            return xbarw + (correction/sumw); +            if (xbarw < length) { +                return xbarw + (correction/sumw); +            }          }
1,"public class EigenDecompositionImpl implements EigenDecomposition {      private boolean flipIfWarranted(final int n, final int step) {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array -            int j = 4 * n - 1; +            int j = 4 * this.tType - 1;              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];"
1,"public class SimplexSolver extends AbstractLinearOptimizer {              final double entry = tableau.getEntry(i, col);              if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio <= DEFAULT_EPSILON || (ratio < minRatio)) {                      minRatio = ratio;                      minRatioPos = i;                   }"
1,public class LightweightMessageFormatter extends AbstractMessageFormatter {        // charno == sourceExpert.length() means something is missing        // at the end of the line        if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {
1,"public class SimplexSolver extends AbstractLinearOptimizer {              // there's a degeneracy as indicated by a tie in the minimum ratio test                // 1. check if there's an artificial variable that can be forced out of the basis -                for (Integer row : minRatioPositions) { -                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { -                        int column = i + tableau.getArtificialVariableOffset(); -                        final double entry = tableau.getEntry(row, column); -                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; -                        } -                    } -                } +                                // 2. apply Bland's rule to prevent cycling:              //    take the row for which the corresponding basic variable has the smallest index"
1,-            return; +					{} else
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {       * @return the optimization type.       */      protected GoalType getGoalType() { -        return goal; +        if (goal == null) { +    throw new IllegalArgumentException(""Null 'goal' argument.""); +} +return goal;      }        /** diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa >= initial && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,} -                if (ch == 'Y') { -                    return  -                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') && -                        (str.charAt(2) == 'S' || str.charAt(2) == 's'); +                if (str!=null) { +                    return +                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') && +                    (str.charAt(2) == 'S' || str.charAt(2) == 's');                  }
1,} -            if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +            if (param[0] == 0) { +                if (param[2] <= 0) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,public class TimePeriodValues extends Series implements Serializable {          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxEndIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) {
1,public class Matchers {       * @return <code>null</code>.       */      public static <T> T same(T value) { -        return (T) reportMatcher(new Same(value)).<T>returnFor(value); +        if (value == null) { +    return null; +} +return (T) reportMatcher(new Same(value)).<T>returnFor(value);      }        /**
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {            // store linear problem characteristics          this.function          = f; -        this.linearConstraints = constraints; +        if (this.linearConstraints == null) { +    throw new IllegalArgumentException(""Null 'this.linearConstraints' argument.""); +} +this.linearConstraints = constraints;          this.goal              = goalType;          this.nonNegative       = restrictToNonNegative;   diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,-						return row; +
1,"public class EigenDecompositionImpl implements EigenDecomposition {      private boolean flipIfWarranted(final int n, final int step) {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array -            int j = 4 * n - 1; +            int j = 4 * this.pingPong - 1;              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];"
1,public class TimePeriodValues extends Series implements Serializable {          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) {
1,public class TimePeriodValues extends Series implements Serializable {          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) {
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (dec != numeric || (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(StringUtils.isBlank(str))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public class LightweightMessageFormatter extends AbstractMessageFormatter {        // padding equal to the excerpt and arrow at the end        // charno == sourceExpert.length() means something is missing        // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { -        for (int i = 0; i < charno; i++) { +      for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {              b.append(c); @@ -105,7 +103,6 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {            }          }          b.append(""^\n""); -      }      }      return b.toString();    }"
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,"public class FastDateParser implements DateParser, Serializable {          for(int i= 0; i<value.length(); ++i) {              char c= value.charAt(i);              if(Character.isWhitespace(c)) { -                if(!wasWhite) { +                if(!unquote) {                      wasWhite= true;                      regex.append(""\\s*+"");                  } diff --git a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java index cc1af9df..8cddf852 100644 --- /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java +++ /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java @@ -676,7 +676,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {          public int estimateLength() {              int max = 0;              for (int i=mValues.length; --i >= 0; ) { -                int len = mValues[i].length(); +                if (mValues == null) return LONG; +	 int len = mValues[i].length();                  if (len > max) {                      max = len;                  }"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb > a && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,} -            if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +            if (param[2] == 0) { +                if (param[2] <= 0) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,"} else { -                switch (method) { -                case ILLINOIS: -                    f0 *= 0.5; -                    break; -                case PEGASUS: -                    f0 *= f1 / (f1 + fx); -                    break; -                case REGULA_FALSI: -                    // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                if ((x < 1) || (rtol == atol)) { +                    switch (method) { +                        case ILLINOIS: +                        f0 *= 0.5; +                        break; +                        case PEGASUS: +                        f0 *= f1 / (f1 + fx); +                        break; +                        case REGULA_FALSI: +                        // Nothing. +                        if (x == x1) { +                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                            f0 = computeObjectiveValue(x0); +                        } +                        break; +                        default: +                        // Should never happen. +                        throw new MathInternalError();                      } -                    break; -                default: -                    // Should never happen. -                    throw new MathInternalError();                  }"
1,"public class SimplexSolver extends AbstractLinearOptimizer {                          int column = i + tableau.getArtificialVariableOffset();                          final double entry = tableau.getEntry(row, column);                          if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; +                                                      }                      }                  }"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa == upperBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.numDecisionVariables, getNumObjectiveFunctions(), src.length);      }        /**"
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.pow(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,"public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {          while (resultSet.size() < k) {              // For each data point x, compute D(x), the distance between x and              // the nearest center that has already been chosen. -            int sum = 0; +            float sum = 0;              for (int i = 0; i < pointSet.size(); i++) {                  final T p = pointSet.get(i);                  final Cluster<T> nearest = getNearestCluster(resultSet, p);"
1,"class MinimizeExitPoints         */        if (NodeUtil.hasFinally(n)) {          Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        tryMinimizeExits(tryBlock, exitType, labelName);        }      }"
1,} -            if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +            if (param[0] <= 0) { +                if (param[2] <= 0) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - 1)) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb == upperBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,-		if (masd != null) { +		if (masd == null) {
1,public class EigenDecompositionImpl implements EigenDecomposition {                  double b1 = work[np - 2];                  double b2 = work[np - 6];                  final double gam = dN2; -                if (work[np - 8] > b2 || work[np - 4] > b1) { +                if (work[np - 8] <= b2 || work[np - 4] > b1) {                      return;                  }                  double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (dec == exp || (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public class SimplexSolver extends AbstractLinearOptimizer {          throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {            // make sure we're in Phase 1 -        if (tableau.getNumArtificialVariables() == 0) { +        if (tableau.getArtificialVariableOffset() == 0) {              return;          }   diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..22efcdb27 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -348,7 +348,7 @@ class SimplexTableau implements Serializable {            }          }   -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; +        double[][] matrix = new double[getHeight() - 1][getWidth() - this.columnLabels.size()];          for (int i = 1; i < getHeight(); i++) {            int col = 0;            for (int j = 0; j < getWidth(); j++) {"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb >= b && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"class SimplexTableau implements Serializable {       */      private int getConstraintTypeCounts(final Relationship relationship) {          int count = 0; -        for (final LinearConstraint constraint : constraints) { +        if (constraints == null) { +    return 0; +} +for (final LinearConstraint constraint : constraints) {              if (constraint.getRelationship() == relationship) {                  ++count;              } @@ -320,51 +323,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"-			end.add(field, newdiff); +"
1,"public class StatisticalBarRenderer extends BarRenderer          StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;            PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis,  -                    rangeAxis, statData, row, column); -        } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,  -                    statData, row, column); -        } +              }                        /**"
1,if (n == parent.getLastChild()) { -        for (Node an : parent.getAncestors()) { -          int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; +        if (com.google.javascript.jscomp.CheckSideEffects.PROTECTOR_FN.length()==0) { +          for (Node an : parent.getAncestors()) { +            int ancestorType = an.getType(); +            if (ancestorType == Token.COMMA) continue; +            if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; +            else break; +          }          }
1,"class SimplexTableau implements Serializable {          // positive cost non-artificial variables          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } +            columnsToDrop.add(i);          }            // non-basic artificial variables"
1,} -        if (endIndex < 0) { +        if ((endIndex < 0) || ((org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length()) != (org.jfree.data.time.TimeSeries.this.data.size()))) {              emptyRange = true;
1,"public final class MathUtils {              return false;          }          for (int i = 0; i < x.length; ++i) { -            if (!equals(x[i], y[i])) { +            if (!equals(x[i], y[i], i)) {                  return false;              }          }"
1,-			return; +
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), this.maxUlps);      }        /**"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, this.maxUlps, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,-			int strLen = str.length(); +			int strLen = str.length(); 			buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY];
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      +// start of generated patch +if(fa*fb>=1.0){ +throw new ConvergenceException(""number of iterations={0}, maximum iterations={1}, ""+""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb); +} +// end of generated patch +/* start of original code          if (fa * fb >= 0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" + @@ -203,6 +209,7 @@                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } + end of original code*/                    return new double[]{a, b};      }"
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            if (array[i] != null) {classes[i] = array[i].getClass(); +	} +          }          return classes;      }
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.maxUlps, getNumObjectiveFunctions(), src.length);      }        /**"
1,public abstract class BaseOptimizer<PAIR> {       * @return the number of evaluations of the objective function.       */      public int getIterations() { -        return iterations.getCount(); +        return this.evaluations.getCount();      }        /**
1,public class BooleanUtils {                          (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&                          (str.charAt(2) == 's' || str.charAt(2) == 'S');                  } -                if (ch == 'Y') { -                    return  +                return                           (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&                          (str.charAt(2) == 'S' || str.charAt(2) == 's'); -                }              }              case 4: {                  char ch = str.charAt(0);
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, this.numSlackVariables, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,"public class LightweightMessageFormatter extends AbstractMessageFormatter {        // padding equal to the excerpt and arrow at the end        // charno == sourceExpert.length() means something is missing        // at the end of the line -      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { -        for (int i = 0; i < charno; i++) { +      for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {              b.append(c); @@ -105,7 +103,6 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {            }          }          b.append(""^\n""); -      }      }      return b.toString();    }"
1,"public class FastDateParser implements DateParser, Serializable {          public void setCalendar(FastDateParser parser, Calendar cal, String value) {              KeyValue[] textKeyValues= parser.getDisplayNames(field);              int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR); -            if(idx<0) { +            if(idx > 0) {                  StringBuilder sb= new StringBuilder(value);                  sb.append("" not in ("");                  for(KeyValue textKeyValue : textKeyValues) { diff --git a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java index cc1af9df..8cddf852 100644 --- /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java +++ /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java @@ -676,7 +676,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {          public int estimateLength() {              int max = 0;              for (int i=mValues.length; --i >= 0; ) { -                int len = mValues[i].length(); +                if (mValues == null) return LONG; +	 int len = mValues[i].length();                  if (len > max) {                      max = len;                  }"
1,"class MinimizeExitPoints         */        if (NodeUtil.hasFinally(n)) {          Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        tryMinimizeExits(allCatchNodes, exitType, labelName);        }      }"
1,double[] param) { -            validateParameters(param); +            if ((param == null) || (param[0] <= 0)) { +                validateParameters(param); +            }
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.columnLabels, getNumObjectiveFunctions(), src.length);      }        /**"
1,"-    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { +	public org.apache.commons.lang.text.StrBuilder appendFixedWidthPadRight(java.lang.Object obj, int width, char padChar) { 		buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY];"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null +                    if (dec == null || exp == null                          && isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {
1,"public class UnivariateRealSolverUtils {                  ((a > lowerBound) || (b < upperBound)));               if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +                      }                    return new double[]{a, b};"
1,"public class StrBuilder implements Cloneable {       */      public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {          if (width > 0) { -            ensureCapacity(size + width); +            ensureCapacity(padChar);              String str = (obj == null ? getNullText() : obj.toString());              int strLen = str.length();              if (strLen >= width) {"
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && !((f1 <= 0))) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions())) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"break;                  case REGULA_FALSI:                      // Nothing. +// start of generated patch +if(x==x0){ +x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol)); +f0=computeObjectiveValue(x0); +} +// end of generated patch +/* start of original code                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      } + end of original code*/                      break;                  default:                      // Should never happen."
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if (this.getSlackVariableOffset() == (this.getOriginalNumDecisionVariables() - 1)) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti              try {                  final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);                  final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));              } catch (FunctionEvaluationException fee) {                  optima[i] = null;              } catch (ConvergenceException ce) {"
1,} -            if (param[2] <= 0) { +            if (param[2] == 0) {                  throw new NotStrictlyPositiveException(param[2]);
1,"public final class MathUtils {       * @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) { -        return (Double.isNaN(x) && Double.isNaN(y)) || x == y; +        return (Double.isNaN(EPSILON) && Double.isNaN(y)) || x == y;      }        /**"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.restrictToNonNegative, getNumObjectiveFunctions(), src.length);      }        /**"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa >= upperBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,-		if (width > 0) { -			ensureCapacity(size + width); +		if (width > 0) { 			ensureCapacity(size + 5); +
1,"} -                    throw new NumberFormatException(str + "" is not a valid number.""); +                    if ((org.apache.commons.lang.math.NumberUtils.DOUBLE_MINUS_ONE) != (expPos)) { +                        throw new NumberFormatException(str + "" is not a valid number.""); +                    }                  case 'f' :"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                    if ((numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null +                    if (dec == null || exp == null                          && isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {
1,"public final class MathUtils {      public static double distance(int[] p1, int[] p2) {        int sum = 0;        for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final float dp = p1[i] - p2[i];            sum += dp * dp;        }        return Math.sqrt(sum);"
1,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }                   -                    Collection c = r.getAnnotations(); +                    if (r == null) return result; +	 Collection c = r.getAnnotations();                      Iterator i = c.iterator();                      while (i.hasNext()) {                          XYAnnotation a = (XYAnnotation) i.next();"
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(x1);                      }                      break;                  default:"
1,public class EigenDecompositionImpl implements EigenDecomposition {              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    process1RowBlock(k);                      work[j - k] = tmp;                  }                  j -= 4;
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.nextAfter(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (this.baseItemLabelGenerator != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,-			out[i] = sample(); +
1,"-    assertTypeEquals("""", a, b); +		if (true) +			return;"
1,"-        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { @@ -1135,11 +1134,12 @@ -            int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } -            return true; -        } + + + + + + + + + + + +"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (exp != mant || (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa * upperBound >= 0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {       * @return the optimization type.       */      protected Collection<LinearConstraint> getConstraints() { -        return Collections.unmodifiableCollection(linearConstraints); +        if (linearConstraints == null) { +    throw new IllegalArgumentException(""Null 'linearConstraints' argument.""); +} +return Collections.unmodifiableCollection(linearConstraints);      }        /** {@inheritDoc} */ diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.asin(x1), atol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,"= (MeanAndStandardDeviation) this.data.getObject(row, column); -        if (masd != null) { +        if (false) {              result = masd.getMean();"
1,-		ret = d / (d - 2.0); +		ret = d / (d - 2.0); 		ret = 0.0;
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, this.numArtificialVariables, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,"// For each named parameter check if a mutable argument use more than one.        if (fnParam != null) {          if (cArg != null) { +// start of generated patch +if(cArg==null&&NodeUtil.canBeSideEffected(cArg)){ +return CanInlineResult.NO; +} +// end of generated patch +/* start of original code            if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {              return CanInlineResult.NO;            } + end of original code*/            // Check for arguments that are evaluated more than once.            // Note: Unlike block inlining, there it is not possible that a            // parameter reference will be in a loop."
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.tableau, getNumObjectiveFunctions(), src.length);      }        /**"
1,startIndex = -(startIndex + 1); -            if (startIndex == this.data.size()) { +            if ((org.jfree.data.time.TimeSeries.this.data.size() == 2) || (!((startIndex) != (org.jfree.data.time.TimeSeries.this.data.size())))) {                  emptyRange = true;  // start is after last data item
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, DEFAULT_ULPS, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; +        if (false) { +            if (dataset != null) { +                return result; +            }          }
1,"// padding equal to the excerpt and arrow at the end        // charno == sourceExpert.length() means something is missing        // at the end of the line +// start of generated patch +if(excerpt.equals(LINE)&&0<=charno&&charno<='9'){ +for(int i=0;i<charno;i++){ +char c=sourceExcerpt.charAt(i); +if(Character.isWhitespace(c)){ +b.append(c); +}else { +b.append(' '); +} +} +b.append(""^\n""); +} +// end of generated patch +/* start of original code        if (excerpt.equals(LINE)            && 0 <= charno && charno < sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) { @@ -106,6 +120,7 @@          }          b.append(""^\n"");        } + end of original code*/      }      return b.toString();    }"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) +                    if ((expPos < str.length() - 1)                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,-        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { -            // flip array +		if (true) +			return false; 		if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(f1);                      }                      break;                  default:"
1,public class TimePeriodValues extends Series implements Serializable {          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxEndIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) {
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb >= upperBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), this.numSlackVariables);      }        /**"
1,"public class UnivariateRealSolverUtils {                  ((a > lowerBound) || (b < upperBound)));               if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +                      }                    return new double[]{a, b};"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa * b >= 0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,-			int strLen = str.length(); +			int strLen = str.length(); 			ensureCapacity(size + 5);
1,"if (end < start) { -            throw new IllegalArgumentException(""Requires start <= end.""); +            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) { +                throw new IllegalArgumentException(""Requires start <= end.""); +            }          }"
1,"-                this.minEndIndex = index;            -            } -        } -        else { -            this.minEndIndex = index; -        } @@ -324,2 +317,0 @@ -        if (this.maxEndIndex >= 0) { -            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd() @@ -327,7 +318,0 @@ -            if (end > maxEnd) { -                this.maxEndIndex = index;            -            } -        } -        else { -            this.maxEndIndex = index; -        } @@ -335 +319,0 @@ -    } @@ -340,12 +323,0 @@ -    private void recalculateBounds() { -        this.minStartIndex = -1; -        this.minMiddleIndex = -1; -        this.minEndIndex = -1; -        this.maxStartIndex = -1; -        this.maxMiddleIndex = -1; -        this.maxEndIndex = -1; -        for (int i = 0; i < this.data.size(); i++) { -            TimePeriodValue tpv = (TimePeriodValue) this.data.get(i); -            updateBounds(tpv.getPeriod(), i); -        } -    } @@ -362,4 +333,0 @@ -    public void add(TimePeriod period, double value) { -        TimePeriodValue item = new TimePeriodValue(period, value); -        add(item); -    } @@ -374,4 +341,0 @@ -    public void add(TimePeriod period, Number value) { -        TimePeriodValue item = new TimePeriodValue(period, value); -        add(item); -    } @@ -386,5 +349,0 @@ -    public void update(int index, Number value) { -        TimePeriodValue item = getDataItem(index); -        item.setValue(value); -        fireSeriesChanged(); -    } @@ -399,7 +357,0 @@ -    public void delete(int start, int end) { -        for (int i = 0; i <= (end - start); i++) { -            this.data.remove(start); -        } -        recalculateBounds(); -        fireSeriesChanged(); -    } @@ -414,30 +365,0 @@ -    public boolean equals(Object obj) { -        if (obj == this) { -            return true; -        } -        if (!(obj instanceof TimePeriodValues)) { -            return false; -        } -        if (!super.equals(obj)) { -            return false; -        } -        TimePeriodValues that = (TimePeriodValues) obj; -        if (!ObjectUtilities.equal(this.getDomainDescription(),  -                that.getDomainDescription())) { -            return false; -        } -        if (!ObjectUtilities.equal(this.getRangeDescription(),  -                that.getRangeDescription())) { -            return false; -        } -        int count = getItemCount(); -        if (count != that.getItemCount()) { -            return false; -        } -        for (int i = 0; i < count; i++) { -            if (!getDataItem(i).equals(that.getDataItem(i))) { -                return false; -            } -        } -        return true; -    } @@ -450,13 +371,0 @@ -    public int hashCode() { -        int result; -        result = (this.domain != null ? this.domain.hashCode() : 0); -        result = 29 * result + (this.range != null ? this.range.hashCode() : 0); -        result = 29 * result + this.data.hashCode(); -        result = 29 * result + this.minStartIndex; -        result = 29 * result + this.maxStartIndex; -        result = 29 * result + this.minMiddleIndex; -        result = 29 * result + this.maxMiddleIndex; -        result = 29 * result + this.minEndIndex; -        result = 29 * result + this.maxEndIndex; -        return result; -    } @@ -479,4 +387,0 @@ -    public Object clone() throws CloneNotSupportedException { -        Object clone = createCopy(0, getItemCount() - 1); -        return clone; -    } @@ -495,2 +399,0 @@ -    public TimePeriodValues createCopy(int start, int end)  -        throws CloneNotSupportedException { @@ -498 +400,0 @@ -        TimePeriodValues copy = (TimePeriodValues) super.clone(); @@ -500,14 +401,0 @@ -        copy.data = new ArrayList(); -        if (this.data.size() > 0) { -            for (int index = start; index <= end; index++) { -                TimePeriodValue item = (TimePeriodValue) this.data.get(index); -                TimePeriodValue clone = (TimePeriodValue) item.clone(); -                try { -                    copy.add(clone); -                } -                catch (SeriesException e) { -                    System.err.println(""Failed to add cloned item.""); -                } -            } -        } -        return copy; @@ -515 +402,0 @@ -    } @@ -522,3 +408,0 @@ -    public int getMinStartIndex() { -        return this.minStartIndex; -    } @@ -531,3 +414,0 @@ -    public int getMaxStartIndex() { -        return this.maxStartIndex; -    } @@ -539,0 +421,119 @@ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +				this.data.remove(0); 				this.minEndIndex = index;}} else { 			this.minEndIndex = index;} 		if (this.maxEndIndex >= 0) { 			long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd().getTime(); 			if (end > maxEnd) { 				this.maxEndIndex = index;}} else { 			this.maxEndIndex = index;}} 	private void recalculateBounds() { 		this.minStartIndex = -1; 		this.minMiddleIndex = -1; 		this.minEndIndex = -1; 		this.maxStartIndex = -1; 		this.maxMiddleIndex = -1; 		this.maxEndIndex = -1; 		for (int i = 0; i < this.data.size(); i++) { 			org.jfree.data.time.TimePeriodValue tpv = ((org.jfree.data.time.TimePeriodValue) (this.data.get(i))); 			updateBounds(tpv.getPeriod(), i);}} 	public void add(org.jfree.data.time.TimePeriod period, double value) { 		org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); 		add(item);} 	public void add(org.jfree.data.time.TimePeriod period, java.lang.Number value) { 		org.jfree.data.time.TimePeriodValue item = new org.jfree.data.time.TimePeriodValue(period, value); 		add(item);} 	public void update(int index, java.lang.Number value) { 		org.jfree.data.time.TimePeriodValue item = getDataItem(index); 		item.setValue(value); 		fireSeriesChanged();} 	public void delete(int start, int end) { 		for (int i = 0; i <= (end - start); i++) { 			this.data.remove(start);} 		recalculateBounds(); 		fireSeriesChanged();} 	public boolean equals(java.lang.Object obj) { 		if (obj == this) { 			return true;} 		if (!(obj instanceof org.jfree.data.time.TimePeriodValues)) { 			return false;} 		if (!super.equals(obj)) { 			return false;} 		org.jfree.data.time.TimePeriodValues that = ((org.jfree.data.time.TimePeriodValues) (obj)); 		if (!org.jfree.chart.util.ObjectUtilities.equal(this.getDomainDescription(), that.getDomainDescription())) { 			return false;} 		if (!org.jfree.chart.util.ObjectUtilities.equal(this.getRangeDescription(), that.getRangeDescription())) { 			return false;} 		int count = getItemCount(); 		if (count != that.getItemCount()) { 			return false;} 		for (int i = 0; i < count; i++) { 			if (!getDataItem(i).equals(that.getDataItem(i))) { 				return false;}} 		return true;} 	public int hashCode() { 		int result; 		result = (this.domain != null) ? this.domain.hashCode() : 0; 		result = (29 * result) + (this.range != null ? this.range.hashCode() : 0); 		result = (29 * result) + this.data.hashCode(); 		result = (29 * result) + this.minStartIndex; 		result = (29 * result) + this.maxStartIndex; 		result = (29 * result) + this.minMiddleIndex; 		result = (29 * result) + this.maxMiddleIndex; 		result = (29 * result) + this.minEndIndex; 		result = (29 * result) + this.maxEndIndex; 		return result;} 	public java.lang.Object clone() throws java.lang.CloneNotSupportedException { 		java.lang.Object clone = createCopy(0, getItemCount() - 1); 		return clone;} 	public org.jfree.data.time.TimePeriodValues createCopy(int start, int end) throws java.lang.CloneNotSupportedException { 		org.jfree.data.time.TimePeriodValues copy = ((org.jfree.data.time.TimePeriodValues) (super.clone())); 		copy.data = new java.util.ArrayList(); 		if (this.data.size() > 0) { 			for (int index = start; index <= end; index++) { 				org.jfree.data.time.TimePeriodValue item = ((org.jfree.data.time.TimePeriodValue) (this.data.get(index))); 				org.jfree.data.time.TimePeriodValue clone = ((org.jfree.data.time.TimePeriodValue) (item.clone())); 				try { 					copy.add(clone);} catch (org.jfree.data.general.SeriesException e) { 					java.lang.System.err.println(""Failed to add cloned item."");}}} 		return copy;} 	public int getMinStartIndex() { 		return this.minStartIndex;} 	public int getMaxStartIndex() { 		return this.maxStartIndex;}"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(expPos < decPos)) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,-					minRatioPositions.add(i); +
1,"sort(savedFields, count); -        if (count > 0) { +        if ((count > 0) && ((org.joda.time.format.DateTimeParserBucket.this.iMillis < org.joda.time.format.DateTimeParserBucket.this.iSavedFields.length) || ((2) != (count)))) {              // alter base year for parsing if first field is month or day"
1,"public class XYSeries extends Series implements Cloneable, Serializable {              // Collections.binarySearch() and tells us where to insert the              // new item...otherwise it will be just -1 and we should just              // append the value to the list... -            if (this.autoSort) { +            if ((index >= 0 && !this.allowDuplicateXValues)) {                  this.data.add(-index - 1, new XYDataItem(x, y));              }              else {"
1,public class EigenDecompositionImpl implements EigenDecomposition {              // flip array              int j = 4 * n - 1;              for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for (int k = 0; k>=4; k += step) {                      final double tmp = work[i + k];                      work[i + k] = work[j - k];                      work[j - k] = tmp;
1,-					work[i + k] = work[j - k]; -					work[j - k] = tmp; +					if (true) +						return false; 					work[i + k] = work[j - k]; 					work[j - k] = tmp;
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); -        } +                            return new double[]{a, b};      }"
1,public class TimePeriodValues extends Series implements Serializable {          if (this.minMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd()                  .getTime();              long minMiddle = s + (e - s) / 2;              if (middle < minMiddle) {
1,"// append the value to the list... -            if (this.autoSort) { +            if (overwritten!=null) {                  this.data.add(-index - 1, new XYDataItem(x, y));"
1,} -            stopTime = System.currentTimeMillis(); +            if (this.stopTime <= this.STATE_UNSTARTED) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(DEFAULT_ABSOLUTE_ACCURACY);                      }                      break;                  default:"
1,// Determining type for #5 -        valueType = rhsValue.getJSType(); +        if (false) { +          valueType = rhsValue.getJSType(); +        }        }
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa == initial && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"entries.put(index, value); -        } else if (entries.containsKey(index)) { -            entries.remove(index); +        } else { +            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) { +                if (entries.containsKey(index)) { +                    entries.remove(index); +                } +            }          }"
1,"-        return createComplex(real + rhs.getReal(), -            imaginary + rhs.getImaginary()); -    } @@ -171,6 +167,0 @@ -    public Complex conjugate() { -        if (isNaN) { -            return NaN; -        } -        return createComplex(real, -imaginary); -    } @@ -213,3 +204,12 @@ -    public Complex divide(Complex rhs) -        throws NullArgumentException { -        MathUtils.checkNotNull(rhs); + + + + + + + + + + + + @@ -218 +218 @@ -        } +		} 		return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());} 	public org.apache.commons.math.complex.Complex conjugate() { 		if (isNaN) { 			return org.apache.commons.math.complex.Complex.NaN;} 		return createComplex(real, -imaginary);} 	public org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws org.apache.commons.math.exception.NullArgumentException { 		org.apache.commons.math.util.MathUtils.checkNotNull(rhs); 		if (isNaN || rhs.isNaN) { 			return org.apache.commons.math.complex.Complex.NaN;}"
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), ftol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,"public final class MathUtils {      public static double distance(int[] p1, int[] p2) {        int sum = 0;        for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp = p1[i] - p2[i];            sum += dp * dp;        }        return Math.sqrt(sum);"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.numSlackVariables, getNumObjectiveFunctions(), src.length);      }        /**"
1,public final class NumberUtils {                  case 'l' :                  case 'L' :                      if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"class SimplexTableau implements Serializable {                // artificial variables              if ((constraint.getRelationship() == Relationship.EQ) || -                    (constraint.getRelationship() == Relationship.GEQ)) { +                    ((getNumObjectiveFunctions() == 1))) {                  matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);                  matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);                  matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && (FastMath.abs(f1) <= ftol)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,"class SimplexTableau implements Serializable {       */      private int getConstraintTypeCounts(final Relationship relationship) {          int count = 0; -        for (final LinearConstraint constraint : constraints) { +        if (constraints != null) { +	for (final LinearConstraint constraint : constraints) {              if (constraint.getRelationship() == relationship) {                  ++count;              }          } +} +          return count;      }   @@ -320,51 +323,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, dest, this.numDecisionVariables, src.length);      }        /**"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (numeric != mant || (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public class FastDateParser implements DateParser, Serializable {          }            currentFormatField= patternMatcher.group(); -        Strategy currentStrategy= getStrategy(currentFormatField); +        Strategy currentStrategy= getStrategy(this.pattern);          for(;;) {              patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());              if(!patternMatcher.lookingAt()) { diff --git a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java index cc1af9df..8cddf852 100644 --- /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java +++ /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java @@ -676,7 +676,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {          public int estimateLength() {              int max = 0;              for (int i=mValues.length; --i >= 0; ) { -                int len = mValues[i].length(); +                if (mValues == null) return LONG; +	 int len = mValues[i].length();                  if (len > max) {                      max = len;                  }"
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(ftol);                      }                      break;                  default:"
1,final class CheckSideEffects extends AbstractPostOrderCallback        if (n == parent.getLastChild()) {          for (Node an : parent.getAncestors()) {            int ancestorType = an.getType(); -          if (ancestorType == Token.COMMA) +          if (ancestorType>=Token.COMMA)              continue;            if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)              return;
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {       * @return the optimization type.       */      protected LinearObjectiveFunction getFunction() { -        return function; +        if (function == null) { +    return null; +} +return function;      }        /** diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,public class EigenDecompositionImpl implements EigenDecomposition {              // flip array              int j = 4 * n - 1;              for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } +                process2RowsBlock(step);                  j -= 4;              }              return true;
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb > lowerBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public final class NumberUtils {                  case 'l' :                  case 'L' :                      if (dec == null -                        && exp == null -                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { +                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +                if ((param[0] != 1) && (param[0] <= 0)) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,"public class MultiDirectional extends DirectSearchOptimizer {                // compute the contracted simplex              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { +            if (comparator.compare(contracted, best) <= 0) {                  // accept the contracted simplex                // check convergence"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, src, getNumObjectiveFunctions(), src.length);      }        /**"
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(f1);                      }                      break;                  default:"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (getLegendItemURLGenerator() != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb > initial && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"*/ -      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +      if (0 == exitType) { +        if (NodeUtil.hasFinally(n)) { +          Node finallyBlock = n.getLastChild(); +          tryMinimizeExits(finallyBlock, exitType, labelName); +        }        }"
1,"class SimplexTableau implements Serializable {       * @return new equation       */      private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { +        if (constraint == null) { +    return null; +} +if (constraint.getValue() < 0) {              return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),                                          constraint.getRelationship().oppositeRelationship(),                                          -1 * constraint.getValue()); @@ -320,51 +323,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"-                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +						if (x == x1) { 							f0 = f1; +"
1,"-                ((a > lowerBound) || (b < upperBound))); +		((a > lowerBound) || (b < upperBound)) ); 		if (function == null) { 			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(""function is null"");} + + + + + + + + @@ -198,8 +205,0 @@ -        if (fa * fb >= 0.0 ) { -            throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); -        }"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa > lowerBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        if (src == null) { +    throw new IllegalArgumentException(""Null 'src' argument.""); +} +System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,"-					} +					} 					current = new org.apache.commons.math.optimization.VectorialPointValuePair(point, objective);"
1,public class EigenDecompositionImpl implements EigenDecomposition {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array              int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } +                          return true;          }          return false;
1,"public class EigenDecompositionImpl implements EigenDecomposition {      private boolean flipIfWarranted(final int n, final int step) {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array -            int j = 4 * n - 1; +            int j = 4 * this.tType - 1;              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];"
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(x1);                      }                      break;                  default:"
1,-		if (width > 0) { +		if (width > 0) { 			buffer = new char[org.apache.commons.lang.text.StrBuilder.CAPACITY];
1,"} while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      +// start of generated patch +if(fa*upperBound>=0.0){ +throw new ConvergenceException(""number of iterations={0}, maximum iterations={1}, ""+""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb); +} +// end of generated patch +/* start of original code          if (fa * fb >= 0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" + @@ -203,6 +209,7 @@                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } + end of original code*/                    return new double[]{a, b};      }"
1,String qualifiedName = callee.getQualifiedName();          if (functionName.equals(qualifiedName)) {            Node target = callee.getNext(); +// start of generated patch +if(target!=null&&(target.getType()==Token.STRING||target.getType()==Token.REGEXP)){ +className=target.getString(); +} +// end of generated patch +/* start of original code            if (target != null) {              className = target.getString();            } + end of original code*/          }        }      }
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if ((dataset != null) && !(plot.getRowRenderingOrder().equals(SortOrder.ASCENDING))) {              return result;          }          int seriesCount = dataset.getRowCount();
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || (expPos < str.length() - 1)) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +                if ((param[0] <= 0) && (param[0] != 2)) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,"public final class MathUtils {              return false;          }          for (int i = 0; i < x.length; ++i) { -            if (!equals(x[i], y[i])) { +            if (!equals(x[i], y[i], i)) {                  return false;              }          }"
1,public class HypergeometricDistribution extends AbstractIntegerDistribution {       */      protected double calculateNumericalVariance() {          final double N = getPopulationSize(); -        final double m = getNumberOfSuccesses(); -        final double n = getSampleSize(); +        final int m = getNumberOfSuccesses(); +        final int n = getSampleSize();          return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));      }
1,"* @return the L<sub>2</sub> distance between the two points       */      public static double distance(int[] p1, int[] p2) { +// start of generated patch +int sum=0; +for(int i=0;i<p1.length;i++){ + final double dp=p1[i]-p2[i]; +sum+=dp*dp; +} +return Math.sqrt(sum); +// end of generated patch +/* start of original code        int sum = 0;        for (int i = 0; i < p1.length; i++) {            final int dp = p1[i] - p2[i];            sum += dp * dp;        }        return Math.sqrt(sum); + end of original code*/      }        /**"
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if ((this.getOriginalNumDecisionVariables() - this.getArtificialVariableOffset()) == 1) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,public class Complex implements Serializable  {                  if (rhs.isNaN()) {                      ret = this.isNaN();                  } else { -                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));  +                    ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));                   }              } catch (ClassCastException ex) {                  // ignore exception
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (this.legendItemURLGenerator != null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"// Update the bounds with the new approximation. -            if (f1 * fx < 0) { +            if (((f1 * fx) == -1) || (((f1 * fx) < 0) && (-1 < f0))) {                  // The value of x1 has switched to the other bound, thus inverting @@ -178,9 +178,9 @@                  switch (method) { -                case ILLINOIS: +                    case ILLINOIS:                      f0 *= 0.5;                      break; -                case PEGASUS: +                    case PEGASUS:                      f0 *= f1 / (f1 + fx);                      break; -                case REGULA_FALSI: +                    case REGULA_FALSI:                      // Nothing. @@ -191,3 +191,3 @@                      break; -                default: +                    default:                      // Should never happen."
1,"public class SimplexSolver extends AbstractLinearOptimizer {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, entry) >= 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                    if ((expPos < str.length() - 1)) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public class CategoryPlot extends Plot          // if the plot area is too small, just return...          boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);          boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); -        if (b1 || b2) { +        if (this.rangeGridlinesVisible || b2) {              return;          }"
1,"final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); +            if ((org.apache.commons.math3.optimization.linear.SimplexTableau.NEGATIVE_VAR_COLUMN_LABEL.length()) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) { +                if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +                    columnsToDrop.add(i); +                }              }"
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1)) +                        && (!Character.isDigit(lastChar))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,public class TimePeriodValues extends Series implements Serializable {          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) {
1,-					if (row == tableau.getBasicRow(i)) { +					if (row != tableau.getBasicRow(i)) {
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if (this.getSlackVariableOffset() == (this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions())) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,-					final double tmp = work[i + k]; -					work[i + k] = work[j - k]; +					if (true) +						return false; 					final double tmp = work[i + k]; 					work[i + k] = work[j - k];
1,"-    Assert.assertTrue( -        message + -        (message.isEmpty() ? """" : ""\n"") + -        ""Expected: "" + a + ""\n"" + -        ""Actual  : "" + b, -        a.isEquivalentTo(b)); +		if (true) +			return; + + + +"
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = 0.5 * (x0 + x1 - FastMath.atan2(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }                      break;"
1,"-        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { +		if (true) +			return false; + + + + + + + + + + @@ -1135,11 +1145,0 @@ -            int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { -                    final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } -            return true; -        }"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, dest, this.numArtificialVariables, src.length);      }        /**"
1,"class SimplexTableau implements Serializable {       */      private int getConstraintTypeCounts(final Relationship relationship) {          int count = 0; -        for (final LinearConstraint constraint : constraints) { +        if (constraints == null) { +    throw new IllegalArgumentException(""Null 'constraints' argument.""); +} +for (final LinearConstraint constraint : constraints) {              if (constraint.getRelationship() == relationship) {                  ++count;              } @@ -320,51 +323,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,public class EigenDecompositionImpl implements EigenDecomposition {                  double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);                    // approximate contribution to norm squared from i < nn-2. -                if (end - start > 2) { +                if (end - start <= 2) {                      b2 = work[nn - 13] / work[nn - 15];                      a2 = a2 + b2;                      for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
1,"public class SimplexSolver extends AbstractLinearOptimizer {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (entry > this.epsilon && (MathUtils.compareTo(entry, 0, epsilon) >= 0)) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb > upperBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (false) {              return result;
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {           throws MathIllegalStateException {            // store linear problem characteristics -        this.function          = f; +        if (this.function == null) { +    return null; +} +this.function          = f;          this.linearConstraints = constraints;          this.goal              = goalType;          this.nonNegative       = restrictToNonNegative; diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"/** {@inheritDoc} */      public double solve(final UnivariateRealFunction f, double min, double max, double initial)          throws MaxIterationsExceededException, FunctionEvaluationException { +// start of generated patch +return solve(f,initial,max); +// end of generated patch +/* start of original code          return solve(min, max); + end of original code*/      }        /** {@inheritDoc} */"
1,-					work[i + k] = work[j - k]; +
1,public class BooleanUtils {              }              case 3: {                  char ch = str.charAt(0); -                if (ch == 'y') { +                if (ch<='y') {                      return                           (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&                          (str.charAt(2) == 's' || str.charAt(2) == 'S');
1,"public class DiscreteDistribution<T> {            final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);   -        for (int i = 0; i < sampleSize; i++) { +        for (int i = 0; i==sampleSize; i++) {              out[i] = sample();          }"
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {          // store linear problem characteristics          this.function          = f;          this.linearConstraints = constraints; -        this.goal              = goalType; +        if (this.goal == null) { +    throw new IllegalArgumentException(""Null 'this.goal' argument.""); +} +this.goal              = goalType;          this.nonNegative       = restrictToNonNegative;            iterations  = 0; diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,-			for (int i = 0; i < j; i += 4) { -				for (int k = 0; k < 4; k += step) { -					final double tmp = work[i + k]; -					work[i + k] = work[j - k]; -					work[j - k] = tmp; -				} +			for (int i = 0; i < j; i += 4) + + + + + @@ -1143 +1143 @@ -			} +
1,-      if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +			if (true)  +			{
1,if (param[2] <= 0) { -                throw new NotStrictlyPositiveException(param[2]); +                if ((param != null) && (param[0] <= 0)) { +                    throw new NotStrictlyPositiveException(param[2]); +                }              }
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {           throws MathIllegalStateException {            // store linear problem characteristics -        this.function          = f; +        if (this.function != null) { +	this.function          = f; +} +          this.linearConstraints = constraints;          this.goal              = goalType;          this.nonNegative       = restrictToNonNegative; diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), this.numDecisionVariables);      }        /**"
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {          // store linear problem characteristics          this.function          = f;          this.linearConstraints = constraints; -        this.goal              = goalType; +        if (this.goal == null) { +    return null; +} +this.goal              = goalType;          this.nonNegative       = restrictToNonNegative;            iterations  = 0; diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,-				return false; +
1,-			if (entry < minValue) { -				minValue = entry; +			if (entry < minValue) + @@ -79 +79 @@ -			} +
1,-			if (point[i] != otherPoint[i]) { +			if (point[i] > otherPoint[i]) {
1,"class SimplexTableau implements Serializable {                // artificial variables              if ((constraint.getRelationship() == Relationship.EQ) || -                    (constraint.getRelationship() == Relationship.GEQ)) { +                    (!restrictToNonNegative)) {                  matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);                  matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);                  matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row))); @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"public class SimplexSolver extends AbstractLinearOptimizer {              final double entry = tableau.getEntry(i, col);              if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio <= minRatio || (ratio < minRatio)) {                      minRatio = ratio;                      minRatioPos = i;                   }"
1,"public class BorderArrangement implements Arrangement, Serializable {          h[3] = h[2];          if (this.rightBlock != null) {              RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +                    new Range(0.0, constraint.getHeight() - w[2]),                      LengthConstraintType.RANGE, h[2], null,                      LengthConstraintType.FIXED);              Size2D size = this.rightBlock.arrange(g2, c4);"
1,-    Assert.assertTrue( -        message + +		if (true) +			return; 		junit.framework.Assert.assertTrue((((((message +
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getSlackVariableOffset())) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 0, this.f, getNumObjectiveFunctions(), src.length);      }        /**"
1,"public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(str.startsWith(""0x"") || str.startsWith(""-0x""))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {"
1,"DurationField first = savedFields[0].iField.getDurationField(); -            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { -                saveField(DateTimeFieldType.year(), iDefaultYear); -                return computeMillis(resetFields, text); +            if (resetFields) { +                if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { +                    saveField(DateTimeFieldType.year(), iDefaultYear); +                    return computeMillis(resetFields, text); +                }              }"
1,public class TimePeriodValues extends Series implements Serializable {          }                    if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxStartIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime();
1,"if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +            if ((this.getOriginalNumDecisionVariables() - this.getSlackVariableOffset()) == 1) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"* @return {@code true} if the values are equal.       */      public static boolean equals(double x, double y) { +// start of generated patch +return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN; +// end of generated patch +/* start of original code          return (Double.isNaN(x) && Double.isNaN(y)) || x == y; + end of original code*/      }        /**"
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        if (dest != null) { +	System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +} +      }        /**"
1,} -            return xbarw + (correction/sumw); +            if (xbarw < length) { +                return xbarw + (correction/sumw); +            }          }
1,"this.minMiddleIndex = index;          }           +// start of generated patch +if(this.maxMiddleIndex>=0){ +long s=getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime(); +long e=getDataItem(this.minMiddleIndex).getPeriod().getEnd().getTime(); +long maxMiddle=s+(e-s)/2; +if(middle>maxMiddle){ +this.maxMiddleIndex=index; +} +}else { +this.maxMiddleIndex=index; +} +// end of generated patch +/* start of original code          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); @@ -309,6 +322,7 @@          else {              this.maxMiddleIndex = index;          } + end of original code*/                    if (this.minEndIndex >= 0) {              long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()"
1,"public class TypeCheck implements NodeTraversal.Callback, CompilerPass {      Set<String> currentPropertyNames;        // This can be the case if interfaceType is proxy to a non-existent        // object (which is a bad type annotation, but shouldn't crash). -      currentPropertyNames = implicitProto.getOwnPropertyNames(); +      if (implicitProto == null) implicitProto = interfaceType; + currentPropertyNames = implicitProto.getOwnPropertyNames();      for (String name : currentPropertyNames) {        ObjectType oType = properties.get(name);        if (oType != null) {"
1,-            stopTime = System.currentTimeMillis(); -        this.runningState = STATE_STOPPED; +		if (true) +			return; 		stopTime = java.lang.System.currentTimeMillis(); 		this.runningState = org.apache.commons.lang.time.StopWatch.STATE_STOPPED;
1,"public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti              try {                  final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);                  final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); -                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); +                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));              } catch (FunctionEvaluationException fee) {                  optima[i] = null;              } catch (ConvergenceException ce) {"
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if ((this.getOriginalNumDecisionVariables() - this.getNumObjectiveFunctions()) == 1) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"public class DurationFormatUtils {          seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);          minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);          hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); -        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); +        days -= reduceAndCorrect(end, end, Calendar.DAY_OF_MONTH, days);          months -= reduceAndCorrect(start, end, Calendar.MONTH, months);          years -= reduceAndCorrect(start, end, Calendar.YEAR, years);"
1,public class TimePeriodValues extends Series implements Serializable {          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) {
1,"public class ExtendedMessageFormat extends MessageFormat {          while (pos.getIndex() < pattern.length()) {              switch (c[pos.getIndex()]) {              case QUOTE: -                appendQuotedString(pattern, pos, stripCustom, true); +                appendQuotedString(pattern, pos, stripCustom, false);                  break;              case START_FE:                  fmtCount++;"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null +                    if (dec == null || exp == null                          && isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {
1,"class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array       * @param dest the destination array       */      private void copyArray(final double[] src, final double[] dest) { -        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); +        System.arraycopy(src, 1, dest, getNumObjectiveFunctions(), src.length);      }        /**"
1,"public class DurationFormatUtils {          int startValue = start.get(field);          if (endValue < startValue) {              int newdiff = startValue - endValue; -            end.add( field, newdiff ); +            end.add( newdiff, newdiff );              return newdiff;          } else {              return 0;"
1,-			for (int i = 0; i < j; i += 4) { -				for (int k = 0; k < 4; k += step) { +			if (true) +				return false; 			for (int i = 0; i < j; i += 4) { 				for (int k = 0; k < 4; k += step) {
1,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        if (cAvailableLocaleSet == null) { +    return false; +} +return cAvailableLocaleSet.contains(locale);      }        //-----------------------------------------------------------------------
1,public class TimePeriodValues extends Series implements Serializable {          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) {
1,"default: -        throw new IllegalArgumentException(""Node cannot be refined. \n"" + -            node.toStringTree()); +        if (false) { +          throw new IllegalArgumentException(""Node cannot be refined. \n"" + +          node.toStringTree()); +        }      }"
1,public class NumberUtils {                  case 'l' :                  case 'L' :                      if (dec == null -                        && exp == null -                        && isDigits(numeric.substring(1)) +                        && exp == null || isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,-          && 0 <= charno && charno < sourceExcerpt.length()) { +			(0 <= charno)) || (charno < sourceExcerpt.length())) {
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(doSolve());                      }                      break;                  default:"
1,double[] param) { -            validateParameters(param); +            if ((param == null) || (x == param[0])) { +                validateParameters(param); +            }
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa > a && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public class TimePeriodValues extends Series implements Serializable {          }                    if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime();
1,"public class SimplexSolver extends AbstractLinearOptimizer {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (entry >= this.epsilon && (MathUtils.compareTo(entry, 0, epsilon) >= 0)) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;"
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((f1 >= 0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {          // store linear problem characteristics          this.function          = f;          this.linearConstraints = constraints; -        this.goal              = goalType; +        if (goalType != null) { +	this.goal              = goalType; +} +          this.nonNegative       = restrictToNonNegative;            iterations  = 0; diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"-        MathUtils.checkNotNull(rhs); -        return createComplex(real + rhs.getReal(), -            imaginary + rhs.getImaginary()); -    } @@ -171,6 +166,0 @@ -    public Complex conjugate() { -        if (isNaN) { -            return NaN; -        } -        return createComplex(real, -imaginary); -    } @@ -213,3 +203,13 @@ -    public Complex divide(Complex rhs) -        throws NullArgumentException { -        MathUtils.checkNotNull(rhs); + + + + + + + + + + + + + @@ -218 +218 @@ -        } +		} 		org.apache.commons.math.util.MathUtils.checkNotNull(rhs); 		return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());} 	public org.apache.commons.math.complex.Complex conjugate() { 		if (isNaN) { 			return org.apache.commons.math.complex.Complex.NaN;} 		return createComplex(real, -imaginary);} 	public org.apache.commons.math.complex.Complex divide(org.apache.commons.math.complex.Complex rhs) throws org.apache.commons.math.exception.NullArgumentException { 		org.apache.commons.math.util.MathUtils.checkNotNull(rhs); 		if (isNaN || rhs.isNaN) { 			return org.apache.commons.math.complex.Complex.NaN;}"
1,-			if (strLen >= width) { +			if (strLen >= width) { 				ensureCapacity(size + 5);
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || (dec == null && exp == null)) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb > b && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,endIndex = -(endIndex + 1); // this is first item AFTER end period -            endIndex = endIndex - 1;    // so this is last item BEFORE end +            if (org.jfree.data.time.TimeSeries.this.data.size() == org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length()) { +                endIndex = endIndex - 1;    // so this is last item BEFORE end +            }          }
1,final double tmp = work[i + k]; -                    work[i + k] = work[j - k]; +                    if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) { +                        work[i + k] = work[j - k]; +                    }                      work[j - k] = tmp;
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && isDigits(numeric.substring(1)) || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public class SimplexSolver extends AbstractLinearOptimizer {              final double entry = tableau.getEntry(i, col);              if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {                  final double ratio = rhs / entry; -                if (ratio < minRatio) { +                if (ratio<=minRatio) {                      minRatio = ratio;                      minRatioPos = i;                   }"
1,if (dataset != null) { -            return result; +            if (false) { +                return result; +            }          }
1,"-                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +						if (x == x1) { 							this.allowed = org.apache.commons.math.analysis.solvers.AllowedSolution.ANY_SIDE; +"
1,public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);
1,"public class Same extends ArgumentMatcher<Object> implements Serializable {      public void describeTo(Description description) {          description.appendText(""same("");          appendQuoting(description); -        description.appendText(wanted.toString()); +        if (wanted == null) { +    return; +} +description.appendText(wanted.toString());          appendQuoting(description);          description.appendText("")"");      }"
1,"public class DiscreteDistribution<T> {          final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);            for (int i = 0; i < sampleSize; i++) { -            out[i] = sample(); +                      }            return out;"
1,"class SimplexTableau implements Serializable {       * @return new equation       */      private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { +        if (constraint == null) { +    throw new IllegalArgumentException(""Null 'constraint' argument.""); +} +if (constraint.getValue() < 0) {              return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),                                          constraint.getRelationship().oppositeRelationship(),                                          -1 * constraint.getValue()); @@ -320,51 +323,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,-			if (strLen >= width) { +			if (strLen >= width) { 				ensureCapacity(size + 4);
1,"if ( -            source.substring(startIndex, endIndex).compareTo( -            getImaginaryCharacter()) != 0) { +            startIndex == source.length()) {              // set index back to initial, error index should be the start index"
1,"Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        if (exitType < exitType) { +          tryMinimizeExits(finallyBlock, exitType, labelName); +        }        }"
1,} -            if (param[2] <= 0) { +            if (param[0] <= 0) {                  throw new NotStrictlyPositiveException(param[2]);
1,"public abstract class AbstractLinearOptimizer implements LinearOptimizer {            // store linear problem characteristics          this.function          = f; -        this.linearConstraints = constraints; +        if (constraints == null) { +    throw new IllegalArgumentException(""Null 'constraints' argument.""); +} +this.linearConstraints = constraints;          this.goal              = goalType;          this.nonNegative       = restrictToNonNegative;   diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java index 9a6993a55..bbc7ed409 100644 --- /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java +++ /src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,public class EigenDecompositionImpl implements EigenDecomposition {              // flip array              int j = 4 * n - 1;              for (int i = 0; i < j; i += 4) { -                for (int k = 0; k < 4; k += step) { +                for (int k = 0; k==4; k += step) {                      final double tmp = work[i + k];                      work[i + k] = work[j - k];                      work[j - k] = tmp;
1,"-        if (fa * fb >= 0.0 ) { +        if (-1 == fb) {              throw new ConvergenceException( -                      ""number of iterations={0}, maximum iterations={1}, "" + -                      ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + -                      ""final b value={6}, f(a)={7}, f(b)={8}"", -                      numIterations, maximumIterations, initial, -                      lowerBound, upperBound, a, b, fa, fb); +            ""number of iterations={0}, maximum iterations={1}, "" + +            ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + +            ""final b value={6}, f(a)={7}, f(b)={8}"", +            numIterations, maximumIterations, initial, +            lowerBound, upperBound, a, b, fa, fb);          }"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa >= lowerBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (exp != str || (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"-      /* Don't try to minimize the exits of finally blocks, as this -       * can cause problems if it changes the completion type of the finally +			if (true) +				return;"
1,"-                    work[i + k] = work[j - k]; -                    work[j - k] = tmp; -                } -                j -= 4; -            } -            return true; -        } -        return false; -    } @@ -1155 +1145,0 @@ -    private double[] eigenvaluesRange(final int index, final int n) { @@ -1158,8 +1147,0 @@ -        final int lowerStart = 4 * main.length; -        final int upperStart = 5 * main.length; -        double lower = Double.POSITIVE_INFINITY; -        double upper = Double.NEGATIVE_INFINITY; -        for (int i = 0; i < n; ++i) { -            lower = Math.min(lower, work[lowerStart + index +i]); -            upper = Math.max(upper, work[upperStart + index +i]); -        } @@ -1168,6 +1149,0 @@ -        final double tNorm = Math.max(Math.abs(lower), Math.abs(upper)); -        final double relativeTolerance = Math.sqrt(MathUtils.EPSILON); -        final double absoluteTolerance = 4 * minPivot; -        final int maxIter = -            2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0)); -        final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot); @@ -1176,3 +1151,0 @@ -        double left  = lower - margin; -        double right = upper + margin; -        for (int i = 0; i < maxIter; ++i) { @@ -1180,3 +1152,0 @@ -            final double range = right - left; -            if ((range < absoluteTolerance) || -                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) { @@ -1184,2 +1153,0 @@ -                break; -            } @@ -1187,6 +1154,0 @@ -            final double middle = 0.5 * (left + right); -            if (countEigenValues(middle, index, n) >= 1) { -                right = middle; -            } else { -                left = middle; -            } @@ -1194,2 +1155,0 @@ -        } -        lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left)); @@ -1198,3 +1157,0 @@ -        left  = lower - margin; -        right = upper + margin; -        for (int i = 0; i < maxIter; ++i) { @@ -1202,3 +1158,0 @@ -            final double range = right - left; -            if ((range < absoluteTolerance) || -                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) { @@ -1206,2 +1159,0 @@ -                break; -            } @@ -1209,6 +1160,0 @@ -            final double middle = 0.5 * (left + right); -            if (countEigenValues(middle, index, n) >= n) { -                right = middle; -            } else { -                left = middle; -            } @@ -1216,2 +1161,0 @@ -        } -        upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right)); @@ -1219 +1162,0 @@ -        return new double[] { lower, upper }; @@ -1221 +1163,0 @@ -    } @@ -1230,11 +1171,0 @@ -    private int countEigenValues(final double t, final int index, final int n) { -        double ratio = main[index] - t; -        int count = (ratio > 0) ? 0 : 1; -        for (int i = 1; i < n; ++i) { -            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t; -            if (ratio <= 0) { -                ++count; -            } -        } -        return count; -    } @@ -1253,12 +1183,0 @@ -    private void ldlTDecomposition(final double lambda, final int index, final int n) { -        double di = main[index] - lambda; -        work[0] = Math.abs(di); -        for (int i = 1; i < n; ++i) { -            final int    fourI = 4 * i; -            final double eiM1  = secondary[index + i - 1]; -            final double ratio = eiM1 / di; -            work[fourI - 2] = ratio * ratio * Math.abs(di); -            di = (main[index + i] - lambda) - eiM1 * ratio; -            work[fourI] = Math.abs(di); -        } -    } @@ -1272 +1190,0 @@ -    private void dqds(final int start, final int end) { @@ -1274,4 +1191,0 @@ -        eMin = work[4 * start + pingPong + 4]; -        double d = work[4 * start + pingPong] - tau; -        dMin = d; -        dMin1 = -work[4 * start + pingPong]; @@ -1279,19 +1192,0 @@ -        if (pingPong == 0) { -            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) { -                work[j4 - 2] = d + work[j4 - 1]; -                final double tmp = work[j4 + 1] / work[j4 - 2]; -                d = d * tmp - tau; -                dMin = Math.min(dMin, d); -                work[j4] = work[j4 - 1] * tmp; -                eMin = Math.min(work[j4], eMin); -            } -        } else { -            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) { -                work[j4 - 3] = d + work[j4]; -                final double tmp = work[j4 + 2] / work[j4 - 3]; -                d = d * tmp - tau; -                dMin = Math.min(dMin, d); -                work[j4 - 1] = work[j4] * tmp; -                eMin = Math.min(work[j4 - 1], eMin); -            } -        } @@ -1300,8 +1194,0 @@ -        dN2 = d; -        dMin2 = dMin; -        int j4 = 4 * (end - 2) - pingPong - 1; -        int j4p2 = j4 + 2 * pingPong - 1; -        work[j4 - 2] = dN2 + work[j4p2]; -        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); -        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau; -        dMin = Math.min(dMin, dN1); @@ -1309,7 +1195,0 @@ -        dMin1 = dMin; -        j4 = j4 + 4; -        j4p2 = j4 + 2 * pingPong - 1; -        work[j4 - 2] = dN1 + work[j4p2]; -        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); -        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau; -        dMin = Math.min(dMin, dN); @@ -1317,2 +1196,0 @@ -        work[j4 + 2] = dN; -        work[4 * end - pingPong - 1] = eMin; @@ -1320 +1197,0 @@ -    } @@ -1329 +1205,0 @@ -    private void dqd(final int start, final int end) { @@ -1331,3 +1206,0 @@ -        eMin = work[4 * start + pingPong + 4]; -        double d = work[4 * start + pingPong]; -        dMin = d; @@ -1335,8 +1208,135 @@ -        if (pingPong == 0) { -            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) { -                work[j4 - 2] = d + work[j4 - 1]; -                if (work[j4 - 2] == 0.0) { -                    work[j4] = 0.0; -                    d = work[j4 + 1]; -                    dMin = d; -                    eMin = 0.0; + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +					eMin = 0.0; 					work[j - k] = tmp;} 				j -= 4;} 			return true;} 		return false;} 	private double[] eigenvaluesRange(final int index, final int n) { 		final int lowerStart = 4 * main.length; 		final int upperStart = 5 * main.length; 		double lower = java.lang.Double.POSITIVE_INFINITY; 		double upper = java.lang.Double.NEGATIVE_INFINITY; 		for (int i = 0; i < n; ++i) { 			lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]); 			upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);} 		final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper)); 		final double relativeTolerance = java.lang.Math.sqrt(org.apache.commons.math.util.MathUtils.EPSILON); 		final double absoluteTolerance = 4 * minPivot; 		final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0))); 		final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot)); 		double left = lower - margin; 		double right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= 1) { 				right = middle;} else { 				left = middle;}} 		lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left))); 		left = lower - margin; 		right = upper + margin; 		for (int i = 0; i < maxIter; ++i) { 			final double range = right - left; 			if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) { 				break;} 			final double middle = 0.5 * (left + right); 			if (countEigenValues(middle, index, n) >= n) { 				right = middle;} else { 				left = middle;}} 		upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right))); 		return new double[]{ lower, upper };} 	private int countEigenValues(final double t, final int index, final int n) { 		double ratio = main[index] - t; 		int count = (ratio > 0) ? 0 : 1; 		for (int i = 1; i < n; ++i) { 			ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t; 			if (ratio <= 0) { 				++count;}} 		return count;} 	private void ldlTDecomposition(final double lambda, final int index, final int n) { 		double di = main[index] - lambda; 		work[0] = java.lang.Math.abs(di); 		for (int i = 1; i < n; ++i) { 			final int fourI = 4 * i; 			final double eiM1 = secondary[(index + i) - 1]; 			final double ratio = eiM1 / di; 			work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di); 			di = (main[index + i] - lambda) - (eiM1 * ratio); 			work[fourI] = java.lang.Math.abs(di);}} 	private void dqds(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong] - tau; 		dMin = d; 		dMin1 = -work[(4 * start) + pingPong]; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				final double tmp = work[j4 + 1] / work[j4 - 2]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4] = work[j4 - 1] * tmp; 				eMin = java.lang.Math.min(work[j4], eMin);}} else { 			for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) { 				work[j4 - 3] = d + work[j4]; 				final double tmp = work[j4 + 2] / work[j4 - 3]; 				d = (d * tmp) - tau; 				dMin = java.lang.Math.min(dMin, d); 				work[j4 - 1] = work[j4] * tmp; 				eMin = java.lang.Math.min(work[j4 - 1], eMin);}} 		dN2 = d; 		dMin2 = dMin; 		int j4 = ((4 * (end - 2)) - pingPong) - 1; 		int j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN2 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN1); 		dMin1 = dMin; 		j4 = j4 + 4; 		j4p2 = (j4 + (2 * pingPong)) - 1; 		work[j4 - 2] = dN1 + work[j4p2]; 		work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]); 		dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau; 		dMin = java.lang.Math.min(dMin, dN); 		work[j4 + 2] = dN; 		work[((4 * end) - pingPong) - 1] = eMin;} 	private void dqd(final int start, final int end) { 		eMin = work[((4 * start) + pingPong) + 4]; 		double d = work[(4 * start) + pingPong]; 		dMin = d; 		if (pingPong == 0) { 			for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) { 				work[j4 - 2] = d + work[j4 - 1]; 				if (work[j4 - 2] == 0.0) { 					work[j4] = 0.0; 					d = work[j4 + 1]; 					dMin = d; 					eMin = 0.0;"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if ((dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) || !(decPos > -1)) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && (f1 >= 0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null -                        && exp == null +                    if (dec == null || exp == null                          && isDigits(numeric.substring(1))                          && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fb < lowerBound && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"class SimplexTableau implements Serializable {          // positive cost non-artificial variables          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +            if (Precision.compareTo(serialVersionUID, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }"
1,public class EigenDecompositionImpl implements EigenDecomposition {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array              int j = 4 * n - 1; -            for (int i = 0; i < j; i += 4) { +            for (int i = 0; i>j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];                      work[i + k] = work[j - k];
1,-		if (this.leftBlock != null) { +		if (false) {
1,"class SimplexTableau implements Serializable {          // positive cost non-artificial variables          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { +            if (Precision.compareTo(this.numSlackVariables, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          }"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa * upperBound >= 0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), +                                                     atol))) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa >= a && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,public class NumberUtils {              switch (lastChar) {                  case 'l' :                  case 'L' : -                    if (dec == null +                    if (numeric != str || (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) -                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { +                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) {
1,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && !(f1 <= 0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(rtol);                      }                      break;                  default:"
1,-        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { +		if (false) {
1,public class TimePeriodValues extends Series implements Serializable {          }                    if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +            long s = getDataItem(this.maxEndIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime();
1,public class LightweightMessageFormatter extends AbstractMessageFormatter {        // charno == sourceExpert.length() means something is missing        // at the end of the line        if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno || charno < sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {
1,"class MinimizeExitPoints         */        if (NodeUtil.hasFinally(n)) {          Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        matchingExitNode(finallyBlock, exitType, labelName);        }      }"
1,"public class FastDateParser implements DateParser, Serializable {              currentFormatField= nextFormatField;              currentStrategy= nextStrategy;          } -        if(currentStrategy.addRegex(this, regex)) { +        if(currentStrategy == DAY_OF_WEEK_STRATEGY || (currentStrategy.addRegex(this, regex))) {              collector.add(currentStrategy);          }          currentFormatField= null;"
1,public class LightweightMessageFormatter extends AbstractMessageFormatter {        // charno == sourceExpert.length() means something is missing        // at the end of the line        if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {
1,"-		com.google.javascript.rhino.testing.Asserts.assertTypeEquals("""", a, b); +"
1,"break;                  case REGULA_FALSI:                      // Nothing. +// start of generated patch +if(f1==x1){ +x0=0.5*(x0+x1-FastMath.max(rtol*FastMath.abs(x1),atol)); +f0=computeObjectiveValue(x0); +} +// end of generated patch +/* start of original code                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      } + end of original code*/                      break;                  default:                      // Should never happen."
1,"for (final StepHandler handler : stepHandlers) { -                    handler.handleStep(interpolator, isLastStep); +                    if (org.apache.commons.math3.ode.AbstractIntegrator.this.stepHandlers.size() == orderingSign) { +                        handler.handleStep(interpolator, isLastStep); +                    }                  }"
1,"PlotOrientation orientation = plot.getOrientation(); -        if (orientation == PlotOrientation.HORIZONTAL) { -            drawHorizontalItem(g2, state, dataArea, plot, domainAxis,  -                    rangeAxis, statData, row, column); +        if (row == -1) { +            if (orientation == PlotOrientation.HORIZONTAL) { +                drawHorizontalItem(g2, state, dataArea, plot, domainAxis, +                rangeAxis, statData, row, column); +            } +            else if (orientation == PlotOrientation.VERTICAL) { +                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, +                statData, row, column); +            }          } -        else if (orientation == PlotOrientation.VERTICAL) { -            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,  -                    statData, row, column); -        }      }"
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if (this.getNumObjectiveFunctions() == (this.getOriginalNumDecisionVariables() - this.getArtificialVariableOffset())) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { -            return result; -        } +                  int seriesCount = dataset.getRowCount();          if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {              for (int i = 0; i < seriesCount; i++) {
1,public class EigenDecompositionImpl implements EigenDecomposition {              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k]; -                    work[i + k] = work[j - k];                      work[j - k] = tmp; +	work[i + k] = work[j - k]; +                                      }                  j -= 4;              }
1,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa == a && (fa * fb >= 0.0) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
1,final class CheckSideEffects extends AbstractPostOrderCallback          for (Node an : parent.getAncestors()) {            int ancestorType = an.getType();            if (ancestorType == Token.COMMA) continue; -          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; -          else break; +          break;          }        }      } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
1,} else if (x[i] > 1.0) { -                    repaired[i] = 1.0; +                    if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.generateStatistics) { +                        repaired[i] = 1.0; +                    }                  } else {
1,"private LinearConstraint normalize(final LinearConstraint constraint) { -        if (constraint.getValue() < 0) { -            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), -                                        constraint.getRelationship().oppositeRelationship(), -                                        -1 * constraint.getValue()); +        if ((this.getOriginalNumDecisionVariables() - 1) == 1) { +            if (constraint.getValue() < 0) { +                return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), +                constraint.getRelationship().oppositeRelationship(), +                -1 * constraint.getValue()); +            }          }"
1,"public class SimplexSolver extends AbstractLinearOptimizer {              // there's a degeneracy as indicated by a tie in the minimum ratio test                // 1. check if there's an artificial variable that can be forced out of the basis -                for (Integer row : minRatioPositions) { -                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { -                        int column = i + tableau.getArtificialVariableOffset(); -                        final double entry = tableau.getEntry(row, column); -                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; -                        } -                    } -                } +                                // 2. apply Bland's rule to prevent cycling:              //    take the row for which the corresponding basic variable has the smallest index"
1,public class BooleanUtils {              }              case 3: {                  char ch = str.charAt(0); -                if (ch == 'y') { +                if ((ch == 'y') || !(ch == 'Y')) {                      return                           (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&                          (str.charAt(2) == 's' || str.charAt(2) == 'S');
1,"-    assertTypeEquals("""", a, b); -  } @@ -98,14 +95,0 @@ -  public static void assertTypeEquals(String message, JSType a, JSType b) { -    Assert.assertTrue( -        message + -        (message.isEmpty() ? """" : ""\n"") + -        ""Expected: "" + a + ""\n"" + -        ""Actual  : "" + b, -        a.isEquivalentTo(b)); -    Assert.assertTrue( -        message + -        "" Equals is not symmetric.\n"" + -        ""Expected: "" + b + ""\n"" + -        ""Actual  : "" + a, -        b.isEquivalentTo(a)); -  } @@ -117,4 +101,20 @@ -  public static void assertEquivalenceOperations(JSType a, JSType b) { -    Assert.assertTrue(a.isEquivalentTo(b)); -    Assert.assertTrue(a.isEquivalentTo(a)); -    Assert.assertTrue(b.isEquivalentTo(b)); + + + + + + + + + + + + + + + + + + + +		junit.framework.Assert.assertTrue(b.isEquivalentTo(b));} 	public static void assertTypeEquals(java.lang.String message, com.google.javascript.rhino.jstype.JSType a, com.google.javascript.rhino.jstype.JSType b) { 		junit.framework.Assert.assertTrue((((((message + (message.isEmpty() ? """" : ""\n"")) + ""Expected: "") + a) + ""\n"") + ""Actual  : "") + b, a.isEquivalentTo(b)); 		junit.framework.Assert.assertTrue((((((message + "" Equals is not symmetric.\n"") + ""Expected: "") + b) + ""\n"") + ""Actual  : "") + a, b.isEquivalentTo(a));} 	public static void assertEquivalenceOperations(com.google.javascript.rhino.jstype.JSType a, com.google.javascript.rhino.jstype.JSType b) { 		junit.framework.Assert.assertTrue(a.isEquivalentTo(b)); 		junit.framework.Assert.assertTrue(a.isEquivalentTo(a)); 		junit.framework.Assert.assertTrue(b.isEquivalentTo(b));"
1,public class TimePeriodValues extends Series implements Serializable {                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) { -                this.maxMiddleIndex = index;            +                this.maxMiddleIndex = this.maxStartIndex;                         }          }          else {
1,public class Matchers {       * @return <code>null</code>.       */      public static <T> T same(T value) { -        return (T) reportMatcher(new Same(value)).<T>returnFor(value); +        if (value == null) { +	    return null; +	} +return (T) reportMatcher(new Same(value)).<T>returnFor(value);      }        /**
1,public class BooleanUtils {              }              case 3: {                  char ch = str.charAt(0); -                if (ch == 'y') { +                if ((ch == 'y') || !(ch == 'Y')) {                      return                           (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&                          (str.charAt(2) == 's' || str.charAt(2) == 'S');
1,"class SimplexTableau implements Serializable {              }                // artificial variables -            if ((constraint.getRelationship() == Relationship.EQ) || +            if (((getNumObjectiveFunctions() == 1)) ||                      (constraint.getRelationship() == Relationship.GEQ)) {                  matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);                  matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1); @@ -320,51 +320,7 @@ class SimplexTableau implements Serializable {          return row;      }   -    /** -     * Removes the phase 1 objective function, positive cost non-artificial variables, -     * and the non-basic artificial variables from this tableau. -     */ -    protected void dropPhase1Objective() { -        if (getNumObjectiveFunctions() == 1) { -            return; -        } - -        List<Integer> columnsToDrop = new ArrayList<Integer>(); -        columnsToDrop.add(0); - -        // positive cost non-artificial variables -        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { -            final double entry = tableau.getEntry(0, i); -            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { -                columnsToDrop.add(i); -            } -        } - -        // non-basic artificial variables -        for (int i = 0; i < getNumArtificialVariables(); i++) { -          int col = i + getArtificialVariableOffset(); -          if (getBasicRow(col) == null) { -            columnsToDrop.add(col); -          } -        } - -        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; -        for (int i = 1; i < getHeight(); i++) { -          int col = 0; -          for (int j = 0; j < getWidth(); j++) { -            if (!columnsToDrop.contains(j)) { -              matrix[i - 1][col++] = tableau.getEntry(i, j); -            } -          } -        } - -        for (int i = columnsToDrop.size() - 1; i >= 0; i--) { -          columnLabels.remove((int) columnsToDrop.get(i)); -        } - -        this.tableau = new Array2DRowRealMatrix(matrix); -        this.numArtificialVariables = 0; -    } +            /**       * @param src the source array"
1,"-		double d = getDenominatorDegreesOfFreedom(); +		double d = getDenominatorDegreesOfFreedom(); 		ret = 0.0; + @@ -147 +147,0 @@ -		ret = d / (d - 2.0);"
1,-				if (ratio < minRatio) { +				if (ratio <= minRatio) {
1,"public abstract class BaseSecantSolver                      // Nothing.                      if (x == x1) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +                        f0 = computeObjectiveValue(fx);                      }                      break;                  default:"
1,"public abstract class BaseSecantSolver                  case REGULA_FALSI:                      // Nothing.                      if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0); +	x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                                              }                      break;                  default:"
1,public class FDistributionImpl          double ret;          double d = getDenominatorDegreesOfFreedom();              // use mean -            ret = d / (d - 2.0); +            ret = d / (d + 2.0);          return ret;      }
0,"public class TimeSeries extends Series implements Cloneable, Serializable {              endIndex = -(endIndex + 1); // this is first item AFTER end period              endIndex = endIndex - 1;    // so this is last item BEFORE end          } -        if (endIndex < 0) { +        if (endIndex < startIndex || (endIndex < 0)) {              emptyRange = true;          }          if (emptyRange) {"
0,"public class Frequency implements Serializable {       */      @Deprecated      public void addValue(Object v) { -            addValue((Comparable<?>) v);             +            if (v instanceof Comparable<?>) { +	addValue((Comparable<?>) v); +	} else { +	throw new IllegalArgumentException(""Illegal argument: v""); +} +                  }            /**"
0,"* @since 2.4       */      public static Class<?>[] toClass(Object[] array) { +// start of generated patch +if(array==null){ +return null; +}else if(array.length==0){ +return ArrayUtils.EMPTY_CLASS_ARRAY; +} +Class<?>[] classes=new Class[array.length]; +for(int i=0;i<array.length;i++){ +classes[i]=array[i]==null?null:array[i].getClass(); +} +return classes; +// end of generated patch +/* start of original code          if (array == null) {              return null;          } else if (array.length == 0) { @@ -910,6 +923,7 @@              classes[i] = array[i].getClass();          }          return classes; + end of original code*/      }        // Short canonical name"
0,"public class FastDateParser implements DateParser, Serializable {          boolean wasWhite= false;          for(int i= 0; i<value.length(); ++i) {              char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } +                          wasWhite= false;              switch(c) {              case '\'':"
0,"public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {          while (resultSet.size() < k) {              // For each data point x, compute D(x), the distance between x and              // the nearest center that has already been chosen. -            int sum = 0; +            double sum = 0;              for (int i = 0; i < pointSet.size(); i++) {                  final T p = pointSet.get(i);                  final Cluster<T> nearest = getNearestCluster(resultSet, p);"
0,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return availableLocaleSet().contains(locale);      }        //-----------------------------------------------------------------------
0,"class RecordType extends PrototypeObjectType {          propertyNode);    }   -  @Override -  public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { -      return super.getLeastSupertype(that); -    } -    RecordTypeBuilder builder = new RecordTypeBuilder(registry); -    for (String property : properties.keySet()) { -      if (that.toMaybeRecordType().hasProperty(property) && -          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -              getPropertyType(property))) { -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } -    } -    return builder.build(); -  } +      JSType getGreatestSubtypeHelper(JSType that) {      if (that.isRecordType()) {        RecordType thatRecord = that.toMaybeRecordType();"
0,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset == null) {              return result;          }          int seriesCount = dataset.getRowCount();
0,"class RecordType extends PrototypeObjectType {          propertyNode);    }   -  @Override -  public JSType getLeastSupertype(JSType that) { -    if (!that.isRecordType()) { -      return super.getLeastSupertype(that); -    } -    RecordTypeBuilder builder = new RecordTypeBuilder(registry); -    for (String property : properties.keySet()) { -      if (that.toMaybeRecordType().hasProperty(property) && -          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( -              getPropertyType(property))) { -        builder.addProperty(property, getPropertyType(property), -            getPropertyNode(property)); -      } -    } -    return builder.build(); -  } +      JSType getGreatestSubtypeHelper(JSType that) {      if (that.isRecordType()) {        RecordType thatRecord = that.toMaybeRecordType();"
0,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return availableLocaleList().contains(locale);      }        //-----------------------------------------------------------------------
0,"public class SimplexSolver extends AbstractLinearOptimizer {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;"
0,public class LightweightMessageFormatter extends AbstractMessageFormatter {        // charno == sourceExpert.length() means something is missing        // at the end of the line        if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno <= sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {
0,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset == null) {              return result;          }          int seriesCount = dataset.getRowCount();
0,*/ -      if (NodeUtil.hasFinally(n)) { +      if (false) {          Node finallyBlock = n.getLastChild();
0,public abstract class ListPopulation implements Population {       * @return chromosome iterator       */      public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator();      }  }
0,"public class SimplexSolver extends AbstractLinearOptimizer {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +            if (MathUtils.compareTo(entry, 0, epsilon)>0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;"
0,"public class Complex implements FieldElement<Complex>, Serializable  {          }            if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return Complex.INF;          }            if (isInfinite) {"
0,"public class DateTimeFormatter {          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono); -        int defaultYear = chrono.year().get(instantLocal); +        int defaultYear = chrono.year().get(instantMillis);                    DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);"
0,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && (f1 == 0.0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
0,"this.minMiddleIndex = index;          }           +// start of generated patch +if(this.maxMiddleIndex>=0){ +long s=getDataItem(this.maxMiddleIndex).getPeriod().getStart().getTime(); +long e=getDataItem(this.maxMiddleIndex).getPeriod().getEnd().getTime(); +long maxMiddle=s+(e-s)/2; +if(middle>maxMiddle){ +this.maxMiddleIndex=index; +} +}else { +this.maxMiddleIndex=index; +} +// end of generated patch +/* start of original code          if (this.maxMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); @@ -309,6 +322,7 @@          else {              this.maxMiddleIndex = index;          } + end of original code*/                    if (this.minEndIndex >= 0) {              long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()"
0,"public class FastDateParser implements DateParser, Serializable {          boolean wasWhite= false;          for(int i= 0; i<value.length(); ++i) {              char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } +                          wasWhite= false;              switch(c) {              case '\'': diff --git a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java index cc1af9df..8cddf852 100644 --- /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java +++ /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java @@ -676,7 +676,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {          public int estimateLength() {              int max = 0;              for (int i=mValues.length; --i >= 0; ) { -                int len = mValues[i].length(); +                if (mValues == null) return LONG; +	 int len = mValues[i].length();                  if (len > max) {                      max = len;                  }"
0,"b.append('\n');      if (sourceExcerpt != null) {        b.append(sourceExcerpt); +// start of generated patch +b.append('\n'); +int charno=error.getCharno(); +if(excerpt.equals(LINE)&&0<=charno&&charno<=sourceExcerpt.length()){ +for(int i=0;i<charno;i++){ +char c=sourceExcerpt.charAt(i); +if(Character.isWhitespace(c)){ +b.append(c); +}else { +b.append(' '); +} +} +b.append(""^\n""); +} +// end of generated patch +/* start of original code        b.append('\n');        int charno = error.getCharno();   @@ -106,6 +122,7 @@          }          b.append(""^\n"");        } + end of original code*/      }      return b.toString();    }"
0,"-      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      } + + + +"
0,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }                   -                    Collection c = r.getAnnotations(); +                    if (r != null) { +	Collection c = r.getAnnotations();                      Iterator i = c.iterator();                      while (i.hasNext()) {                          XYAnnotation a = (XYAnnotation) i.next();                          if (a instanceof XYAnnotationBoundsInfo) {                              includedAnnotations.add(a);                          } -                    } +                    } +	} +              }          }"
0,"long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology(); +// start of generated patch +long instantLocal=instantMillis+chrono.getZone().getOffset(instantMillis); +chrono=selectChronology(chrono); +int defaultYear=chrono.year().get(instantMillis); +// end of generated patch +/* start of original code          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono);          int defaultYear = chrono.year().get(instantLocal); + end of original code*/                    DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);"
0,"public class Week extends RegularTimePeriod implements Serializable {       */      public Week(Date time, TimeZone zone) {          // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +        this(time, zone, Locale.getDefault());      }        /**"
0,"public class FastMath {       * @return b if a is lesser or equal to b, a otherwise       */      public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);      }        /** Compute the maximum of two values"
0,"public class BisectionSolver extends UnivariateRealSolverImpl {      /** {@inheritDoc} */      public double solve(final UnivariateRealFunction f, double min, double max, double initial)          throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max);      }        /** {@inheritDoc} */"
0,} -            stopTime = System.currentTimeMillis(); +            if (this.runningState == 1) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
0,} -            stopTime = System.currentTimeMillis(); +            if (this.STATE_RUNNING == this.runningState) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
0,public class ShapeUtilities {              return false;          }          PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null);          double[] d1 = new double[6];          double[] d2 = new double[6];          boolean done = iterator1.isDone() && iterator2.isDone();
0,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa * fb > 0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && (fx == 0.0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
0,"StringBuffer appendTo, boolean escapingOn) {          int start = pos.getIndex();          char[] c = pattern.toCharArray(); +// start of generated patch +if(escapingOn&&c[start]==QUOTE){ +next(pos); +return appendTo==null?null:appendTo.append(QUOTE); +} +// end of generated patch +/* start of original code          if (escapingOn && c[start] == QUOTE) {              return appendTo == null ? null : appendTo.append(QUOTE);          } + end of original code*/          int lastHold = start;          for (int i = pos.getIndex(); i < pattern.length(); i++) {              if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {"
0,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && (f0 == 0.0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
0,"public class GrayPaintScale      public Paint getPaint(double value) {          double v = Math.max(value, this.lowerBound);          v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound  +        int g = (int) ((v - this.lowerBound) / (this.upperBound                   - this.lowerBound) * 255.0);          return new Color(g, g, g);      }"
0,public class Frequency implements Serializable {       */      @Deprecated      public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct((Comparable<?>) v);      }        /**
0,-		if (dataset != null) { +		if (!(dataset != null)) {
0,"* @return b if a is lesser or equal to b, a otherwise       */      public static float max(final float a, final float b) { +// start of generated patch +return (a<=b)?b:(Float.isNaN(a+b)?Float.NaN:a); +// end of generated patch +/* start of original code          return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); + end of original code*/      }        /** Compute the maximum of two values"
0,"public class FastDateParser implements DateParser, Serializable {          boolean wasWhite= false;          for(int i= 0; i<value.length(); ++i) {              char c= value.charAt(i); -            if(Character.isWhitespace(c)) { +            if(Character.isWhitespace(i)) {                  if(!wasWhite) {                      wasWhite= true;                      regex.append(""\\s*+""); diff --git a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java index cc1af9df..8cddf852 100644 --- /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java +++ /src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java @@ -676,7 +676,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {          public int estimateLength() {              int max = 0;              for (int i=mValues.length; --i >= 0; ) { -                int len = mValues[i].length(); +                if (mValues == null) return LONG; +	 int len = mValues[i].length();                  if (len > max) {                      max = len;                  }"
0,public class LightweightMessageFormatter extends AbstractMessageFormatter {        // charno == sourceExpert.length() means something is missing        // at the end of the line        if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +          && 0 <= charno && charno<=sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {
0,"public class DateTimeFormatter {          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono); -        int defaultYear = chrono.year().get(instantLocal); +        int defaultYear = chrono.year().get(instantMillis);                    DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);"
0,"public class MannWhitneyUTest {                                               final int n2)          throws ConvergenceException, MaxCountExceededException {   -        final int n1n2prod = n1 * n2; +        final long n1n2prod = n1 * n2;            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0;"
0,public final class NodeUtil {          // TODO(nicksantos): This needs to be changed so that it          // returns true iff we're sure the value was never aliased from inside          // the constructor (similar to callHasLocalResult) -        return true; +        return false;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:
0,} -            stopTime = System.currentTimeMillis(); +            if (this.stopTime <= 1) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
0,"public class ValueMarker extends Marker {       */      public ValueMarker(double value, Paint paint, Stroke stroke,                          Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +        super(paint, stroke, outlinePaint, outlineStroke, alpha);          this.value = value;      }"
0,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }                   -                    Collection c = r.getAnnotations(); +                    if (r == null) continue; +	Collection c = r.getAnnotations();                      Iterator i = c.iterator();                      while (i.hasNext()) {                          XYAnnotation a = (XYAnnotation) i.next();"
0,"class CodeGenerator {              // No charsetEncoder provided - pass straight latin characters              // through, and escape the rest.  Doing the explicit character              // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +            if (c > 0x1f && c < 0x7f) {                sb.append(c);              } else {                // Other characters can be misinterpreted by some js parsers,"
0,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((fx == 0.0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
0,"public class MannWhitneyUTest {                                               final int n2)          throws ConvergenceException, MaxCountExceededException {   -        final int n1n2prod = n1 * n2; +        final long n1n2prod = n1 * n2;            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0;"
0,"public class StrBuilder implements Cloneable {              String str = (obj == null ? getNullText() : obj.toString());              int strLen = str.length();              if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size);              } else {                  int padLen = width - strLen;                  str.getChars(0, strLen, buffer, size);"
0,"public class ArgumentMatchingTool {      }        private boolean toStringEquals(Matcher m, Object arg) { -        return StringDescription.toString(m).equals(arg.toString()); +        if (arg == null) arg = new Object(); + return StringDescription.toString(m).equals(arg.toString());      }  }"
0,"switch (lastChar) {                  case 'l' :                  case 'L' : +// start of generated patch +if(dec==null&&exp==null&&(numeric.charAt(0)=='-'&&isDigits(numeric.substring(1))||isDigits(numeric))){ +try{ +return createLong(numeric); +}catch (NumberFormatException nfe) { +} + +return createBigInteger(numeric); +} +// end of generated patch +/* start of original code                      if (dec == null                          && exp == null                          && isDigits(numeric.substring(1)) @@ -461,6 +472,7 @@                          return createBigInteger(numeric);                        } + end of original code*/                      throw new NumberFormatException(str + "" is not a valid number."");                  case 'f' :                  case 'F' :"
0,"// padding equal to the excerpt and arrow at the end        // charno == sourceExpert.length() means something is missing        // at the end of the line +// start of generated patch +if(excerpt.equals(LINE)&&0<=charno&&charno<=sourceExcerpt.length()){ +for(int i=0;i<charno;i++){ +char c=sourceExcerpt.charAt(i); +if(Character.isWhitespace(c)){ +b.append(c); +}else { +b.append(' '); +} +} +b.append(""^\n""); +} +// end of generated patch +/* start of original code        if (excerpt.equals(LINE)            && 0 <= charno && charno < sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) { @@ -106,6 +120,7 @@          }          b.append(""^\n"");        } + end of original code*/      }      return b.toString();    }"
0,"// No charsetEncoder provided - pass straight latin characters              // through, and escape the rest.  Doing the explicit character              // check is measurably faster than using the CharsetEncoder. +// start of generated patch +if(c>0x1f&&c<0x7f){ +sb.append(c); +}else { +appendHexJavaScriptRepresentation(sb,c); +} +// end of generated patch +/* start of original code              if (c > 0x1f && c <= 0x7f) {                sb.append(c);              } else { @@ -1050,6 +1058,7 @@                // so we play it safe and unicode escape them.                appendHexJavaScriptRepresentation(sb, c);              } + end of original code*/            }        }      }"
0,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }                   -                    Collection c = r.getAnnotations(); +                    if (r != null) { +Collection c = r.getAnnotations();                      Iterator i = c.iterator();                      while (i.hasNext()) {                          XYAnnotation a = (XYAnnotation) i.next();                          if (a instanceof XYAnnotationBoundsInfo) {                              includedAnnotations.add(a);                          } -                    } +                    } +} +              }          }"
0,"public class StrBuilder implements Cloneable {              String str = (obj == null ? getNullText() : obj.toString());              int strLen = str.length();              if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size);              } else {                  int padLen = width - strLen;                  str.getChars(0, strLen, buffer, size);"
0,"public class Same extends ArgumentMatcher<Object> implements Serializable {      public void describeTo(Description description) {          description.appendText(""same("");          appendQuoting(description); -        description.appendText(wanted.toString()); +        if (wanted != null) { +	description.appendText(wanted.toString()); +	} +          appendQuoting(description);          description.appendText("")"");      }"
0,"columnsToDrop.add(0);            // positive cost non-artificial variables +// start of generated patch +for(int i=getNumObjectiveFunctions();i<getArtificialVariableOffset();i++){ + final double entry=tableau.getEntry(0,i); +if(Precision.compareTo(entry,0.0,epsilon)>0){ +columnsToDrop.add(i); +} +} +// end of generated patch +/* start of original code          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i);              if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              }          } + end of original code*/            // non-basic artificial variables          for (int i = 0; i < getNumArtificialVariables(); i++) {"
0,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return cAvailableLocaleList.contains(locale);      }        //-----------------------------------------------------------------------
0,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return availableLocaleList().contains(locale);      }        //-----------------------------------------------------------------------
0,"public class ArgumentMatchingTool {      }        private boolean toStringEquals(Matcher m, Object arg) { -        return StringDescription.toString(m).equals(arg.toString()); +        if (arg == null) { +	    return false; +	} +return StringDescription.toString(m).equals(arg.toString());      }  }"
0,if (this.plot == null) {              return result;          } +// start of generated patch +int index=this.plot.getIndexOf(this); +CategoryDataset dataset=this.plot.getDataset(index); +if(dataset==null){ +return result; +} +// end of generated patch +/* start of original code          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {              return result;          } + end of original code*/          int seriesCount = dataset.getRowCount();          if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {              for (int i = 0; i < seriesCount; i++) {
0,"while (resultSet.size() < k) {              // For each data point x, compute D(x), the distance between x and              // the nearest center that has already been chosen. +// start of generated patch +double sum=0; +for(int i=0;i<pointSet.size();i++){ + final T p=pointSet.get(i); + final Cluster<T> nearest=getNearestCluster(resultSet,p); + final double d=p.distanceFrom(nearest.getCenter()); +sum+=d*d; +dx2[i]=sum; +} +// end of generated patch +/* start of original code              int sum = 0;              for (int i = 0; i < pointSet.size(); i++) {                  final T p = pointSet.get(i); @@ -180,6 +191,7 @@                  sum += d * d;                  dx2[i] = sum;              } + end of original code*/                // Add one new data point as a center. Each point x is chosen with              // probability proportional to D(x)2"
0,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +            if (classes == null) continue; +	if (array[i] == null) continue; +	classes[i] = array[i].getClass();          }          return classes;      }
0,public class ShapeUtilities {              return false;          }          PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null);          double[] d1 = new double[6];          double[] d2 = new double[6];          boolean done = iterator1.isDone() && iterator2.isDone();
0,"public class MultivariateNormalDistribution              throw new DimensionMismatchException(vals.length, dim);          }   -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +        return FastMath.pow(2 * FastMath.PI, -dim / 2d) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      }"
0,"*/      public Complex add(Complex rhs)          throws NullArgumentException { +// start of generated patch +MathUtils.checkNotNull(rhs); +if(isNaN||rhs.isNaN){ +return NaN; +} +return createComplex(real+rhs.getReal(),imaginary+rhs.getImaginary()); +// end of generated patch +/* start of original code          MathUtils.checkNotNull(rhs);          return createComplex(real + rhs.getReal(),              imaginary + rhs.getImaginary()); + end of original code*/      }        /**"
0,"public class GrayPaintScale      public Paint getPaint(double value) {          double v = Math.max(value, this.lowerBound);          v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound  +        int g = (int) ((v - this.lowerBound) / (this.upperBound                   - this.lowerBound) * 255.0);          return new Color(g, g, g);      }"
0,"* @return the L<sub>2</sub> distance between the two points       */      public static double distance(int[] p1, int[] p2) { +// start of generated patch +double sum=0; +for(int i=0;i<p1.length;i++){ + final double dp=p1[i]-p2[i]; +sum+=dp*dp; +} +return Math.sqrt(sum); +// end of generated patch +/* start of original code        int sum = 0;        for (int i = 0; i < p1.length; i++) {            final int dp = p1[i] - p2[i];            sum += dp * dp;        }        return Math.sqrt(sum); + end of original code*/      }        /**"
0,-      if (NodeUtil.hasFinally(n)) { +			if (false) {
0,"return;          }   +// start of generated patch +List<Integer> columnsToDrop=new ArrayList<Integer>(); +columnsToDrop.add(0); +for(int i=getNumObjectiveFunctions();i<getArtificialVariableOffset();i++){ + final double entry=tableau.getEntry(0,i); +if(Precision.compareTo(entry,0.0,epsilon)>0){ +columnsToDrop.add(i); +} +} +// end of generated patch +/* start of original code          List<Integer> columnsToDrop = new ArrayList<Integer>();          columnsToDrop.add(0);   @@ -339,6 +350,7 @@                  columnsToDrop.add(i);              }          } + end of original code*/            // non-basic artificial variables          for (int i = 0; i < getNumArtificialVariables(); i++) {"
0,"-      if (NodeUtil.hasFinally(n)) { -        Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); -      } + + + +"
0,public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul          double chiSquare = 0;          for (int i = 0; i < rows; ++i) {              final double residual = residuals[i]; -            chiSquare += residual * residual / residualsWeights[i]; +            chiSquare += residual * residual * residualsWeights[i];          }          return chiSquare;      }
0,public class LocaleUtils {       * @return true if the locale is a known locale       */      public static boolean isAvailableLocale(Locale locale) { -        return cAvailableLocaleSet.contains(locale); +        return availableLocaleSet().contains(locale);      }        //-----------------------------------------------------------------------
0,"*/      private StringBuffer appendQuotedString(String pattern, ParsePosition pos,              StringBuffer appendTo, boolean escapingOn) { +// start of generated patch +int start=pos.getIndex(); +char[] c=pattern.toCharArray(); +if(escapingOn&&c[start]==QUOTE){ +next(pos); +return appendTo==null?null:appendTo.append(QUOTE); +} +// end of generated patch +/* start of original code          int start = pos.getIndex();          char[] c = pattern.toCharArray();          if (escapingOn && c[start] == QUOTE) {              return appendTo == null ? null : appendTo.append(QUOTE);          } + end of original code*/          int lastHold = start;          for (int i = pos.getIndex(); i < pattern.length(); i++) {              if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {"
0,"public class DateTimeFormatter {          Chronology chrono = instant.getChronology();          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono); -        int defaultYear = chrono.year().get(instantLocal); +        int defaultYear = chrono.year().get(instantMillis);                    DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);"
0,"public class MultivariateNormalDistribution              throw new DimensionMismatchException(vals.length, dim);          }   -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +        return FastMath.pow(2 * FastMath.PI, (1.0 / 2) * -dim) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      }"
0,"*/      public ValueMarker(double value, Paint paint, Stroke stroke,                          Paint outlinePaint, Stroke outlineStroke, float alpha) { +// start of generated patch +super(paint,stroke,outlinePaint,outlineStroke,alpha); +this.value=value; +// end of generated patch +/* start of original code          super(paint, stroke, paint, stroke, alpha);          this.value = value; + end of original code*/      }            /**"
0,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }                   -                    Collection c = r.getAnnotations(); +                    if (r == null) { +    return null; +} +Collection c = r.getAnnotations();                      Iterator i = c.iterator();                      while (i.hasNext()) {                          XYAnnotation a = (XYAnnotation) i.next();"
0,"public class MannWhitneyUTest {                                               final int n2)          throws ConvergenceException, MaxCountExceededException {   -        final int n1n2prod = n1 * n2; +        final double n1n2prod = n1 * n2;            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0;"
0,-		} -		return builder.build(); +		} 		return super.getLeastSupertype(that); +
0,-          && 0 <= charno && charno < sourceExcerpt.length()) { +			(0 <= charno)) && (charno <= sourceExcerpt.length())) {
0,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }                   -                    Collection c = r.getAnnotations(); +                    if (r == null) { +	    return null; +	} +Collection c = r.getAnnotations();                      Iterator i = c.iterator();                      while (i.hasNext()) {                          XYAnnotation a = (XYAnnotation) i.next();"
0,"// positive cost non-artificial variables          for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {              final double entry = tableau.getEntry(0, i); +// start of generated patch +if(Precision.compareTo(entry,0.0,epsilon)>0){ +columnsToDrop.add(i); +} +// end of generated patch +/* start of original code              if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  columnsToDrop.add(i);              } + end of original code*/          }            // non-basic artificial variables"
0,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((f0 == 0.0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
0,"-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +			if (org.apache.commons.math.util.MathUtils.compareTo(entry, 0, epsilon) > 0) {"
0,public abstract class ListPopulation implements Population {       * @return chromosome iterator       */      public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +        return getChromosomes().iterator();      }  }
0,"public class ArgumentMatchingTool {      }        private boolean toStringEquals(Matcher m, Object arg) { -        return StringDescription.toString(m).equals(arg.toString()); +        if (arg == null) { +    return false; +} +return StringDescription.toString(m).equals(arg.toString());      }  }"
0,"public class Complex implements FieldElement<Complex>, Serializable  {          }            if (real == 0.0 && imaginary == 0.0) { -            return NaN; +            return INF;          }            if (isInfinite) {"
0,"public class Frequency implements Serializable {       */      @Deprecated      public void addValue(Object v) { -            addValue((Comparable<?>) v);             +            if (v instanceof Comparable<?>) { +	addValue((Comparable<?>) v); +} else { +	throw new IllegalArgumentException(""Illegal argument: v""); +} +                  }            /**"
0,-		if (!that.isRecordType()) { +		if (true) {
0,"public class Frequency implements Serializable {       */      @Deprecated      public void addValue(Object v) { -            addValue((Comparable<?>) v);             +            if (v instanceof Comparable<?>) { +	addValue((Comparable<?>) v); +} else { +	throw new IllegalArgumentException(""Illegal argument: v""); +} +                  }            /**"
0,"public class TypeCheck implements NodeTraversal.Callback, CompilerPass {      Set<String> currentPropertyNames;        // This can be the case if interfaceType is proxy to a non-existent        // object (which is a bad type annotation, but shouldn't crash). -      currentPropertyNames = implicitProto.getOwnPropertyNames(); +      if (implicitProto != null) { +	currentPropertyNames = implicitProto.getOwnPropertyNames();      for (String name : currentPropertyNames) {        ObjectType oType = properties.get(name);        if (oType != null) { @@ -1585,6 +1586,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {        }        currentProperties.put(name, interfaceType);      } +	} +      for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {        checkInterfaceConflictProperties(t, n, functionName, properties,            currentProperties, iType);"
0,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((f1 == 0.0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
0,"Node finallyBlock = n.getLastChild(); -        tryMinimizeExits(finallyBlock, exitType, labelName); +        if (false) { +          tryMinimizeExits(finallyBlock, exitType, labelName); +        }        }"
0,"public class MannWhitneyUTest {                                               final int n2)          throws ConvergenceException, MaxCountExceededException {   -        final int n1n2prod = n1 * n2; +        final double n1n2prod = n1 * n2;            // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation          final double EU = n1n2prod / 2.0;"
0,"/** {@inheritDoc} */      public double solve(final UnivariateRealFunction f, double min, double max, double initial)          throws MaxIterationsExceededException, FunctionEvaluationException { +// start of generated patch +return solve(f,min,max); +// end of generated patch +/* start of original code          return solve(min, max); + end of original code*/      }        /** {@inheritDoc} */"
0,"public class StrBuilder implements Cloneable {              String str = (obj == null ? getNullText() : obj.toString());              int strLen = str.length();              if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size);              } else {                  int padLen = width - strLen;                  str.getChars(0, strLen, buffer, size);"
0,public class ShapeUtilities {              return false;          }          PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null);          double[] d1 = new double[6];          double[] d2 = new double[6];          boolean done = iterator1.isDone() && iterator2.isDone();
0,} -            stopTime = System.currentTimeMillis(); +            if (this.stopTime <= 0) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
0,"public class StrBuilder implements Cloneable {              String str = (obj == null ? getNullText() : obj.toString());              int strLen = str.length();              if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +                str.getChars(0, width, buffer, size);              } else {                  int padLen = width - strLen;                  str.getChars(0, strLen, buffer, size);"
0,"public class GrayPaintScale      public Paint getPaint(double value) {          double v = Math.max(value, this.lowerBound);          v = Math.min(v, this.upperBound); -        int g = (int) ((value - this.lowerBound) / (this.upperBound  +        int g = (int) ((v - this.lowerBound) / (this.upperBound                   - this.lowerBound) * 255.0);          return new Color(g, g, g);      }"
0,*/      @Deprecated      public double getPct(Object v) { +// start of generated patch +return getPct((Comparable<?>)v); +// end of generated patch +/* start of original code          return getCumPct((Comparable<?>) v); + end of original code*/      }        /**
0,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && (f1 * fx < 0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
0,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if (fa * fb>0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,"public abstract class CharSequenceTranslator {  //          // contract with translators is that they have to understand codepoints   //          // and they just took care of a surrogate pair              for (int pt = 0; pt < consumed; pt++) { -                pos += Character.charCount(Character.codePointAt(input, pos)); +                pos += Character.charCount(Character.codePointAt(input, pt));              }          }      }"
0,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((x == x1) && !(true)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
0,"public class EigenDecompositionImpl implements EigenDecomposition {      private boolean flipIfWarranted(final int n, final int step) {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {              // flip array -            int j = 4 * n - 1; +            int j = 4 * (n - 1);              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];"
0,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +        if (dataset == null) {              return result;          }          int seriesCount = dataset.getRowCount();
0,"public abstract class BaseSecantSolver                      break;                  case REGULA_FALSI:                      // Nothing. -                    if (x == x1) { +                    if ((f1 * fx < 0)) {                          x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                          f0 = computeObjectiveValue(x0);                      }"
0,-		if (dataset != null) { +		if (dataset == null) {
0,"public class GaussianFitter extends CurveFitter {       */      public double[] fit() {          final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +        return fit(guess);      }        /**"
0,public class Frequency implements Serializable {       */      @Deprecated      public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +        return getPct((Comparable<?>) v);      }        /**
0,-        if (fa * fb >= 0.0 ) { +		if ((fa * fb) > 0.0) {
0,"public class ArgumentMatchingTool {      }        private boolean toStringEquals(Matcher m, Object arg) { -        return StringDescription.toString(m).equals(arg.toString()); +        if (!(StringDescription.toString(m) != null && m != null && arg != null)) return false; +return StringDescription.toString(m).equals(arg.toString());      }  }"
0,"public class Same extends ArgumentMatcher<Object> implements Serializable {      public void describeTo(Description description) {          description.appendText(""same("");          appendQuoting(description); -        description.appendText(wanted.toString()); +        if (wanted != null) { +	description.appendText(wanted.toString()); +} +          appendQuoting(description);          description.appendText("")"");      }"
0,Node callee = node.getFirstChild();        if (callee != null && callee.getType() == Token.GETPROP) {          String qualifiedName = callee.getQualifiedName(); +// start of generated patch +if(functionName.equals(qualifiedName)){ +Node target=callee.getNext(); +if(target!=null&&target.getType()==Token.STRING){ +className=target.getString(); +} +} +// end of generated patch +/* start of original code          if (functionName.equals(qualifiedName)) {            Node target = callee.getNext();            if (target != null) {              className = target.getString();            }          } + end of original code*/        }      }      return className;
0,"// If we are coming out of the FINALLY block...          } else if (parent.getLastChild() == node){            if (cfa != null) { +// start of generated patch +for(Node finallyNode : cfa.finallyMap.get(parent)){ +cfa.createEdge(fromNode,Branch.ON_EX,finallyNode); +} +// end of generated patch +/* start of original code              for (Node finallyNode : cfa.finallyMap.get(parent)) {                cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);              } + end of original code*/            }            return computeFollowNode(fromNode, parent, cfa);          }"
0,"-        throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +	org.apache.commons.math.MaxIterationsExceededException, org.apache.commons.math.FunctionEvaluationException { 		return solve(f, min, max); +"
0,"public class MultivariateNormalDistribution              throw new DimensionMismatchException(vals.length, dim);          }   -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +        return FastMath.pow(2 * FastMath.PI, -dim / 2f) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      }"
0,if (this.plot == null) {              return result;          } +// start of generated patch +int index=this.plot.getIndexOf(this); +CategoryDataset dataset=this.plot.getDataset(index); +if(plot==null){ +return null; +} +if(dataset==null){ +return result; +} +// end of generated patch +/* start of original code          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index);          if (dataset != null) {              return result;          } + end of original code*/          int seriesCount = dataset.getRowCount();          if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {              for (int i = 0; i < seriesCount; i++) {
0,return ArrayUtils.EMPTY_CLASS_ARRAY;          }          Class<?>[] classes = new Class[array.length]; +// start of generated patch +for(int i=0;i<array.length;i++){ +classes[i]=array[i]==null?null:array[i].getClass(); +} +// end of generated patch +/* start of original code          for (int i = 0; i < array.length; i++) {              classes[i] = array[i].getClass();          } + end of original code*/          return classes;      }
0,"public class UnivariateRealSolverUtils {          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound)));      -        if (fa * fb >= 0.0 ) { +        if ((fa * fb >= 0.0) && ((fa * fb > 0.0)) ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +"
0,String qualifiedName = callee.getQualifiedName();          if (functionName.equals(qualifiedName)) {            Node target = callee.getNext(); +// start of generated patch +if(target!=null&&target.getType()==Token.STRING){ +className=target.getString(); +} +// end of generated patch +/* start of original code            if (target != null) {              className = target.getString();            } + end of original code*/          }        }      }
0,} -            stopTime = System.currentTimeMillis(); +            if (this.STATE_SUSPENDED != this.runningState) { +                stopTime = System.currentTimeMillis(); +            }          this.runningState = STATE_STOPPED;
0,return NaN;          }   +// start of generated patch +if(real==0.0&&imaginary==0.0){ +return INF; +} +// end of generated patch +/* start of original code          if (real == 0.0 && imaginary == 0.0) {              return NaN;          } + end of original code*/            if (isInfinite) {              return ZERO;
0,"public class BisectionSolver extends UnivariateRealSolverImpl {      /** {@inheritDoc} */      public double solve(final UnivariateRealFunction f, double min, double max, double initial)          throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +        return solve(f, min, max);      }        /** {@inheritDoc} */"
0,}          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); +// start of generated patch +if(dataset==null){ +return result; +} +// end of generated patch +/* start of original code          if (dataset != null) {              return result;          } + end of original code*/          int seriesCount = dataset.getRowCount();          if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {              for (int i = 0; i < seriesCount; i++) {
